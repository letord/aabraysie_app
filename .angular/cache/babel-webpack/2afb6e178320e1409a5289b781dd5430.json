{"ast":null,"code":"import { createRequire as __cjsCompatRequire } from 'module';\n\nconst require = __cjsCompatRequire(import.meta.url);\n\nconst __ESM_IMPORT_META_URL__ = import.meta.url;\nimport { ClassMemberKind, Decorator, KnownDeclaration, filterToMembersWithDecorator, isConcreteDeclaration, isNamedClassDeclaration, reflectObjectLiteral, reflectTypeEntityToDeclaration, typeNodeToValueExpr } from \"./chunk-5QEO6HSG.js\";\nimport { ImportFlags, ImportManager, Reference, attachDefaultImportDeclaration, createExportSpecifier, getDefaultImportDeclaration, getSourceFile, identifierOfNode, isDeclaration, nodeDebugInfo, translateExpression, translateStatement, translateType } from \"./chunk-C2DR5MYL.js\";\nimport { absoluteFrom, absoluteFromSourceFile, relative } from \"./chunk-TI3THPMZ.js\";\nimport { PerfEvent, PerfPhase } from \"./chunk-J6CW3T62.js\";\nimport { __spreadProps, __spreadValues } from \"./chunk-XA5IZLLC.js\"; // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/partial_evaluator/src/dynamic.mjs\n\nvar DynamicValue = class {\n  constructor(node, reason, code) {\n    this.node = node;\n    this.reason = reason;\n    this.code = code;\n  }\n\n  static fromDynamicInput(node, input) {\n    return new DynamicValue(node, input, 0);\n  }\n\n  static fromDynamicString(node) {\n    return new DynamicValue(node, void 0, 1);\n  }\n\n  static fromExternalReference(node, ref) {\n    return new DynamicValue(node, ref, 2);\n  }\n\n  static fromUnsupportedSyntax(node) {\n    return new DynamicValue(node, void 0, 3);\n  }\n\n  static fromUnknownIdentifier(node) {\n    return new DynamicValue(node, void 0, 4);\n  }\n\n  static fromInvalidExpressionType(node, value) {\n    return new DynamicValue(node, value, 5);\n  }\n\n  static fromComplexFunctionCall(node, fn) {\n    return new DynamicValue(node, fn, 6);\n  }\n\n  static fromDynamicType(node) {\n    return new DynamicValue(node, void 0, 7);\n  }\n\n  static fromUnknown(node) {\n    return new DynamicValue(node, void 0, 8);\n  }\n\n  isFromDynamicInput() {\n    return this.code === 0;\n  }\n\n  isFromDynamicString() {\n    return this.code === 1;\n  }\n\n  isFromExternalReference() {\n    return this.code === 2;\n  }\n\n  isFromUnsupportedSyntax() {\n    return this.code === 3;\n  }\n\n  isFromUnknownIdentifier() {\n    return this.code === 4;\n  }\n\n  isFromInvalidExpressionType() {\n    return this.code === 5;\n  }\n\n  isFromComplexFunctionCall() {\n    return this.code === 6;\n  }\n\n  isFromDynamicType() {\n    return this.code === 7;\n  }\n\n  isFromUnknown() {\n    return this.code === 8;\n  }\n\n  accept(visitor) {\n    switch (this.code) {\n      case 0:\n        return visitor.visitDynamicInput(this);\n\n      case 1:\n        return visitor.visitDynamicString(this);\n\n      case 2:\n        return visitor.visitExternalReference(this);\n\n      case 3:\n        return visitor.visitUnsupportedSyntax(this);\n\n      case 4:\n        return visitor.visitUnknownIdentifier(this);\n\n      case 5:\n        return visitor.visitInvalidExpressionType(this);\n\n      case 6:\n        return visitor.visitComplexFunctionCall(this);\n\n      case 7:\n        return visitor.visitDynamicType(this);\n\n      case 8:\n        return visitor.visitUnknown(this);\n    }\n  }\n\n}; // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/partial_evaluator/src/interpreter.mjs\n\nimport ts from \"typescript\"; // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/partial_evaluator/src/result.mjs\n\nvar ResolvedModule = class {\n  constructor(exports, evaluate) {\n    this.exports = exports;\n    this.evaluate = evaluate;\n  }\n\n  getExport(name) {\n    if (!this.exports.has(name)) {\n      return void 0;\n    }\n\n    return this.evaluate(this.exports.get(name));\n  }\n\n  getExports() {\n    const map = new Map();\n    this.exports.forEach((decl, name) => {\n      map.set(name, this.evaluate(decl));\n    });\n    return map;\n  }\n\n};\nvar EnumValue = class {\n  constructor(enumRef, name, resolved) {\n    this.enumRef = enumRef;\n    this.name = name;\n    this.resolved = resolved;\n  }\n\n};\nvar KnownFn = class {}; // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/partial_evaluator/src/builtin.mjs\n\nvar ArraySliceBuiltinFn = class extends KnownFn {\n  constructor(lhs) {\n    super();\n    this.lhs = lhs;\n  }\n\n  evaluate(node, args) {\n    if (args.length === 0) {\n      return this.lhs;\n    } else {\n      return DynamicValue.fromUnknown(node);\n    }\n  }\n\n};\nvar ArrayConcatBuiltinFn = class extends KnownFn {\n  constructor(lhs) {\n    super();\n    this.lhs = lhs;\n  }\n\n  evaluate(node, args) {\n    const result = [...this.lhs];\n\n    for (const arg of args) {\n      if (arg instanceof DynamicValue) {\n        result.push(DynamicValue.fromDynamicInput(node, arg));\n      } else if (Array.isArray(arg)) {\n        result.push(...arg);\n      } else {\n        result.push(arg);\n      }\n    }\n\n    return result;\n  }\n\n};\nvar StringConcatBuiltinFn = class extends KnownFn {\n  constructor(lhs) {\n    super();\n    this.lhs = lhs;\n  }\n\n  evaluate(node, args) {\n    let result = this.lhs;\n\n    for (const arg of args) {\n      const resolved = arg instanceof EnumValue ? arg.resolved : arg;\n\n      if (typeof resolved === \"string\" || typeof resolved === \"number\" || typeof resolved === \"boolean\" || resolved == null) {\n        result = result.concat(resolved);\n      } else {\n        return DynamicValue.fromUnknown(node);\n      }\n    }\n\n    return result;\n  }\n\n};\nvar ObjectAssignBuiltinFn = class extends KnownFn {\n  evaluate(node, args) {\n    if (args.length === 0) {\n      return DynamicValue.fromUnsupportedSyntax(node);\n    }\n\n    for (const arg of args) {\n      if (arg instanceof DynamicValue) {\n        return DynamicValue.fromDynamicInput(node, arg);\n      } else if (!(arg instanceof Map)) {\n        return DynamicValue.fromUnsupportedSyntax(node);\n      }\n    }\n\n    const [target, ...sources] = args;\n\n    for (const source of sources) {\n      source.forEach((value, key) => target.set(key, value));\n    }\n\n    return target;\n  }\n\n}; // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/partial_evaluator/src/ts_helpers.mjs\n\nvar AssignHelperFn = class extends ObjectAssignBuiltinFn {};\nvar SpreadHelperFn = class extends KnownFn {\n  evaluate(node, args) {\n    const result = [];\n\n    for (const arg of args) {\n      if (arg instanceof DynamicValue) {\n        result.push(DynamicValue.fromDynamicInput(node, arg));\n      } else if (Array.isArray(arg)) {\n        result.push(...arg);\n      } else {\n        result.push(arg);\n      }\n    }\n\n    return result;\n  }\n\n};\nvar SpreadArrayHelperFn = class extends KnownFn {\n  evaluate(node, args) {\n    if (args.length !== 2 && args.length !== 3) {\n      return DynamicValue.fromUnknown(node);\n    }\n\n    const [to, from] = args;\n\n    if (to instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, to);\n    } else if (from instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, from);\n    }\n\n    if (!Array.isArray(to)) {\n      return DynamicValue.fromInvalidExpressionType(node, to);\n    } else if (!Array.isArray(from)) {\n      return DynamicValue.fromInvalidExpressionType(node, from);\n    }\n\n    return to.concat(from);\n  }\n\n};\nvar ReadHelperFn = class extends KnownFn {\n  evaluate(node, args) {\n    if (args.length !== 1) {\n      return DynamicValue.fromUnknown(node);\n    }\n\n    const [value] = args;\n\n    if (value instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, value);\n    }\n\n    if (!Array.isArray(value)) {\n      return DynamicValue.fromInvalidExpressionType(node, value);\n    }\n\n    return value;\n  }\n\n}; // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/partial_evaluator/src/known_declaration.mjs\n\nvar jsGlobalObjectValue = new Map([[\"assign\", new ObjectAssignBuiltinFn()]]);\nvar assignTsHelperFn = new AssignHelperFn();\nvar spreadTsHelperFn = new SpreadHelperFn();\nvar spreadArrayTsHelperFn = new SpreadArrayHelperFn();\nvar readTsHelperFn = new ReadHelperFn();\n\nfunction resolveKnownDeclaration(decl) {\n  switch (decl) {\n    case KnownDeclaration.JsGlobalObject:\n      return jsGlobalObjectValue;\n\n    case KnownDeclaration.TsHelperAssign:\n      return assignTsHelperFn;\n\n    case KnownDeclaration.TsHelperSpread:\n    case KnownDeclaration.TsHelperSpreadArrays:\n      return spreadTsHelperFn;\n\n    case KnownDeclaration.TsHelperSpreadArray:\n      return spreadArrayTsHelperFn;\n\n    case KnownDeclaration.TsHelperRead:\n      return readTsHelperFn;\n\n    default:\n      throw new Error(`Cannot resolve known declaration. Received: ${KnownDeclaration[decl]}.`);\n  }\n} // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/partial_evaluator/src/interpreter.mjs\n\n\nfunction literalBinaryOp(op) {\n  return {\n    op,\n    literal: true\n  };\n}\n\nfunction referenceBinaryOp(op) {\n  return {\n    op,\n    literal: false\n  };\n}\n\nvar BINARY_OPERATORS = new Map([[ts.SyntaxKind.PlusToken, literalBinaryOp((a, b) => a + b)], [ts.SyntaxKind.MinusToken, literalBinaryOp((a, b) => a - b)], [ts.SyntaxKind.AsteriskToken, literalBinaryOp((a, b) => a * b)], [ts.SyntaxKind.SlashToken, literalBinaryOp((a, b) => a / b)], [ts.SyntaxKind.PercentToken, literalBinaryOp((a, b) => a % b)], [ts.SyntaxKind.AmpersandToken, literalBinaryOp((a, b) => a & b)], [ts.SyntaxKind.BarToken, literalBinaryOp((a, b) => a | b)], [ts.SyntaxKind.CaretToken, literalBinaryOp((a, b) => a ^ b)], [ts.SyntaxKind.LessThanToken, literalBinaryOp((a, b) => a < b)], [ts.SyntaxKind.LessThanEqualsToken, literalBinaryOp((a, b) => a <= b)], [ts.SyntaxKind.GreaterThanToken, literalBinaryOp((a, b) => a > b)], [ts.SyntaxKind.GreaterThanEqualsToken, literalBinaryOp((a, b) => a >= b)], [ts.SyntaxKind.EqualsEqualsToken, literalBinaryOp((a, b) => a == b)], [ts.SyntaxKind.EqualsEqualsEqualsToken, literalBinaryOp((a, b) => a === b)], [ts.SyntaxKind.ExclamationEqualsToken, literalBinaryOp((a, b) => a != b)], [ts.SyntaxKind.ExclamationEqualsEqualsToken, literalBinaryOp((a, b) => a !== b)], [ts.SyntaxKind.LessThanLessThanToken, literalBinaryOp((a, b) => a << b)], [ts.SyntaxKind.GreaterThanGreaterThanToken, literalBinaryOp((a, b) => a >> b)], [ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken, literalBinaryOp((a, b) => a >>> b)], [ts.SyntaxKind.AsteriskAsteriskToken, literalBinaryOp((a, b) => Math.pow(a, b))], [ts.SyntaxKind.AmpersandAmpersandToken, referenceBinaryOp((a, b) => a && b)], [ts.SyntaxKind.BarBarToken, referenceBinaryOp((a, b) => a || b)]]);\nvar UNARY_OPERATORS = new Map([[ts.SyntaxKind.TildeToken, a => ~a], [ts.SyntaxKind.MinusToken, a => -a], [ts.SyntaxKind.PlusToken, a => +a], [ts.SyntaxKind.ExclamationToken, a => !a]]);\nvar StaticInterpreter = class {\n  constructor(host, checker, dependencyTracker) {\n    this.host = host;\n    this.checker = checker;\n    this.dependencyTracker = dependencyTracker;\n  }\n\n  visit(node, context) {\n    return this.visitExpression(node, context);\n  }\n\n  visitExpression(node, context) {\n    let result;\n\n    if (node.kind === ts.SyntaxKind.TrueKeyword) {\n      return true;\n    } else if (node.kind === ts.SyntaxKind.FalseKeyword) {\n      return false;\n    } else if (node.kind === ts.SyntaxKind.NullKeyword) {\n      return null;\n    } else if (ts.isStringLiteral(node)) {\n      return node.text;\n    } else if (ts.isNoSubstitutionTemplateLiteral(node)) {\n      return node.text;\n    } else if (ts.isTemplateExpression(node)) {\n      result = this.visitTemplateExpression(node, context);\n    } else if (ts.isNumericLiteral(node)) {\n      return parseFloat(node.text);\n    } else if (ts.isObjectLiteralExpression(node)) {\n      result = this.visitObjectLiteralExpression(node, context);\n    } else if (ts.isIdentifier(node)) {\n      result = this.visitIdentifier(node, context);\n    } else if (ts.isPropertyAccessExpression(node)) {\n      result = this.visitPropertyAccessExpression(node, context);\n    } else if (ts.isCallExpression(node)) {\n      result = this.visitCallExpression(node, context);\n    } else if (ts.isConditionalExpression(node)) {\n      result = this.visitConditionalExpression(node, context);\n    } else if (ts.isPrefixUnaryExpression(node)) {\n      result = this.visitPrefixUnaryExpression(node, context);\n    } else if (ts.isBinaryExpression(node)) {\n      result = this.visitBinaryExpression(node, context);\n    } else if (ts.isArrayLiteralExpression(node)) {\n      result = this.visitArrayLiteralExpression(node, context);\n    } else if (ts.isParenthesizedExpression(node)) {\n      result = this.visitParenthesizedExpression(node, context);\n    } else if (ts.isElementAccessExpression(node)) {\n      result = this.visitElementAccessExpression(node, context);\n    } else if (ts.isAsExpression(node)) {\n      result = this.visitExpression(node.expression, context);\n    } else if (ts.isNonNullExpression(node)) {\n      result = this.visitExpression(node.expression, context);\n    } else if (this.host.isClass(node)) {\n      result = this.visitDeclaration(node, context);\n    } else {\n      return DynamicValue.fromUnsupportedSyntax(node);\n    }\n\n    if (result instanceof DynamicValue && result.node !== node) {\n      return DynamicValue.fromDynamicInput(node, result);\n    }\n\n    return result;\n  }\n\n  visitArrayLiteralExpression(node, context) {\n    const array = [];\n\n    for (let i = 0; i < node.elements.length; i++) {\n      const element = node.elements[i];\n\n      if (ts.isSpreadElement(element)) {\n        array.push(...this.visitSpreadElement(element, context));\n      } else {\n        array.push(this.visitExpression(element, context));\n      }\n    }\n\n    return array;\n  }\n\n  visitObjectLiteralExpression(node, context) {\n    const map = new Map();\n\n    for (let i = 0; i < node.properties.length; i++) {\n      const property = node.properties[i];\n\n      if (ts.isPropertyAssignment(property)) {\n        const name = this.stringNameFromPropertyName(property.name, context);\n\n        if (name === void 0) {\n          return DynamicValue.fromDynamicInput(node, DynamicValue.fromDynamicString(property.name));\n        }\n\n        map.set(name, this.visitExpression(property.initializer, context));\n      } else if (ts.isShorthandPropertyAssignment(property)) {\n        const symbol = this.checker.getShorthandAssignmentValueSymbol(property);\n\n        if (symbol === void 0 || symbol.valueDeclaration === void 0) {\n          map.set(property.name.text, DynamicValue.fromUnknown(property));\n        } else {\n          map.set(property.name.text, this.visitDeclaration(symbol.valueDeclaration, context));\n        }\n      } else if (ts.isSpreadAssignment(property)) {\n        const spread = this.visitExpression(property.expression, context);\n\n        if (spread instanceof DynamicValue) {\n          return DynamicValue.fromDynamicInput(node, spread);\n        } else if (spread instanceof Map) {\n          spread.forEach((value, key) => map.set(key, value));\n        } else if (spread instanceof ResolvedModule) {\n          spread.getExports().forEach((value, key) => map.set(key, value));\n        } else {\n          return DynamicValue.fromDynamicInput(node, DynamicValue.fromInvalidExpressionType(property, spread));\n        }\n      } else {\n        return DynamicValue.fromUnknown(node);\n      }\n    }\n\n    return map;\n  }\n\n  visitTemplateExpression(node, context) {\n    const pieces = [node.head.text];\n\n    for (let i = 0; i < node.templateSpans.length; i++) {\n      const span = node.templateSpans[i];\n      const value = literal(this.visit(span.expression, context), () => DynamicValue.fromDynamicString(span.expression));\n\n      if (value instanceof DynamicValue) {\n        return DynamicValue.fromDynamicInput(node, value);\n      }\n\n      pieces.push(`${value}`, span.literal.text);\n    }\n\n    return pieces.join(\"\");\n  }\n\n  visitIdentifier(node, context) {\n    const decl = this.host.getDeclarationOfIdentifier(node);\n\n    if (decl === null) {\n      if (node.originalKeywordKind === ts.SyntaxKind.UndefinedKeyword) {\n        return void 0;\n      } else {\n        if (this.dependencyTracker !== null && this.host.getImportOfIdentifier(node) !== null) {\n          this.dependencyTracker.recordDependencyAnalysisFailure(context.originatingFile);\n        }\n\n        return DynamicValue.fromUnknownIdentifier(node);\n      }\n    }\n\n    if (decl.known !== null) {\n      return resolveKnownDeclaration(decl.known);\n    } else if (isConcreteDeclaration(decl) && decl.identity !== null && decl.identity.kind === 0) {\n      return this.getResolvedEnum(decl.node, decl.identity.enumMembers, context);\n    }\n\n    const declContext = __spreadValues(__spreadValues({}, context), joinModuleContext(context, node, decl));\n\n    const result = this.visitAmbiguousDeclaration(decl, declContext);\n\n    if (result instanceof Reference) {\n      if (!result.synthetic) {\n        result.addIdentifier(node);\n      }\n    } else if (result instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, result);\n    }\n\n    return result;\n  }\n\n  visitDeclaration(node, context) {\n    if (this.dependencyTracker !== null) {\n      this.dependencyTracker.addDependency(context.originatingFile, node.getSourceFile());\n    }\n\n    if (this.host.isClass(node)) {\n      return this.getReference(node, context);\n    } else if (ts.isVariableDeclaration(node)) {\n      return this.visitVariableDeclaration(node, context);\n    } else if (ts.isParameter(node) && context.scope.has(node)) {\n      return context.scope.get(node);\n    } else if (ts.isExportAssignment(node)) {\n      return this.visitExpression(node.expression, context);\n    } else if (ts.isEnumDeclaration(node)) {\n      return this.visitEnumDeclaration(node, context);\n    } else if (ts.isSourceFile(node)) {\n      return this.visitSourceFile(node, context);\n    } else if (ts.isBindingElement(node)) {\n      return this.visitBindingElement(node, context);\n    } else {\n      return this.getReference(node, context);\n    }\n  }\n\n  visitVariableDeclaration(node, context) {\n    const value = this.host.getVariableValue(node);\n\n    if (value !== null) {\n      return this.visitExpression(value, context);\n    } else if (isVariableDeclarationDeclared(node)) {\n      if (node.type !== void 0) {\n        const evaluatedType = this.visitType(node.type, context);\n\n        if (!(evaluatedType instanceof DynamicValue)) {\n          return evaluatedType;\n        }\n      }\n\n      return this.getReference(node, context);\n    } else {\n      return void 0;\n    }\n  }\n\n  visitEnumDeclaration(node, context) {\n    const enumRef = this.getReference(node, context);\n    const map = new Map();\n    node.members.forEach(member => {\n      const name = this.stringNameFromPropertyName(member.name, context);\n\n      if (name !== void 0) {\n        const resolved = member.initializer && this.visit(member.initializer, context);\n        map.set(name, new EnumValue(enumRef, name, resolved));\n      }\n    });\n    return map;\n  }\n\n  visitElementAccessExpression(node, context) {\n    const lhs = this.visitExpression(node.expression, context);\n\n    if (lhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, lhs);\n    }\n\n    const rhs = this.visitExpression(node.argumentExpression, context);\n\n    if (rhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, rhs);\n    }\n\n    if (typeof rhs !== \"string\" && typeof rhs !== \"number\") {\n      return DynamicValue.fromInvalidExpressionType(node, rhs);\n    }\n\n    return this.accessHelper(node, lhs, rhs, context);\n  }\n\n  visitPropertyAccessExpression(node, context) {\n    const lhs = this.visitExpression(node.expression, context);\n    const rhs = node.name.text;\n\n    if (lhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, lhs);\n    }\n\n    return this.accessHelper(node, lhs, rhs, context);\n  }\n\n  visitSourceFile(node, context) {\n    const declarations = this.host.getExportsOfModule(node);\n\n    if (declarations === null) {\n      return DynamicValue.fromUnknown(node);\n    }\n\n    return new ResolvedModule(declarations, decl => {\n      if (decl.known !== null) {\n        return resolveKnownDeclaration(decl.known);\n      }\n\n      const declContext = __spreadValues(__spreadValues({}, context), joinModuleContext(context, node, decl));\n\n      return this.visitAmbiguousDeclaration(decl, declContext);\n    });\n  }\n\n  visitAmbiguousDeclaration(decl, declContext) {\n    return decl.kind === 1 && decl.implementation !== void 0 && !isDeclaration(decl.implementation) ? this.visitExpression(decl.implementation, declContext) : this.visitDeclaration(decl.node, declContext);\n  }\n\n  accessHelper(node, lhs, rhs, context) {\n    const strIndex = `${rhs}`;\n\n    if (lhs instanceof Map) {\n      if (lhs.has(strIndex)) {\n        return lhs.get(strIndex);\n      } else {\n        return void 0;\n      }\n    } else if (lhs instanceof ResolvedModule) {\n      return lhs.getExport(strIndex);\n    } else if (Array.isArray(lhs)) {\n      if (rhs === \"length\") {\n        return lhs.length;\n      } else if (rhs === \"slice\") {\n        return new ArraySliceBuiltinFn(lhs);\n      } else if (rhs === \"concat\") {\n        return new ArrayConcatBuiltinFn(lhs);\n      }\n\n      if (typeof rhs !== \"number\" || !Number.isInteger(rhs)) {\n        return DynamicValue.fromInvalidExpressionType(node, rhs);\n      }\n\n      return lhs[rhs];\n    } else if (typeof lhs === \"string\" && rhs === \"concat\") {\n      return new StringConcatBuiltinFn(lhs);\n    } else if (lhs instanceof Reference) {\n      const ref = lhs.node;\n\n      if (this.host.isClass(ref)) {\n        const module = owningModule(context, lhs.bestGuessOwningModule);\n        let value = void 0;\n        const member = this.host.getMembersOfClass(ref).find(member2 => member2.isStatic && member2.name === strIndex);\n\n        if (member !== void 0) {\n          if (member.value !== null) {\n            value = this.visitExpression(member.value, context);\n          } else if (member.implementation !== null) {\n            value = new Reference(member.implementation, module);\n          } else if (member.node) {\n            value = new Reference(member.node, module);\n          }\n        }\n\n        return value;\n      } else if (isDeclaration(ref)) {\n        return DynamicValue.fromDynamicInput(node, DynamicValue.fromExternalReference(ref, lhs));\n      }\n    } else if (lhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, lhs);\n    }\n\n    return DynamicValue.fromUnknown(node);\n  }\n\n  visitCallExpression(node, context) {\n    const lhs = this.visitExpression(node.expression, context);\n\n    if (lhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, lhs);\n    }\n\n    if (lhs instanceof KnownFn) {\n      return lhs.evaluate(node, this.evaluateFunctionArguments(node, context));\n    }\n\n    if (!(lhs instanceof Reference)) {\n      return DynamicValue.fromInvalidExpressionType(node.expression, lhs);\n    }\n\n    const fn = this.host.getDefinitionOfFunction(lhs.node);\n\n    if (fn === null) {\n      return DynamicValue.fromInvalidExpressionType(node.expression, lhs);\n    }\n\n    if (!isFunctionOrMethodReference(lhs)) {\n      return DynamicValue.fromInvalidExpressionType(node.expression, lhs);\n    }\n\n    if (fn.body === null) {\n      let expr = null;\n\n      if (context.foreignFunctionResolver) {\n        expr = context.foreignFunctionResolver(lhs, node.arguments);\n      }\n\n      if (expr === null) {\n        return DynamicValue.fromDynamicInput(node, DynamicValue.fromExternalReference(node.expression, lhs));\n      }\n\n      if (expr.getSourceFile() !== node.expression.getSourceFile() && lhs.bestGuessOwningModule !== null) {\n        context = __spreadProps(__spreadValues({}, context), {\n          absoluteModuleName: lhs.bestGuessOwningModule.specifier,\n          resolutionContext: lhs.bestGuessOwningModule.resolutionContext\n        });\n      }\n\n      return this.visitFfrExpression(expr, context);\n    }\n\n    let res = this.visitFunctionBody(node, fn, context);\n\n    if (res instanceof DynamicValue && context.foreignFunctionResolver !== void 0) {\n      const ffrExpr = context.foreignFunctionResolver(lhs, node.arguments);\n\n      if (ffrExpr !== null) {\n        const ffrRes = this.visitFfrExpression(ffrExpr, context);\n\n        if (!(ffrRes instanceof DynamicValue)) {\n          res = ffrRes;\n        }\n      }\n    }\n\n    return res;\n  }\n\n  visitFfrExpression(expr, context) {\n    const res = this.visitExpression(expr, context);\n\n    if (res instanceof Reference) {\n      res.synthetic = true;\n    }\n\n    return res;\n  }\n\n  visitFunctionBody(node, fn, context) {\n    if (fn.body === null) {\n      return DynamicValue.fromUnknown(node);\n    } else if (fn.body.length !== 1 || !ts.isReturnStatement(fn.body[0])) {\n      return DynamicValue.fromComplexFunctionCall(node, fn);\n    }\n\n    const ret = fn.body[0];\n    const args = this.evaluateFunctionArguments(node, context);\n    const newScope = new Map();\n\n    const calleeContext = __spreadProps(__spreadValues({}, context), {\n      scope: newScope\n    });\n\n    fn.parameters.forEach((param, index) => {\n      let arg = args[index];\n\n      if (param.node.dotDotDotToken !== void 0) {\n        arg = args.slice(index);\n      }\n\n      if (arg === void 0 && param.initializer !== null) {\n        arg = this.visitExpression(param.initializer, calleeContext);\n      }\n\n      newScope.set(param.node, arg);\n    });\n    return ret.expression !== void 0 ? this.visitExpression(ret.expression, calleeContext) : void 0;\n  }\n\n  visitConditionalExpression(node, context) {\n    const condition = this.visitExpression(node.condition, context);\n\n    if (condition instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, condition);\n    }\n\n    if (condition) {\n      return this.visitExpression(node.whenTrue, context);\n    } else {\n      return this.visitExpression(node.whenFalse, context);\n    }\n  }\n\n  visitPrefixUnaryExpression(node, context) {\n    const operatorKind = node.operator;\n\n    if (!UNARY_OPERATORS.has(operatorKind)) {\n      return DynamicValue.fromUnsupportedSyntax(node);\n    }\n\n    const op = UNARY_OPERATORS.get(operatorKind);\n    const value = this.visitExpression(node.operand, context);\n\n    if (value instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, value);\n    } else {\n      return op(value);\n    }\n  }\n\n  visitBinaryExpression(node, context) {\n    const tokenKind = node.operatorToken.kind;\n\n    if (!BINARY_OPERATORS.has(tokenKind)) {\n      return DynamicValue.fromUnsupportedSyntax(node);\n    }\n\n    const opRecord = BINARY_OPERATORS.get(tokenKind);\n    let lhs, rhs;\n\n    if (opRecord.literal) {\n      lhs = literal(this.visitExpression(node.left, context), value => DynamicValue.fromInvalidExpressionType(node.left, value));\n      rhs = literal(this.visitExpression(node.right, context), value => DynamicValue.fromInvalidExpressionType(node.right, value));\n    } else {\n      lhs = this.visitExpression(node.left, context);\n      rhs = this.visitExpression(node.right, context);\n    }\n\n    if (lhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, lhs);\n    } else if (rhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, rhs);\n    } else {\n      return opRecord.op(lhs, rhs);\n    }\n  }\n\n  visitParenthesizedExpression(node, context) {\n    return this.visitExpression(node.expression, context);\n  }\n\n  evaluateFunctionArguments(node, context) {\n    const args = [];\n\n    for (const arg of node.arguments) {\n      if (ts.isSpreadElement(arg)) {\n        args.push(...this.visitSpreadElement(arg, context));\n      } else {\n        args.push(this.visitExpression(arg, context));\n      }\n    }\n\n    return args;\n  }\n\n  visitSpreadElement(node, context) {\n    const spread = this.visitExpression(node.expression, context);\n\n    if (spread instanceof DynamicValue) {\n      return [DynamicValue.fromDynamicInput(node, spread)];\n    } else if (!Array.isArray(spread)) {\n      return [DynamicValue.fromInvalidExpressionType(node, spread)];\n    } else {\n      return spread;\n    }\n  }\n\n  visitBindingElement(node, context) {\n    const path = [];\n    let closestDeclaration = node;\n\n    while (ts.isBindingElement(closestDeclaration) || ts.isArrayBindingPattern(closestDeclaration) || ts.isObjectBindingPattern(closestDeclaration)) {\n      if (ts.isBindingElement(closestDeclaration)) {\n        path.unshift(closestDeclaration);\n      }\n\n      closestDeclaration = closestDeclaration.parent;\n    }\n\n    if (!ts.isVariableDeclaration(closestDeclaration) || closestDeclaration.initializer === void 0) {\n      return DynamicValue.fromUnknown(node);\n    }\n\n    let value = this.visit(closestDeclaration.initializer, context);\n\n    for (const element of path) {\n      let key;\n\n      if (ts.isArrayBindingPattern(element.parent)) {\n        key = element.parent.elements.indexOf(element);\n      } else {\n        const name = element.propertyName || element.name;\n\n        if (ts.isIdentifier(name)) {\n          key = name.text;\n        } else {\n          return DynamicValue.fromUnknown(element);\n        }\n      }\n\n      value = this.accessHelper(element, value, key, context);\n\n      if (value instanceof DynamicValue) {\n        return value;\n      }\n    }\n\n    return value;\n  }\n\n  stringNameFromPropertyName(node, context) {\n    if (ts.isIdentifier(node) || ts.isStringLiteral(node) || ts.isNumericLiteral(node)) {\n      return node.text;\n    } else if (ts.isComputedPropertyName(node)) {\n      const literal2 = this.visitExpression(node.expression, context);\n      return typeof literal2 === \"string\" ? literal2 : void 0;\n    } else {\n      return void 0;\n    }\n  }\n\n  getResolvedEnum(node, enumMembers, context) {\n    const enumRef = this.getReference(node, context);\n    const map = new Map();\n    enumMembers.forEach(member => {\n      const name = this.stringNameFromPropertyName(member.name, context);\n\n      if (name !== void 0) {\n        const resolved = this.visit(member.initializer, context);\n        map.set(name, new EnumValue(enumRef, name, resolved));\n      }\n    });\n    return map;\n  }\n\n  getReference(node, context) {\n    return new Reference(node, owningModule(context));\n  }\n\n  visitType(node, context) {\n    if (ts.isLiteralTypeNode(node)) {\n      return this.visitExpression(node.literal, context);\n    } else if (ts.isTupleTypeNode(node)) {\n      return this.visitTupleType(node, context);\n    } else if (ts.isNamedTupleMember(node)) {\n      return this.visitType(node.type, context);\n    }\n\n    return DynamicValue.fromDynamicType(node);\n  }\n\n  visitTupleType(node, context) {\n    const res = [];\n\n    for (const elem of node.elements) {\n      res.push(this.visitType(elem, context));\n    }\n\n    return res;\n  }\n\n};\n\nfunction isFunctionOrMethodReference(ref) {\n  return ts.isFunctionDeclaration(ref.node) || ts.isMethodDeclaration(ref.node) || ts.isFunctionExpression(ref.node);\n}\n\nfunction literal(value, reject) {\n  if (value instanceof EnumValue) {\n    value = value.resolved;\n  }\n\n  if (value instanceof DynamicValue || value === null || value === void 0 || typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n    return value;\n  }\n\n  return reject(value);\n}\n\nfunction isVariableDeclarationDeclared(node) {\n  if (node.parent === void 0 || !ts.isVariableDeclarationList(node.parent)) {\n    return false;\n  }\n\n  const declList = node.parent;\n\n  if (declList.parent === void 0 || !ts.isVariableStatement(declList.parent)) {\n    return false;\n  }\n\n  const varStmt = declList.parent;\n  return varStmt.modifiers !== void 0 && varStmt.modifiers.some(mod => mod.kind === ts.SyntaxKind.DeclareKeyword);\n}\n\nvar EMPTY = {};\n\nfunction joinModuleContext(existing, node, decl) {\n  if (decl.viaModule !== null && decl.viaModule !== existing.absoluteModuleName) {\n    return {\n      absoluteModuleName: decl.viaModule,\n      resolutionContext: node.getSourceFile().fileName\n    };\n  } else {\n    return EMPTY;\n  }\n}\n\nfunction owningModule(context, override = null) {\n  let specifier = context.absoluteModuleName;\n\n  if (override !== null) {\n    specifier = override.specifier;\n  }\n\n  if (specifier !== null) {\n    return {\n      specifier,\n      resolutionContext: context.resolutionContext\n    };\n  } else {\n    return null;\n  }\n} // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/partial_evaluator/src/interface.mjs\n\n\nvar PartialEvaluator = class {\n  constructor(host, checker, dependencyTracker) {\n    this.host = host;\n    this.checker = checker;\n    this.dependencyTracker = dependencyTracker;\n  }\n\n  evaluate(expr, foreignFunctionResolver) {\n    const interpreter = new StaticInterpreter(this.host, this.checker, this.dependencyTracker);\n    const sourceFile = expr.getSourceFile();\n    return interpreter.visit(expr, {\n      originatingFile: sourceFile,\n      absoluteModuleName: null,\n      resolutionContext: sourceFile.fileName,\n      scope: new Map(),\n      foreignFunctionResolver\n    });\n  }\n\n}; // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/partial_evaluator/src/diagnostics.mjs\n\nimport ts3 from \"typescript\"; // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/diagnostics/src/error_code.mjs\n\nvar ErrorCode;\n\n(function (ErrorCode2) {\n  ErrorCode2[ErrorCode2[\"DECORATOR_ARG_NOT_LITERAL\"] = 1001] = \"DECORATOR_ARG_NOT_LITERAL\";\n  ErrorCode2[ErrorCode2[\"DECORATOR_ARITY_WRONG\"] = 1002] = \"DECORATOR_ARITY_WRONG\";\n  ErrorCode2[ErrorCode2[\"DECORATOR_NOT_CALLED\"] = 1003] = \"DECORATOR_NOT_CALLED\";\n  ErrorCode2[ErrorCode2[\"DECORATOR_ON_ANONYMOUS_CLASS\"] = 1004] = \"DECORATOR_ON_ANONYMOUS_CLASS\";\n  ErrorCode2[ErrorCode2[\"DECORATOR_UNEXPECTED\"] = 1005] = \"DECORATOR_UNEXPECTED\";\n  ErrorCode2[ErrorCode2[\"DECORATOR_COLLISION\"] = 1006] = \"DECORATOR_COLLISION\";\n  ErrorCode2[ErrorCode2[\"VALUE_HAS_WRONG_TYPE\"] = 1010] = \"VALUE_HAS_WRONG_TYPE\";\n  ErrorCode2[ErrorCode2[\"VALUE_NOT_LITERAL\"] = 1011] = \"VALUE_NOT_LITERAL\";\n  ErrorCode2[ErrorCode2[\"COMPONENT_MISSING_TEMPLATE\"] = 2001] = \"COMPONENT_MISSING_TEMPLATE\";\n  ErrorCode2[ErrorCode2[\"PIPE_MISSING_NAME\"] = 2002] = \"PIPE_MISSING_NAME\";\n  ErrorCode2[ErrorCode2[\"PARAM_MISSING_TOKEN\"] = 2003] = \"PARAM_MISSING_TOKEN\";\n  ErrorCode2[ErrorCode2[\"DIRECTIVE_MISSING_SELECTOR\"] = 2004] = \"DIRECTIVE_MISSING_SELECTOR\";\n  ErrorCode2[ErrorCode2[\"UNDECORATED_PROVIDER\"] = 2005] = \"UNDECORATED_PROVIDER\";\n  ErrorCode2[ErrorCode2[\"DIRECTIVE_INHERITS_UNDECORATED_CTOR\"] = 2006] = \"DIRECTIVE_INHERITS_UNDECORATED_CTOR\";\n  ErrorCode2[ErrorCode2[\"UNDECORATED_CLASS_USING_ANGULAR_FEATURES\"] = 2007] = \"UNDECORATED_CLASS_USING_ANGULAR_FEATURES\";\n  ErrorCode2[ErrorCode2[\"COMPONENT_RESOURCE_NOT_FOUND\"] = 2008] = \"COMPONENT_RESOURCE_NOT_FOUND\";\n  ErrorCode2[ErrorCode2[\"COMPONENT_INVALID_SHADOW_DOM_SELECTOR\"] = 2009] = \"COMPONENT_INVALID_SHADOW_DOM_SELECTOR\";\n  ErrorCode2[ErrorCode2[\"SYMBOL_NOT_EXPORTED\"] = 3001] = \"SYMBOL_NOT_EXPORTED\";\n  ErrorCode2[ErrorCode2[\"SYMBOL_EXPORTED_UNDER_DIFFERENT_NAME\"] = 3002] = \"SYMBOL_EXPORTED_UNDER_DIFFERENT_NAME\";\n  ErrorCode2[ErrorCode2[\"IMPORT_CYCLE_DETECTED\"] = 3003] = \"IMPORT_CYCLE_DETECTED\";\n  ErrorCode2[ErrorCode2[\"CONFIG_FLAT_MODULE_NO_INDEX\"] = 4001] = \"CONFIG_FLAT_MODULE_NO_INDEX\";\n  ErrorCode2[ErrorCode2[\"CONFIG_STRICT_TEMPLATES_IMPLIES_FULL_TEMPLATE_TYPECHECK\"] = 4002] = \"CONFIG_STRICT_TEMPLATES_IMPLIES_FULL_TEMPLATE_TYPECHECK\";\n  ErrorCode2[ErrorCode2[\"HOST_BINDING_PARSE_ERROR\"] = 5001] = \"HOST_BINDING_PARSE_ERROR\";\n  ErrorCode2[ErrorCode2[\"TEMPLATE_PARSE_ERROR\"] = 5002] = \"TEMPLATE_PARSE_ERROR\";\n  ErrorCode2[ErrorCode2[\"NGMODULE_INVALID_DECLARATION\"] = 6001] = \"NGMODULE_INVALID_DECLARATION\";\n  ErrorCode2[ErrorCode2[\"NGMODULE_INVALID_IMPORT\"] = 6002] = \"NGMODULE_INVALID_IMPORT\";\n  ErrorCode2[ErrorCode2[\"NGMODULE_INVALID_EXPORT\"] = 6003] = \"NGMODULE_INVALID_EXPORT\";\n  ErrorCode2[ErrorCode2[\"NGMODULE_INVALID_REEXPORT\"] = 6004] = \"NGMODULE_INVALID_REEXPORT\";\n  ErrorCode2[ErrorCode2[\"NGMODULE_MODULE_WITH_PROVIDERS_MISSING_GENERIC\"] = 6005] = \"NGMODULE_MODULE_WITH_PROVIDERS_MISSING_GENERIC\";\n  ErrorCode2[ErrorCode2[\"NGMODULE_REEXPORT_NAME_COLLISION\"] = 6006] = \"NGMODULE_REEXPORT_NAME_COLLISION\";\n  ErrorCode2[ErrorCode2[\"NGMODULE_DECLARATION_NOT_UNIQUE\"] = 6007] = \"NGMODULE_DECLARATION_NOT_UNIQUE\";\n  ErrorCode2[ErrorCode2[\"NGMODULE_VE_DEPENDENCY_ON_IVY_LIB\"] = 6999] = \"NGMODULE_VE_DEPENDENCY_ON_IVY_LIB\";\n  ErrorCode2[ErrorCode2[\"SCHEMA_INVALID_ELEMENT\"] = 8001] = \"SCHEMA_INVALID_ELEMENT\";\n  ErrorCode2[ErrorCode2[\"SCHEMA_INVALID_ATTRIBUTE\"] = 8002] = \"SCHEMA_INVALID_ATTRIBUTE\";\n  ErrorCode2[ErrorCode2[\"MISSING_REFERENCE_TARGET\"] = 8003] = \"MISSING_REFERENCE_TARGET\";\n  ErrorCode2[ErrorCode2[\"MISSING_PIPE\"] = 8004] = \"MISSING_PIPE\";\n  ErrorCode2[ErrorCode2[\"WRITE_TO_READ_ONLY_VARIABLE\"] = 8005] = \"WRITE_TO_READ_ONLY_VARIABLE\";\n  ErrorCode2[ErrorCode2[\"DUPLICATE_VARIABLE_DECLARATION\"] = 8006] = \"DUPLICATE_VARIABLE_DECLARATION\";\n  ErrorCode2[ErrorCode2[\"SPLIT_TWO_WAY_BINDING\"] = 8007] = \"SPLIT_TWO_WAY_BINDING\";\n  ErrorCode2[ErrorCode2[\"INVALID_BANANA_IN_BOX\"] = 8101] = \"INVALID_BANANA_IN_BOX\";\n  ErrorCode2[ErrorCode2[\"NULLISH_COALESCING_NOT_NULLABLE\"] = 8102] = \"NULLISH_COALESCING_NOT_NULLABLE\";\n  ErrorCode2[ErrorCode2[\"INLINE_TCB_REQUIRED\"] = 8900] = \"INLINE_TCB_REQUIRED\";\n  ErrorCode2[ErrorCode2[\"INLINE_TYPE_CTOR_REQUIRED\"] = 8901] = \"INLINE_TYPE_CTOR_REQUIRED\";\n  ErrorCode2[ErrorCode2[\"INJECTABLE_DUPLICATE_PROV\"] = 9001] = \"INJECTABLE_DUPLICATE_PROV\";\n  ErrorCode2[ErrorCode2[\"SUGGEST_STRICT_TEMPLATES\"] = 10001] = \"SUGGEST_STRICT_TEMPLATES\";\n  ErrorCode2[ErrorCode2[\"SUGGEST_SUBOPTIMAL_TYPE_INFERENCE\"] = 10002] = \"SUGGEST_SUBOPTIMAL_TYPE_INFERENCE\";\n})(ErrorCode || (ErrorCode = {})); // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/diagnostics/src/docs.mjs\n\n\nvar COMPILER_ERRORS_WITH_GUIDES = new Set([ErrorCode.DECORATOR_ARG_NOT_LITERAL, ErrorCode.IMPORT_CYCLE_DETECTED, ErrorCode.PARAM_MISSING_TOKEN, ErrorCode.SCHEMA_INVALID_ELEMENT, ErrorCode.SCHEMA_INVALID_ATTRIBUTE, ErrorCode.MISSING_REFERENCE_TARGET, ErrorCode.COMPONENT_INVALID_SHADOW_DOM_SELECTOR]); // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/diagnostics/src/error.mjs\n\nimport ts2 from \"typescript\"; // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/diagnostics/src/util.mjs\n\nvar ERROR_CODE_MATCHER = /(\\u001b\\[\\d+m ?)TS-99(\\d+: ?\\u001b\\[\\d+m)/g;\n\nfunction replaceTsWithNgInErrors(errors) {\n  return errors.replace(ERROR_CODE_MATCHER, \"$1NG$2\");\n}\n\nfunction ngErrorCode(code) {\n  return parseInt(\"-99\" + code);\n} // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/diagnostics/src/error.mjs\n\n\nvar FatalDiagnosticError = class {\n  constructor(code, node, message, relatedInformation) {\n    this.code = code;\n    this.node = node;\n    this.message = message;\n    this.relatedInformation = relatedInformation;\n    this._isFatalDiagnosticError = true;\n  }\n\n  toDiagnostic() {\n    return makeDiagnostic(this.code, this.node, this.message, this.relatedInformation);\n  }\n\n};\n\nfunction makeDiagnostic(code, node, messageText, relatedInformation) {\n  node = ts2.getOriginalNode(node);\n  return {\n    category: ts2.DiagnosticCategory.Error,\n    code: ngErrorCode(code),\n    file: ts2.getOriginalNode(node).getSourceFile(),\n    start: node.getStart(void 0, false),\n    length: node.getWidth(),\n    messageText,\n    relatedInformation\n  };\n}\n\nfunction makeRelatedInformation(node, messageText) {\n  node = ts2.getOriginalNode(node);\n  return {\n    category: ts2.DiagnosticCategory.Message,\n    code: 0,\n    file: node.getSourceFile(),\n    start: node.getStart(),\n    length: node.getWidth(),\n    messageText\n  };\n}\n\nfunction isFatalDiagnosticError(err) {\n  return err._isFatalDiagnosticError === true;\n} // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/diagnostics/src/error_details_base_url.mjs\n\n\nvar ERROR_DETAILS_PAGE_BASE_URL = \"https://angular.io/errors\"; // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/partial_evaluator/src/diagnostics.mjs\n\nfunction describeResolvedType(value, maxDepth = 1) {\n  var _a, _b;\n\n  if (value === null) {\n    return \"null\";\n  } else if (value === void 0) {\n    return \"undefined\";\n  } else if (typeof value === \"number\" || typeof value === \"boolean\" || typeof value === \"string\") {\n    return typeof value;\n  } else if (value instanceof Map) {\n    if (maxDepth === 0) {\n      return \"object\";\n    }\n\n    const entries = Array.from(value.entries()).map(([key, v]) => {\n      return `${quoteKey(key)}: ${describeResolvedType(v, maxDepth - 1)}`;\n    });\n    return entries.length > 0 ? `{ ${entries.join(\"; \")} }` : \"{}\";\n  } else if (value instanceof ResolvedModule) {\n    return \"(module)\";\n  } else if (value instanceof EnumValue) {\n    return (_a = value.enumRef.debugName) != null ? _a : \"(anonymous)\";\n  } else if (value instanceof Reference) {\n    return (_b = value.debugName) != null ? _b : \"(anonymous)\";\n  } else if (Array.isArray(value)) {\n    if (maxDepth === 0) {\n      return \"Array\";\n    }\n\n    return `[${value.map(v => describeResolvedType(v, maxDepth - 1)).join(\", \")}]`;\n  } else if (value instanceof DynamicValue) {\n    return \"(not statically analyzable)\";\n  } else if (value instanceof KnownFn) {\n    return \"Function\";\n  } else {\n    return \"unknown\";\n  }\n}\n\nfunction quoteKey(key) {\n  if (/^[a-z0-9_]+$/i.test(key)) {\n    return key;\n  } else {\n    return `'${key.replace(/'/g, \"\\\\'\")}'`;\n  }\n}\n\nfunction traceDynamicValue(node, value) {\n  return value.accept(new TraceDynamicValueVisitor(node));\n}\n\nvar TraceDynamicValueVisitor = class {\n  constructor(node) {\n    this.node = node;\n    this.currentContainerNode = null;\n  }\n\n  visitDynamicInput(value) {\n    const trace = value.reason.accept(this);\n\n    if (this.shouldTrace(value.node)) {\n      const info = makeRelatedInformation(value.node, \"Unable to evaluate this expression statically.\");\n      trace.unshift(info);\n    }\n\n    return trace;\n  }\n\n  visitDynamicString(value) {\n    return [makeRelatedInformation(value.node, \"A string value could not be determined statically.\")];\n  }\n\n  visitExternalReference(value) {\n    const name = value.reason.debugName;\n    const description = name !== null ? `'${name}'` : \"an anonymous declaration\";\n    return [makeRelatedInformation(value.node, `A value for ${description} cannot be determined statically, as it is an external declaration.`)];\n  }\n\n  visitComplexFunctionCall(value) {\n    return [makeRelatedInformation(value.node, \"Unable to evaluate function call of complex function. A function must have exactly one return statement.\"), makeRelatedInformation(value.reason.node, \"Function is declared here.\")];\n  }\n\n  visitInvalidExpressionType(value) {\n    return [makeRelatedInformation(value.node, \"Unable to evaluate an invalid expression.\")];\n  }\n\n  visitUnknown(value) {\n    return [makeRelatedInformation(value.node, \"Unable to evaluate statically.\")];\n  }\n\n  visitUnknownIdentifier(value) {\n    return [makeRelatedInformation(value.node, \"Unknown reference.\")];\n  }\n\n  visitDynamicType(value) {\n    return [makeRelatedInformation(value.node, \"Dynamic type.\")];\n  }\n\n  visitUnsupportedSyntax(value) {\n    return [makeRelatedInformation(value.node, \"This syntax is not supported.\")];\n  }\n\n  shouldTrace(node) {\n    if (node === this.node) {\n      return false;\n    }\n\n    const container = getContainerNode(node);\n\n    if (container === this.currentContainerNode) {\n      return false;\n    }\n\n    this.currentContainerNode = container;\n    return true;\n  }\n\n};\n\nfunction getContainerNode(node) {\n  let currentNode = node;\n\n  while (currentNode !== void 0) {\n    switch (currentNode.kind) {\n      case ts3.SyntaxKind.ExpressionStatement:\n      case ts3.SyntaxKind.VariableStatement:\n      case ts3.SyntaxKind.ReturnStatement:\n      case ts3.SyntaxKind.IfStatement:\n      case ts3.SyntaxKind.SwitchStatement:\n      case ts3.SyntaxKind.DoStatement:\n      case ts3.SyntaxKind.WhileStatement:\n      case ts3.SyntaxKind.ForStatement:\n      case ts3.SyntaxKind.ForInStatement:\n      case ts3.SyntaxKind.ForOfStatement:\n      case ts3.SyntaxKind.ContinueStatement:\n      case ts3.SyntaxKind.BreakStatement:\n      case ts3.SyntaxKind.ThrowStatement:\n      case ts3.SyntaxKind.ObjectBindingPattern:\n      case ts3.SyntaxKind.ArrayBindingPattern:\n        return currentNode;\n    }\n\n    currentNode = currentNode.parent;\n  }\n\n  return node.getSourceFile();\n} // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/src/util.mjs\n\n\nimport { ExternalExpr, LiteralExpr, ParseLocation, ParseSourceFile, ParseSourceSpan, ReadPropExpr, WrappedNodeExpr } from \"@angular/compiler\";\nimport ts4 from \"typescript\";\n\nfunction getConstructorDependencies(clazz, reflector, isCore) {\n  const deps = [];\n  const errors = [];\n  let ctorParams = reflector.getConstructorParameters(clazz);\n\n  if (ctorParams === null) {\n    if (reflector.hasBaseClass(clazz)) {\n      return null;\n    } else {\n      ctorParams = [];\n    }\n  }\n\n  ctorParams.forEach((param, idx) => {\n    let token = valueReferenceToExpression(param.typeValueReference);\n    let attributeNameType = null;\n    let optional = false,\n        self = false,\n        skipSelf = false,\n        host = false;\n    (param.decorators || []).filter(dec => isCore || isAngularCore(dec)).forEach(dec => {\n      const name = isCore || dec.import === null ? dec.name : dec.import.name;\n\n      if (name === \"Inject\") {\n        if (dec.args === null || dec.args.length !== 1) {\n          throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(dec), `Unexpected number of arguments to @Inject().`);\n        }\n\n        token = new WrappedNodeExpr(dec.args[0]);\n      } else if (name === \"Optional\") {\n        optional = true;\n      } else if (name === \"SkipSelf\") {\n        skipSelf = true;\n      } else if (name === \"Self\") {\n        self = true;\n      } else if (name === \"Host\") {\n        host = true;\n      } else if (name === \"Attribute\") {\n        if (dec.args === null || dec.args.length !== 1) {\n          throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(dec), `Unexpected number of arguments to @Attribute().`);\n        }\n\n        const attributeName = dec.args[0];\n        token = new WrappedNodeExpr(attributeName);\n\n        if (ts4.isStringLiteralLike(attributeName)) {\n          attributeNameType = new LiteralExpr(attributeName.text);\n        } else {\n          attributeNameType = new WrappedNodeExpr(ts4.createKeywordTypeNode(ts4.SyntaxKind.UnknownKeyword));\n        }\n      } else {\n        throw new FatalDiagnosticError(ErrorCode.DECORATOR_UNEXPECTED, Decorator.nodeForError(dec), `Unexpected decorator ${name} on parameter.`);\n      }\n    });\n\n    if (token === null) {\n      if (param.typeValueReference.kind !== 2) {\n        throw new Error(\"Illegal state: expected value reference to be unavailable if no token is present\");\n      }\n\n      errors.push({\n        index: idx,\n        param,\n        reason: param.typeValueReference.reason\n      });\n    } else {\n      deps.push({\n        token,\n        attributeNameType,\n        optional,\n        self,\n        skipSelf,\n        host\n      });\n    }\n  });\n\n  if (errors.length === 0) {\n    return {\n      deps\n    };\n  } else {\n    return {\n      deps: null,\n      errors\n    };\n  }\n}\n\nfunction valueReferenceToExpression(valueRef) {\n  if (valueRef.kind === 2) {\n    return null;\n  } else if (valueRef.kind === 0) {\n    const expr = new WrappedNodeExpr(valueRef.expression);\n\n    if (valueRef.defaultImportStatement !== null) {\n      attachDefaultImportDeclaration(expr, valueRef.defaultImportStatement);\n    }\n\n    return expr;\n  } else {\n    let importExpr = new ExternalExpr({\n      moduleName: valueRef.moduleName,\n      name: valueRef.importedName\n    });\n\n    if (valueRef.nestedPath !== null) {\n      for (const property of valueRef.nestedPath) {\n        importExpr = new ReadPropExpr(importExpr, property);\n      }\n    }\n\n    return importExpr;\n  }\n}\n\nfunction unwrapConstructorDependencies(deps) {\n  if (deps === null) {\n    return null;\n  } else if (deps.deps !== null) {\n    return deps.deps;\n  } else {\n    return \"invalid\";\n  }\n}\n\nfunction getValidConstructorDependencies(clazz, reflector, isCore) {\n  return validateConstructorDependencies(clazz, getConstructorDependencies(clazz, reflector, isCore));\n}\n\nfunction validateConstructorDependencies(clazz, deps) {\n  if (deps === null) {\n    return null;\n  } else if (deps.deps !== null) {\n    return deps.deps;\n  } else {\n    const error = deps.errors[0];\n    throw createUnsuitableInjectionTokenError(clazz, error);\n  }\n}\n\nfunction createUnsuitableInjectionTokenError(clazz, error) {\n  const {\n    param,\n    index,\n    reason\n  } = error;\n  let chainMessage = void 0;\n  let hints = void 0;\n\n  switch (reason.kind) {\n    case 5:\n      chainMessage = \"Consider using the @Inject decorator to specify an injection token.\";\n      hints = [makeRelatedInformation(reason.typeNode, \"This type is not supported as injection token.\")];\n      break;\n\n    case 1:\n      chainMessage = \"Consider using the @Inject decorator to specify an injection token.\";\n      hints = [makeRelatedInformation(reason.typeNode, \"This type does not have a value, so it cannot be used as injection token.\")];\n\n      if (reason.decl !== null) {\n        hints.push(makeRelatedInformation(reason.decl, \"The type is declared here.\"));\n      }\n\n      break;\n\n    case 2:\n      chainMessage = \"Consider changing the type-only import to a regular import, or use the @Inject decorator to specify an injection token.\";\n      hints = [makeRelatedInformation(reason.typeNode, \"This type is imported using a type-only import, which prevents it from being usable as an injection token.\"), makeRelatedInformation(reason.node, \"The type-only import occurs here.\")];\n      break;\n\n    case 4:\n      chainMessage = \"Consider using the @Inject decorator to specify an injection token.\";\n      hints = [makeRelatedInformation(reason.typeNode, \"This type corresponds with a namespace, which cannot be used as injection token.\"), makeRelatedInformation(reason.importClause, \"The namespace import occurs here.\")];\n      break;\n\n    case 3:\n      chainMessage = \"The type should reference a known declaration.\";\n      hints = [makeRelatedInformation(reason.typeNode, \"This type could not be resolved.\")];\n      break;\n\n    case 0:\n      chainMessage = \"Consider adding a type to the parameter or use the @Inject decorator to specify an injection token.\";\n      break;\n  }\n\n  const chain = {\n    messageText: `No suitable injection token for parameter '${param.name || index}' of class '${clazz.name.text}'.`,\n    category: ts4.DiagnosticCategory.Error,\n    code: 0,\n    next: [{\n      messageText: chainMessage,\n      category: ts4.DiagnosticCategory.Message,\n      code: 0\n    }]\n  };\n  return new FatalDiagnosticError(ErrorCode.PARAM_MISSING_TOKEN, param.nameNode, chain, hints);\n}\n\nfunction toR3Reference(valueRef, typeRef, valueContext, typeContext, refEmitter) {\n  return {\n    value: refEmitter.emit(valueRef, valueContext).expression,\n    type: refEmitter.emit(typeRef, typeContext, ImportFlags.ForceNewImport | ImportFlags.AllowTypeImports).expression\n  };\n}\n\nfunction isAngularCore(decorator) {\n  return decorator.import !== null && decorator.import.from === \"@angular/core\";\n}\n\nfunction isAngularCoreReference(reference, symbolName) {\n  return reference.ownedByModuleGuess === \"@angular/core\" && reference.debugName === symbolName;\n}\n\nfunction findAngularDecorator(decorators, name, isCore) {\n  return decorators.find(decorator => isAngularDecorator(decorator, name, isCore));\n}\n\nfunction isAngularDecorator(decorator, name, isCore) {\n  if (isCore) {\n    return decorator.name === name;\n  } else if (isAngularCore(decorator)) {\n    return decorator.import.name === name;\n  }\n\n  return false;\n}\n\nfunction unwrapExpression(node) {\n  while (ts4.isAsExpression(node) || ts4.isParenthesizedExpression(node)) {\n    node = node.expression;\n  }\n\n  return node;\n}\n\nfunction expandForwardRef(arg) {\n  arg = unwrapExpression(arg);\n\n  if (!ts4.isArrowFunction(arg) && !ts4.isFunctionExpression(arg)) {\n    return null;\n  }\n\n  const body = arg.body;\n\n  if (ts4.isBlock(body)) {\n    if (body.statements.length !== 1) {\n      return null;\n    }\n\n    const stmt = body.statements[0];\n\n    if (!ts4.isReturnStatement(stmt) || stmt.expression === void 0) {\n      return null;\n    }\n\n    return stmt.expression;\n  } else {\n    return body;\n  }\n}\n\nfunction tryUnwrapForwardRef(node, reflector) {\n  node = unwrapExpression(node);\n\n  if (!ts4.isCallExpression(node) || node.arguments.length !== 1) {\n    return null;\n  }\n\n  const fn = ts4.isPropertyAccessExpression(node.expression) ? node.expression.name : node.expression;\n\n  if (!ts4.isIdentifier(fn)) {\n    return null;\n  }\n\n  const expr = expandForwardRef(node.arguments[0]);\n\n  if (expr === null) {\n    return null;\n  }\n\n  const imp = reflector.getImportOfIdentifier(fn);\n\n  if (imp === null || imp.from !== \"@angular/core\" || imp.name !== \"forwardRef\") {\n    return null;\n  }\n\n  return expr;\n}\n\nfunction forwardRefResolver(ref, args) {\n  if (!isAngularCoreReference(ref, \"forwardRef\") || args.length !== 1) {\n    return null;\n  }\n\n  return expandForwardRef(args[0]);\n}\n\nfunction combineResolvers(resolvers) {\n  return (ref, args) => {\n    for (const resolver of resolvers) {\n      const resolved = resolver(ref, args);\n\n      if (resolved !== null) {\n        return resolved;\n      }\n    }\n\n    return null;\n  };\n}\n\nfunction isExpressionForwardReference(expr, context, contextSource) {\n  if (isWrappedTsNodeExpr(expr)) {\n    const node = ts4.getOriginalNode(expr.node);\n    return node.getSourceFile() === contextSource && context.pos < node.pos;\n  } else {\n    return false;\n  }\n}\n\nfunction isWrappedTsNodeExpr(expr) {\n  return expr instanceof WrappedNodeExpr;\n}\n\nfunction readBaseClass(node, reflector, evaluator) {\n  const baseExpression = reflector.getBaseClassExpression(node);\n\n  if (baseExpression !== null) {\n    const baseClass = evaluator.evaluate(baseExpression);\n\n    if (baseClass instanceof Reference && reflector.isClass(baseClass.node)) {\n      return baseClass;\n    } else {\n      return \"dynamic\";\n    }\n  }\n\n  return null;\n}\n\nvar parensWrapperTransformerFactory = context => {\n  const visitor = node => {\n    const visited = ts4.visitEachChild(node, visitor, context);\n\n    if (ts4.isArrowFunction(visited) || ts4.isFunctionExpression(visited)) {\n      return ts4.createParen(visited);\n    }\n\n    return visited;\n  };\n\n  return node => ts4.visitEachChild(node, visitor, context);\n};\n\nfunction wrapFunctionExpressionsInParens(expression) {\n  return ts4.transform(expression, [parensWrapperTransformerFactory]).transformed[0];\n}\n\nfunction makeDuplicateDeclarationError(node, data, kind) {\n  const context = [];\n\n  for (const decl of data) {\n    if (decl.rawDeclarations === null) {\n      continue;\n    }\n\n    const contextNode = decl.ref.getOriginForDiagnostics(decl.rawDeclarations, decl.ngModule.name);\n    context.push(makeRelatedInformation(contextNode, `'${node.name.text}' is listed in the declarations of the NgModule '${decl.ngModule.name.text}'.`));\n  }\n\n  return makeDiagnostic(ErrorCode.NGMODULE_DECLARATION_NOT_UNIQUE, node.name, `The ${kind} '${node.name.text}' is declared by more than one NgModule.`, context);\n}\n\nfunction resolveProvidersRequiringFactory(rawProviders, reflector, evaluator) {\n  const providers = new Set();\n  const resolvedProviders = evaluator.evaluate(rawProviders);\n\n  if (!Array.isArray(resolvedProviders)) {\n    return providers;\n  }\n\n  resolvedProviders.forEach(function processProviders(provider) {\n    let tokenClass = null;\n\n    if (Array.isArray(provider)) {\n      provider.forEach(processProviders);\n    } else if (provider instanceof Reference) {\n      tokenClass = provider;\n    } else if (provider instanceof Map && provider.has(\"useClass\") && !provider.has(\"deps\")) {\n      const useExisting = provider.get(\"useClass\");\n\n      if (useExisting instanceof Reference) {\n        tokenClass = useExisting;\n      }\n    }\n\n    if (tokenClass !== null && !tokenClass.node.getSourceFile().isDeclarationFile && reflector.isClass(tokenClass.node)) {\n      const constructorParameters = reflector.getConstructorParameters(tokenClass.node);\n\n      if (constructorParameters !== null && constructorParameters.length > 0) {\n        providers.add(tokenClass);\n      }\n    }\n  });\n  return providers;\n}\n\nfunction wrapTypeReference(reflector, clazz) {\n  const dtsClass = reflector.getDtsDeclaration(clazz);\n  const value = new WrappedNodeExpr(clazz.name);\n  const type = dtsClass !== null && isNamedClassDeclaration(dtsClass) ? new WrappedNodeExpr(dtsClass.name) : value;\n  return {\n    value,\n    type\n  };\n}\n\nfunction createSourceSpan(node) {\n  const sf = node.getSourceFile();\n  const [startOffset, endOffset] = [node.getStart(), node.getEnd()];\n  const {\n    line: startLine,\n    character: startCol\n  } = sf.getLineAndCharacterOfPosition(startOffset);\n  const {\n    line: endLine,\n    character: endCol\n  } = sf.getLineAndCharacterOfPosition(endOffset);\n  const parseSf = new ParseSourceFile(sf.getFullText(), sf.fileName);\n  return new ParseSourceSpan(new ParseLocation(parseSf, startOffset, startLine + 1, startCol + 1), new ParseLocation(parseSf, endOffset, endLine + 1, endCol + 1));\n}\n\nfunction compileResults(fac, def, metadataStmt, propName) {\n  const statements = def.statements;\n\n  if (metadataStmt !== null) {\n    statements.push(metadataStmt);\n  }\n\n  return [fac, {\n    name: propName,\n    initializer: def.expression,\n    statements: def.statements,\n    type: def.type\n  }];\n}\n\nfunction toFactoryMetadata(meta, target) {\n  return {\n    name: meta.name,\n    type: meta.type,\n    internalType: meta.internalType,\n    typeArgumentCount: meta.typeArgumentCount,\n    deps: meta.deps,\n    target\n  };\n} // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/src/component.mjs\n\n\nimport { compileClassMetadata as compileClassMetadata3, compileComponentFromMetadata, compileDeclareClassMetadata as compileDeclareClassMetadata3, compileDeclareComponentFromMetadata, CssSelector, DEFAULT_INTERPOLATION_CONFIG, DomElementSchemaRegistry, ExternalExpr as ExternalExpr5, FactoryTarget as FactoryTarget3, InterpolationConfig, makeBindingParser as makeBindingParser2, ParseSourceFile as ParseSourceFile2, parseTemplate, R3TargetBinder, SelectorMatcher, ViewEncapsulation, WrappedNodeExpr as WrappedNodeExpr5 } from \"@angular/compiler\";\nimport ts19 from \"typescript\"; // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/incremental/semantic_graph/src/api.mjs\n\nimport ts5 from \"typescript\";\nvar SemanticSymbol = class {\n  constructor(decl) {\n    this.decl = decl;\n    this.path = absoluteFromSourceFile(decl.getSourceFile());\n    this.identifier = getSymbolIdentifier(decl);\n  }\n\n};\n\nfunction getSymbolIdentifier(decl) {\n  if (!ts5.isSourceFile(decl.parent)) {\n    return null;\n  }\n\n  return decl.name.text;\n} // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/incremental/semantic_graph/src/graph.mjs\n\n\nimport { ExternalExpr as ExternalExpr2 } from \"@angular/compiler\";\nvar OpaqueSymbol = class extends SemanticSymbol {\n  isPublicApiAffected() {\n    return false;\n  }\n\n  isTypeCheckApiAffected() {\n    return false;\n  }\n\n};\nvar SemanticDepGraph = class {\n  constructor() {\n    this.files = new Map();\n    this.symbolByDecl = new Map();\n  }\n\n  registerSymbol(symbol) {\n    this.symbolByDecl.set(symbol.decl, symbol);\n\n    if (symbol.identifier !== null) {\n      if (!this.files.has(symbol.path)) {\n        this.files.set(symbol.path, new Map());\n      }\n\n      this.files.get(symbol.path).set(symbol.identifier, symbol);\n    }\n  }\n\n  getEquivalentSymbol(symbol) {\n    let previousSymbol = this.getSymbolByDecl(symbol.decl);\n\n    if (previousSymbol === null && symbol.identifier !== null) {\n      previousSymbol = this.getSymbolByName(symbol.path, symbol.identifier);\n    }\n\n    return previousSymbol;\n  }\n\n  getSymbolByName(path, identifier) {\n    if (!this.files.has(path)) {\n      return null;\n    }\n\n    const file = this.files.get(path);\n\n    if (!file.has(identifier)) {\n      return null;\n    }\n\n    return file.get(identifier);\n  }\n\n  getSymbolByDecl(decl) {\n    if (!this.symbolByDecl.has(decl)) {\n      return null;\n    }\n\n    return this.symbolByDecl.get(decl);\n  }\n\n};\nvar SemanticDepGraphUpdater = class {\n  constructor(priorGraph) {\n    this.priorGraph = priorGraph;\n    this.newGraph = new SemanticDepGraph();\n    this.opaqueSymbols = new Map();\n  }\n\n  registerSymbol(symbol) {\n    this.newGraph.registerSymbol(symbol);\n  }\n\n  finalize() {\n    if (this.priorGraph === null) {\n      return {\n        needsEmit: new Set(),\n        needsTypeCheckEmit: new Set(),\n        newGraph: this.newGraph\n      };\n    }\n\n    const needsEmit = this.determineInvalidatedFiles(this.priorGraph);\n    const needsTypeCheckEmit = this.determineInvalidatedTypeCheckFiles(this.priorGraph);\n    return {\n      needsEmit,\n      needsTypeCheckEmit,\n      newGraph: this.newGraph\n    };\n  }\n\n  determineInvalidatedFiles(priorGraph) {\n    const isPublicApiAffected = new Set();\n\n    for (const symbol of this.newGraph.symbolByDecl.values()) {\n      const previousSymbol = priorGraph.getEquivalentSymbol(symbol);\n\n      if (previousSymbol === null || symbol.isPublicApiAffected(previousSymbol)) {\n        isPublicApiAffected.add(symbol);\n      }\n    }\n\n    const needsEmit = new Set();\n\n    for (const symbol of this.newGraph.symbolByDecl.values()) {\n      if (symbol.isEmitAffected === void 0) {\n        continue;\n      }\n\n      const previousSymbol = priorGraph.getEquivalentSymbol(symbol);\n\n      if (previousSymbol === null || symbol.isEmitAffected(previousSymbol, isPublicApiAffected)) {\n        needsEmit.add(symbol.path);\n      }\n    }\n\n    return needsEmit;\n  }\n\n  determineInvalidatedTypeCheckFiles(priorGraph) {\n    const isTypeCheckApiAffected = new Set();\n\n    for (const symbol of this.newGraph.symbolByDecl.values()) {\n      const previousSymbol = priorGraph.getEquivalentSymbol(symbol);\n\n      if (previousSymbol === null || symbol.isTypeCheckApiAffected(previousSymbol)) {\n        isTypeCheckApiAffected.add(symbol);\n      }\n    }\n\n    const needsTypeCheckEmit = new Set();\n\n    for (const symbol of this.newGraph.symbolByDecl.values()) {\n      if (symbol.isTypeCheckBlockAffected === void 0) {\n        continue;\n      }\n\n      const previousSymbol = priorGraph.getEquivalentSymbol(symbol);\n\n      if (previousSymbol === null || symbol.isTypeCheckBlockAffected(previousSymbol, isTypeCheckApiAffected)) {\n        needsTypeCheckEmit.add(symbol.path);\n      }\n    }\n\n    return needsTypeCheckEmit;\n  }\n\n  getSemanticReference(decl, expr) {\n    return {\n      symbol: this.getSymbol(decl),\n      importPath: getImportPath(expr)\n    };\n  }\n\n  getSymbol(decl) {\n    const symbol = this.newGraph.getSymbolByDecl(decl);\n\n    if (symbol === null) {\n      return this.getOpaqueSymbol(decl);\n    }\n\n    return symbol;\n  }\n\n  getOpaqueSymbol(decl) {\n    if (this.opaqueSymbols.has(decl)) {\n      return this.opaqueSymbols.get(decl);\n    }\n\n    const symbol = new OpaqueSymbol(decl);\n    this.opaqueSymbols.set(decl, symbol);\n    return symbol;\n  }\n\n};\n\nfunction getImportPath(expr) {\n  if (expr instanceof ExternalExpr2) {\n    return `${expr.value.moduleName}$${expr.value.name}`;\n  } else {\n    return null;\n  }\n} // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/incremental/semantic_graph/src/type_parameters.mjs\n\n\nimport ts6 from \"typescript\"; // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/incremental/semantic_graph/src/util.mjs\n\nfunction isSymbolEqual(a, b) {\n  if (a.decl === b.decl) {\n    return true;\n  }\n\n  if (a.identifier === null || b.identifier === null) {\n    return false;\n  }\n\n  return a.path === b.path && a.identifier === b.identifier;\n}\n\nfunction isReferenceEqual(a, b) {\n  if (!isSymbolEqual(a.symbol, b.symbol)) {\n    return false;\n  }\n\n  return a.importPath === b.importPath;\n}\n\nfunction referenceEquality(a, b) {\n  return a === b;\n}\n\nfunction isArrayEqual(a, b, equalityTester = referenceEquality) {\n  if (a === null || b === null) {\n    return a === b;\n  }\n\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  return !a.some((item, index) => !equalityTester(item, b[index]));\n}\n\nfunction isSetEqual(a, b, equalityTester = referenceEquality) {\n  if (a === null || b === null) {\n    return a === b;\n  }\n\n  if (a.size !== b.size) {\n    return false;\n  }\n\n  for (const itemA of a) {\n    let found = false;\n\n    for (const itemB of b) {\n      if (equalityTester(itemA, itemB)) {\n        found = true;\n        break;\n      }\n    }\n\n    if (!found) {\n      return false;\n    }\n  }\n\n  return true;\n} // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/incremental/semantic_graph/src/type_parameters.mjs\n\n\nfunction extractSemanticTypeParameters(node) {\n  if (!ts6.isClassDeclaration(node) || node.typeParameters === void 0) {\n    return null;\n  }\n\n  return node.typeParameters.map(typeParam => ({\n    hasGenericTypeBound: typeParam.constraint !== void 0\n  }));\n}\n\nfunction areTypeParametersEqual(current, previous) {\n  if (!isArrayEqual(current, previous, isTypeParameterEqual)) {\n    return false;\n  }\n\n  if (current !== null && current.some(typeParam => typeParam.hasGenericTypeBound)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isTypeParameterEqual(a, b) {\n  return a.hasGenericTypeBound === b.hasGenericTypeBound;\n} // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/api.mjs\n\n\nvar MetaType;\n\n(function (MetaType2) {\n  MetaType2[MetaType2[\"Pipe\"] = 0] = \"Pipe\";\n  MetaType2[MetaType2[\"Directive\"] = 1] = \"Directive\";\n})(MetaType || (MetaType = {})); // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/dts.mjs\n\n\nimport ts8 from \"typescript\"; // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/property_mapping.mjs\n\nvar ClassPropertyMapping = class {\n  constructor(forwardMap) {\n    this.forwardMap = forwardMap;\n    this.reverseMap = reverseMapFromForwardMap(forwardMap);\n  }\n\n  static empty() {\n    return new ClassPropertyMapping(new Map());\n  }\n\n  static fromMappedObject(obj) {\n    const forwardMap = new Map();\n\n    for (const classPropertyName of Object.keys(obj)) {\n      const value = obj[classPropertyName];\n      const bindingPropertyName = Array.isArray(value) ? value[0] : value;\n      const inputOrOutput = {\n        classPropertyName,\n        bindingPropertyName\n      };\n      forwardMap.set(classPropertyName, inputOrOutput);\n    }\n\n    return new ClassPropertyMapping(forwardMap);\n  }\n\n  static merge(a, b) {\n    const forwardMap = new Map(a.forwardMap.entries());\n\n    for (const [classPropertyName, inputOrOutput] of b.forwardMap) {\n      forwardMap.set(classPropertyName, inputOrOutput);\n    }\n\n    return new ClassPropertyMapping(forwardMap);\n  }\n\n  get classPropertyNames() {\n    return Array.from(this.forwardMap.keys());\n  }\n\n  get propertyNames() {\n    return Array.from(this.reverseMap.keys());\n  }\n\n  hasBindingPropertyName(propertyName) {\n    return this.reverseMap.has(propertyName);\n  }\n\n  getByBindingPropertyName(propertyName) {\n    return this.reverseMap.has(propertyName) ? this.reverseMap.get(propertyName) : null;\n  }\n\n  getByClassPropertyName(classPropertyName) {\n    return this.forwardMap.has(classPropertyName) ? this.forwardMap.get(classPropertyName) : null;\n  }\n\n  toDirectMappedObject() {\n    const obj = {};\n\n    for (const [classPropertyName, inputOrOutput] of this.forwardMap) {\n      obj[classPropertyName] = inputOrOutput.bindingPropertyName;\n    }\n\n    return obj;\n  }\n\n  toJointMappedObject() {\n    const obj = {};\n\n    for (const [classPropertyName, inputOrOutput] of this.forwardMap) {\n      if (inputOrOutput.bindingPropertyName === classPropertyName) {\n        obj[classPropertyName] = inputOrOutput.bindingPropertyName;\n      } else {\n        obj[classPropertyName] = [inputOrOutput.bindingPropertyName, classPropertyName];\n      }\n    }\n\n    return obj;\n  }\n\n  *[Symbol.iterator]() {\n    for (const [classPropertyName, inputOrOutput] of this.forwardMap.entries()) {\n      yield [classPropertyName, inputOrOutput.bindingPropertyName];\n    }\n  }\n\n};\n\nfunction reverseMapFromForwardMap(forwardMap) {\n  const reverseMap = new Map();\n\n  for (const [_, inputOrOutput] of forwardMap) {\n    if (!reverseMap.has(inputOrOutput.bindingPropertyName)) {\n      reverseMap.set(inputOrOutput.bindingPropertyName, []);\n    }\n\n    reverseMap.get(inputOrOutput.bindingPropertyName).push(inputOrOutput);\n  }\n\n  return reverseMap;\n} // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/util.mjs\n\n\nimport ts7 from \"typescript\";\n\nfunction extractReferencesFromType(checker, def, bestGuessOwningModule) {\n  if (!ts7.isTupleTypeNode(def)) {\n    return [];\n  }\n\n  return def.elements.map(element => {\n    if (!ts7.isTypeQueryNode(element)) {\n      throw new Error(`Expected TypeQueryNode: ${nodeDebugInfo(element)}`);\n    }\n\n    const type = element.exprName;\n    const {\n      node,\n      from\n    } = reflectTypeEntityToDeclaration(type, checker);\n\n    if (!isNamedClassDeclaration(node)) {\n      throw new Error(`Expected named ClassDeclaration: ${nodeDebugInfo(node)}`);\n    }\n\n    if (from !== null && !from.startsWith(\".\")) {\n      return new Reference(node, {\n        specifier: from,\n        resolutionContext: def.getSourceFile().fileName\n      });\n    } else {\n      return new Reference(node, bestGuessOwningModule);\n    }\n  });\n}\n\nfunction readStringType(type) {\n  if (!ts7.isLiteralTypeNode(type) || !ts7.isStringLiteral(type.literal)) {\n    return null;\n  }\n\n  return type.literal.text;\n}\n\nfunction readStringMapType(type) {\n  if (!ts7.isTypeLiteralNode(type)) {\n    return {};\n  }\n\n  const obj = {};\n  type.members.forEach(member => {\n    if (!ts7.isPropertySignature(member) || member.type === void 0 || member.name === void 0 || !ts7.isStringLiteral(member.name)) {\n      return;\n    }\n\n    const value = readStringType(member.type);\n\n    if (value === null) {\n      return null;\n    }\n\n    obj[member.name.text] = value;\n  });\n  return obj;\n}\n\nfunction readStringArrayType(type) {\n  if (!ts7.isTupleTypeNode(type)) {\n    return [];\n  }\n\n  const res = [];\n  type.elements.forEach(el => {\n    if (!ts7.isLiteralTypeNode(el) || !ts7.isStringLiteral(el.literal)) {\n      return;\n    }\n\n    res.push(el.literal.text);\n  });\n  return res;\n}\n\nfunction extractDirectiveTypeCheckMeta(node, inputs, reflector) {\n  const members = reflector.getMembersOfClass(node);\n  const staticMembers = members.filter(member => member.isStatic);\n  const ngTemplateGuards = staticMembers.map(extractTemplateGuard).filter(guard => guard !== null);\n  const hasNgTemplateContextGuard = staticMembers.some(member => member.kind === ClassMemberKind.Method && member.name === \"ngTemplateContextGuard\");\n  const coercedInputFields = new Set(staticMembers.map(extractCoercedInput).filter(inputName => inputName !== null));\n  const restrictedInputFields = new Set();\n  const stringLiteralInputFields = new Set();\n  const undeclaredInputFields = new Set();\n\n  for (const classPropertyName of inputs.classPropertyNames) {\n    const field = members.find(member => member.name === classPropertyName);\n\n    if (field === void 0 || field.node === null) {\n      undeclaredInputFields.add(classPropertyName);\n      continue;\n    }\n\n    if (isRestricted(field.node)) {\n      restrictedInputFields.add(classPropertyName);\n    }\n\n    if (field.nameNode !== null && ts7.isStringLiteral(field.nameNode)) {\n      stringLiteralInputFields.add(classPropertyName);\n    }\n  }\n\n  const arity = reflector.getGenericArityOfClass(node);\n  return {\n    hasNgTemplateContextGuard,\n    ngTemplateGuards,\n    coercedInputFields,\n    restrictedInputFields,\n    stringLiteralInputFields,\n    undeclaredInputFields,\n    isGeneric: arity !== null && arity > 0\n  };\n}\n\nfunction isRestricted(node) {\n  if (node.modifiers === void 0) {\n    return false;\n  }\n\n  return node.modifiers.some(modifier => modifier.kind === ts7.SyntaxKind.PrivateKeyword || modifier.kind === ts7.SyntaxKind.ProtectedKeyword || modifier.kind === ts7.SyntaxKind.ReadonlyKeyword);\n}\n\nfunction extractTemplateGuard(member) {\n  if (!member.name.startsWith(\"ngTemplateGuard_\")) {\n    return null;\n  }\n\n  const inputName = afterUnderscore(member.name);\n\n  if (member.kind === ClassMemberKind.Property) {\n    let type = null;\n\n    if (member.type !== null && ts7.isLiteralTypeNode(member.type) && ts7.isStringLiteral(member.type.literal)) {\n      type = member.type.literal.text;\n    }\n\n    if (type !== \"binding\") {\n      return null;\n    }\n\n    return {\n      inputName,\n      type\n    };\n  } else if (member.kind === ClassMemberKind.Method) {\n    return {\n      inputName,\n      type: \"invocation\"\n    };\n  } else {\n    return null;\n  }\n}\n\nfunction extractCoercedInput(member) {\n  if (member.kind !== ClassMemberKind.Property || !member.name.startsWith(\"ngAcceptInputType_\")) {\n    return null;\n  }\n\n  return afterUnderscore(member.name);\n}\n\nvar CompoundMetadataReader = class {\n  constructor(readers) {\n    this.readers = readers;\n  }\n\n  getDirectiveMetadata(node) {\n    for (const reader of this.readers) {\n      const meta = reader.getDirectiveMetadata(node);\n\n      if (meta !== null) {\n        return meta;\n      }\n    }\n\n    return null;\n  }\n\n  getNgModuleMetadata(node) {\n    for (const reader of this.readers) {\n      const meta = reader.getNgModuleMetadata(node);\n\n      if (meta !== null) {\n        return meta;\n      }\n    }\n\n    return null;\n  }\n\n  getPipeMetadata(node) {\n    for (const reader of this.readers) {\n      const meta = reader.getPipeMetadata(node);\n\n      if (meta !== null) {\n        return meta;\n      }\n    }\n\n    return null;\n  }\n\n};\n\nfunction afterUnderscore(str) {\n  const pos = str.indexOf(\"_\");\n\n  if (pos === -1) {\n    throw new Error(`Expected '${str}' to contain '_'`);\n  }\n\n  return str.substr(pos + 1);\n}\n\nfunction hasInjectableFields(clazz, host) {\n  const members = host.getMembersOfClass(clazz);\n  return members.some(({\n    isStatic,\n    name\n  }) => isStatic && (name === \"\\u0275prov\" || name === \"\\u0275fac\"));\n} // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/dts.mjs\n\n\nvar DtsMetadataReader = class {\n  constructor(checker, reflector) {\n    this.checker = checker;\n    this.reflector = reflector;\n  }\n\n  getNgModuleMetadata(ref) {\n    const clazz = ref.node;\n    const ngModuleDef = this.reflector.getMembersOfClass(clazz).find(member => member.name === \"\\u0275mod\" && member.isStatic);\n\n    if (ngModuleDef === void 0) {\n      return null;\n    } else if (ngModuleDef.type === null || !ts8.isTypeReferenceNode(ngModuleDef.type) || ngModuleDef.type.typeArguments === void 0 || ngModuleDef.type.typeArguments.length !== 4) {\n      return null;\n    }\n\n    const [_, declarationMetadata, importMetadata, exportMetadata] = ngModuleDef.type.typeArguments;\n    return {\n      ref,\n      declarations: extractReferencesFromType(this.checker, declarationMetadata, ref.bestGuessOwningModule),\n      exports: extractReferencesFromType(this.checker, exportMetadata, ref.bestGuessOwningModule),\n      imports: extractReferencesFromType(this.checker, importMetadata, ref.bestGuessOwningModule),\n      schemas: [],\n      rawDeclarations: null\n    };\n  }\n\n  getDirectiveMetadata(ref) {\n    const clazz = ref.node;\n    const def = this.reflector.getMembersOfClass(clazz).find(field => field.isStatic && (field.name === \"\\u0275cmp\" || field.name === \"\\u0275dir\"));\n\n    if (def === void 0) {\n      return null;\n    } else if (def.type === null || !ts8.isTypeReferenceNode(def.type) || def.type.typeArguments === void 0 || def.type.typeArguments.length < 2) {\n      return null;\n    }\n\n    const isComponent = def.name === \"\\u0275cmp\";\n    const ctorParams = this.reflector.getConstructorParameters(clazz);\n    const isStructural = !isComponent && ctorParams !== null && ctorParams.some(param => {\n      return param.typeValueReference.kind === 1 && param.typeValueReference.moduleName === \"@angular/core\" && param.typeValueReference.importedName === \"TemplateRef\";\n    });\n    const inputs = ClassPropertyMapping.fromMappedObject(readStringMapType(def.type.typeArguments[3]));\n    const outputs = ClassPropertyMapping.fromMappedObject(readStringMapType(def.type.typeArguments[4]));\n    return __spreadProps(__spreadValues({\n      type: MetaType.Directive,\n      ref,\n      name: clazz.name.text,\n      isComponent,\n      selector: readStringType(def.type.typeArguments[1]),\n      exportAs: readStringArrayType(def.type.typeArguments[2]),\n      inputs,\n      outputs,\n      queries: readStringArrayType(def.type.typeArguments[5])\n    }, extractDirectiveTypeCheckMeta(clazz, inputs, this.reflector)), {\n      baseClass: readBaseClass2(clazz, this.checker, this.reflector),\n      isPoisoned: false,\n      isStructural\n    });\n  }\n\n  getPipeMetadata(ref) {\n    const def = this.reflector.getMembersOfClass(ref.node).find(field => field.isStatic && field.name === \"\\u0275pipe\");\n\n    if (def === void 0) {\n      return null;\n    } else if (def.type === null || !ts8.isTypeReferenceNode(def.type) || def.type.typeArguments === void 0 || def.type.typeArguments.length < 2) {\n      return null;\n    }\n\n    const type = def.type.typeArguments[1];\n\n    if (!ts8.isLiteralTypeNode(type) || !ts8.isStringLiteral(type.literal)) {\n      return null;\n    }\n\n    const name = type.literal.text;\n    return {\n      type: MetaType.Pipe,\n      ref,\n      name,\n      nameExpr: null\n    };\n  }\n\n};\n\nfunction readBaseClass2(clazz, checker, reflector) {\n  if (!isNamedClassDeclaration(clazz)) {\n    return reflector.hasBaseClass(clazz) ? \"dynamic\" : null;\n  }\n\n  if (clazz.heritageClauses !== void 0) {\n    for (const clause of clazz.heritageClauses) {\n      if (clause.token === ts8.SyntaxKind.ExtendsKeyword) {\n        const baseExpr = clause.types[0].expression;\n        let symbol = checker.getSymbolAtLocation(baseExpr);\n\n        if (symbol === void 0) {\n          return \"dynamic\";\n        } else if (symbol.flags & ts8.SymbolFlags.Alias) {\n          symbol = checker.getAliasedSymbol(symbol);\n        }\n\n        if (symbol.valueDeclaration !== void 0 && isNamedClassDeclaration(symbol.valueDeclaration)) {\n          return new Reference(symbol.valueDeclaration);\n        } else {\n          return \"dynamic\";\n        }\n      }\n    }\n  }\n\n  return null;\n} // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/inheritance.mjs\n\n\nfunction flattenInheritedDirectiveMetadata(reader, dir) {\n  const topMeta = reader.getDirectiveMetadata(dir);\n\n  if (topMeta === null) {\n    throw new Error(`Metadata not found for directive: ${dir.debugName}`);\n  }\n\n  if (topMeta.baseClass === null) {\n    return topMeta;\n  }\n\n  const coercedInputFields = new Set();\n  const undeclaredInputFields = new Set();\n  const restrictedInputFields = new Set();\n  const stringLiteralInputFields = new Set();\n  let isDynamic = false;\n  let inputs = ClassPropertyMapping.empty();\n  let outputs = ClassPropertyMapping.empty();\n  let isStructural = false;\n\n  const addMetadata = meta => {\n    if (meta.baseClass === \"dynamic\") {\n      isDynamic = true;\n    } else if (meta.baseClass !== null) {\n      const baseMeta = reader.getDirectiveMetadata(meta.baseClass);\n\n      if (baseMeta !== null) {\n        addMetadata(baseMeta);\n      } else {\n        isDynamic = true;\n      }\n    }\n\n    isStructural = isStructural || meta.isStructural;\n    inputs = ClassPropertyMapping.merge(inputs, meta.inputs);\n    outputs = ClassPropertyMapping.merge(outputs, meta.outputs);\n\n    for (const coercedInputField of meta.coercedInputFields) {\n      coercedInputFields.add(coercedInputField);\n    }\n\n    for (const undeclaredInputField of meta.undeclaredInputFields) {\n      undeclaredInputFields.add(undeclaredInputField);\n    }\n\n    for (const restrictedInputField of meta.restrictedInputFields) {\n      restrictedInputFields.add(restrictedInputField);\n    }\n\n    for (const field of meta.stringLiteralInputFields) {\n      stringLiteralInputFields.add(field);\n    }\n  };\n\n  addMetadata(topMeta);\n  return __spreadProps(__spreadValues({}, topMeta), {\n    inputs,\n    outputs,\n    coercedInputFields,\n    undeclaredInputFields,\n    restrictedInputFields,\n    stringLiteralInputFields,\n    baseClass: isDynamic ? \"dynamic\" : null,\n    isStructural\n  });\n} // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/registry.mjs\n\n\nvar LocalMetadataRegistry = class {\n  constructor() {\n    this.directives = new Map();\n    this.ngModules = new Map();\n    this.pipes = new Map();\n  }\n\n  getDirectiveMetadata(ref) {\n    return this.directives.has(ref.node) ? this.directives.get(ref.node) : null;\n  }\n\n  getNgModuleMetadata(ref) {\n    return this.ngModules.has(ref.node) ? this.ngModules.get(ref.node) : null;\n  }\n\n  getPipeMetadata(ref) {\n    return this.pipes.has(ref.node) ? this.pipes.get(ref.node) : null;\n  }\n\n  registerDirectiveMetadata(meta) {\n    this.directives.set(meta.ref.node, meta);\n  }\n\n  registerNgModuleMetadata(meta) {\n    this.ngModules.set(meta.ref.node, meta);\n  }\n\n  registerPipeMetadata(meta) {\n    this.pipes.set(meta.ref.node, meta);\n  }\n\n};\nvar CompoundMetadataRegistry = class {\n  constructor(registries) {\n    this.registries = registries;\n  }\n\n  registerDirectiveMetadata(meta) {\n    for (const registry of this.registries) {\n      registry.registerDirectiveMetadata(meta);\n    }\n  }\n\n  registerNgModuleMetadata(meta) {\n    for (const registry of this.registries) {\n      registry.registerNgModuleMetadata(meta);\n    }\n  }\n\n  registerPipeMetadata(meta) {\n    for (const registry of this.registries) {\n      registry.registerPipeMetadata(meta);\n    }\n  }\n\n};\nvar InjectableClassRegistry = class {\n  constructor(host) {\n    this.host = host;\n    this.classes = new Set();\n  }\n\n  registerInjectable(declaration) {\n    this.classes.add(declaration);\n  }\n\n  isInjectable(declaration) {\n    return this.classes.has(declaration) || hasInjectableFields(declaration, this.host);\n  }\n\n}; // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/resource_registry.mjs\n\nvar ResourceRegistry = class {\n  constructor() {\n    this.externalTemplateToComponentsMap = new Map();\n    this.componentToTemplateMap = new Map();\n    this.componentToStylesMap = new Map();\n    this.externalStyleToComponentsMap = new Map();\n  }\n\n  getComponentsWithTemplate(template) {\n    if (!this.externalTemplateToComponentsMap.has(template)) {\n      return new Set();\n    }\n\n    return this.externalTemplateToComponentsMap.get(template);\n  }\n\n  registerResources(resources, component) {\n    if (resources.template !== null) {\n      this.registerTemplate(resources.template, component);\n    }\n\n    for (const style of resources.styles) {\n      this.registerStyle(style, component);\n    }\n  }\n\n  registerTemplate(templateResource, component) {\n    const {\n      path\n    } = templateResource;\n\n    if (path !== null) {\n      if (!this.externalTemplateToComponentsMap.has(path)) {\n        this.externalTemplateToComponentsMap.set(path, new Set());\n      }\n\n      this.externalTemplateToComponentsMap.get(path).add(component);\n    }\n\n    this.componentToTemplateMap.set(component, templateResource);\n  }\n\n  getTemplate(component) {\n    if (!this.componentToTemplateMap.has(component)) {\n      return null;\n    }\n\n    return this.componentToTemplateMap.get(component);\n  }\n\n  registerStyle(styleResource, component) {\n    const {\n      path\n    } = styleResource;\n\n    if (!this.componentToStylesMap.has(component)) {\n      this.componentToStylesMap.set(component, new Set());\n    }\n\n    if (path !== null) {\n      if (!this.externalStyleToComponentsMap.has(path)) {\n        this.externalStyleToComponentsMap.set(path, new Set());\n      }\n\n      this.externalStyleToComponentsMap.get(path).add(component);\n    }\n\n    this.componentToStylesMap.get(component).add(styleResource);\n  }\n\n  getStyles(component) {\n    if (!this.componentToStylesMap.has(component)) {\n      return new Set();\n    }\n\n    return this.componentToStylesMap.get(component);\n  }\n\n  getComponentsWithStyle(styleUrl) {\n    if (!this.externalStyleToComponentsMap.has(styleUrl)) {\n      return new Set();\n    }\n\n    return this.externalStyleToComponentsMap.get(styleUrl);\n  }\n\n}; // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/api.mjs\n\nvar CompilationMode;\n\n(function (CompilationMode2) {\n  CompilationMode2[CompilationMode2[\"FULL\"] = 0] = \"FULL\";\n  CompilationMode2[CompilationMode2[\"PARTIAL\"] = 1] = \"PARTIAL\";\n})(CompilationMode || (CompilationMode = {}));\n\nvar HandlerPrecedence;\n\n(function (HandlerPrecedence2) {\n  HandlerPrecedence2[HandlerPrecedence2[\"PRIMARY\"] = 0] = \"PRIMARY\";\n  HandlerPrecedence2[HandlerPrecedence2[\"SHARED\"] = 1] = \"SHARED\";\n  HandlerPrecedence2[HandlerPrecedence2[\"WEAK\"] = 2] = \"WEAK\";\n})(HandlerPrecedence || (HandlerPrecedence = {}));\n\nvar HandlerFlags;\n\n(function (HandlerFlags2) {\n  HandlerFlags2[HandlerFlags2[\"NONE\"] = 0] = \"NONE\";\n  HandlerFlags2[HandlerFlags2[\"FULL_INHERITANCE\"] = 1] = \"FULL_INHERITANCE\";\n})(HandlerFlags || (HandlerFlags = {})); // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/alias.mjs\n\n\nimport ts9 from \"typescript\";\n\nfunction aliasTransformFactory(exportStatements) {\n  return context => {\n    return file => {\n      if (ts9.isBundle(file) || !exportStatements.has(file.fileName)) {\n        return file;\n      }\n\n      const statements = [...file.statements];\n      exportStatements.get(file.fileName).forEach(([moduleName, symbolName], aliasName) => {\n        const stmt = ts9.createExportDeclaration(void 0, void 0, ts9.createNamedExports([createExportSpecifier(symbolName, aliasName)]), ts9.createStringLiteral(moduleName));\n        statements.push(stmt);\n      });\n      return ts9.updateSourceFileNode(file, statements);\n    };\n  };\n} // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/compilation.mjs\n\n\nimport ts10 from \"typescript\"; // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/trait.mjs\n\nvar TraitState;\n\n(function (TraitState2) {\n  TraitState2[TraitState2[\"Pending\"] = 0] = \"Pending\";\n  TraitState2[TraitState2[\"Analyzed\"] = 1] = \"Analyzed\";\n  TraitState2[TraitState2[\"Resolved\"] = 2] = \"Resolved\";\n  TraitState2[TraitState2[\"Skipped\"] = 3] = \"Skipped\";\n})(TraitState || (TraitState = {}));\n\nvar Trait = {\n  pending: (handler, detected) => TraitImpl.pending(handler, detected)\n};\nvar TraitImpl = class {\n  constructor(handler, detected) {\n    this.state = TraitState.Pending;\n    this.analysis = null;\n    this.symbol = null;\n    this.resolution = null;\n    this.analysisDiagnostics = null;\n    this.resolveDiagnostics = null;\n    this.handler = handler;\n    this.detected = detected;\n  }\n\n  toAnalyzed(analysis, diagnostics, symbol) {\n    this.assertTransitionLegal(TraitState.Pending, TraitState.Analyzed);\n    this.analysis = analysis;\n    this.analysisDiagnostics = diagnostics;\n    this.symbol = symbol;\n    this.state = TraitState.Analyzed;\n    return this;\n  }\n\n  toResolved(resolution, diagnostics) {\n    this.assertTransitionLegal(TraitState.Analyzed, TraitState.Resolved);\n\n    if (this.analysis === null) {\n      throw new Error(`Cannot transition an Analyzed trait with a null analysis to Resolved`);\n    }\n\n    this.resolution = resolution;\n    this.state = TraitState.Resolved;\n    this.resolveDiagnostics = diagnostics;\n    return this;\n  }\n\n  toSkipped() {\n    this.assertTransitionLegal(TraitState.Pending, TraitState.Skipped);\n    this.state = TraitState.Skipped;\n    return this;\n  }\n\n  assertTransitionLegal(allowedState, transitionTo) {\n    if (!(this.state === allowedState)) {\n      throw new Error(`Assertion failure: cannot transition from ${TraitState[this.state]} to ${TraitState[transitionTo]}.`);\n    }\n  }\n\n  static pending(handler, detected) {\n    return new TraitImpl(handler, detected);\n  }\n\n}; // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/compilation.mjs\n\nvar TraitCompiler = class {\n  constructor(handlers, reflector, perf, incrementalBuild, compileNonExportedClasses, compilationMode, dtsTransforms, semanticDepGraphUpdater) {\n    this.handlers = handlers;\n    this.reflector = reflector;\n    this.perf = perf;\n    this.incrementalBuild = incrementalBuild;\n    this.compileNonExportedClasses = compileNonExportedClasses;\n    this.compilationMode = compilationMode;\n    this.dtsTransforms = dtsTransforms;\n    this.semanticDepGraphUpdater = semanticDepGraphUpdater;\n    this.classes = new Map();\n    this.fileToClasses = new Map();\n    this.filesWithoutTraits = new Set();\n    this.reexportMap = new Map();\n    this.handlersByName = new Map();\n\n    for (const handler of handlers) {\n      this.handlersByName.set(handler.name, handler);\n    }\n  }\n\n  analyzeSync(sf) {\n    this.analyze(sf, false);\n  }\n\n  analyzeAsync(sf) {\n    return this.analyze(sf, true);\n  }\n\n  analyze(sf, preanalyze) {\n    if (sf.isDeclarationFile) {\n      return void 0;\n    }\n\n    const promises = [];\n    const priorWork = this.incrementalBuild.priorAnalysisFor(sf);\n\n    if (priorWork !== null) {\n      this.perf.eventCount(PerfEvent.SourceFileReuseAnalysis);\n\n      if (priorWork.length > 0) {\n        for (const priorRecord of priorWork) {\n          this.adopt(priorRecord);\n        }\n\n        this.perf.eventCount(PerfEvent.TraitReuseAnalysis, priorWork.length);\n      } else {\n        this.filesWithoutTraits.add(sf);\n      }\n\n      return;\n    }\n\n    const visit2 = node => {\n      if (this.reflector.isClass(node)) {\n        this.analyzeClass(node, preanalyze ? promises : null);\n      }\n\n      ts10.forEachChild(node, visit2);\n    };\n\n    visit2(sf);\n\n    if (preanalyze && promises.length > 0) {\n      return Promise.all(promises).then(() => void 0);\n    } else {\n      return void 0;\n    }\n  }\n\n  recordFor(clazz) {\n    if (this.classes.has(clazz)) {\n      return this.classes.get(clazz);\n    } else {\n      return null;\n    }\n  }\n\n  recordsFor(sf) {\n    if (!this.fileToClasses.has(sf)) {\n      return null;\n    }\n\n    const records = [];\n\n    for (const clazz of this.fileToClasses.get(sf)) {\n      records.push(this.classes.get(clazz));\n    }\n\n    return records;\n  }\n\n  getAnalyzedRecords() {\n    const result = new Map();\n\n    for (const [sf, classes] of this.fileToClasses) {\n      const records = [];\n\n      for (const clazz of classes) {\n        records.push(this.classes.get(clazz));\n      }\n\n      result.set(sf, records);\n    }\n\n    for (const sf of this.filesWithoutTraits) {\n      result.set(sf, []);\n    }\n\n    return result;\n  }\n\n  adopt(priorRecord) {\n    const record = {\n      hasPrimaryHandler: priorRecord.hasPrimaryHandler,\n      hasWeakHandlers: priorRecord.hasWeakHandlers,\n      metaDiagnostics: priorRecord.metaDiagnostics,\n      node: priorRecord.node,\n      traits: []\n    };\n\n    for (const priorTrait of priorRecord.traits) {\n      const handler = this.handlersByName.get(priorTrait.handler.name);\n      let trait = Trait.pending(handler, priorTrait.detected);\n\n      if (priorTrait.state === TraitState.Analyzed || priorTrait.state === TraitState.Resolved) {\n        const symbol = this.makeSymbolForTrait(handler, record.node, priorTrait.analysis);\n        trait = trait.toAnalyzed(priorTrait.analysis, priorTrait.analysisDiagnostics, symbol);\n\n        if (trait.analysis !== null && trait.handler.register !== void 0) {\n          trait.handler.register(record.node, trait.analysis);\n        }\n      } else if (priorTrait.state === TraitState.Skipped) {\n        trait = trait.toSkipped();\n      }\n\n      record.traits.push(trait);\n    }\n\n    this.classes.set(record.node, record);\n    const sf = record.node.getSourceFile();\n\n    if (!this.fileToClasses.has(sf)) {\n      this.fileToClasses.set(sf, new Set());\n    }\n\n    this.fileToClasses.get(sf).add(record.node);\n  }\n\n  scanClassForTraits(clazz) {\n    if (!this.compileNonExportedClasses && !this.reflector.isStaticallyExported(clazz)) {\n      return null;\n    }\n\n    const decorators = this.reflector.getDecoratorsOfDeclaration(clazz);\n    return this.detectTraits(clazz, decorators);\n  }\n\n  detectTraits(clazz, decorators) {\n    let record = this.recordFor(clazz);\n    let foundTraits = [];\n\n    for (const handler of this.handlers) {\n      const result = handler.detect(clazz, decorators);\n\n      if (result === void 0) {\n        continue;\n      }\n\n      const isPrimaryHandler = handler.precedence === HandlerPrecedence.PRIMARY;\n      const isWeakHandler = handler.precedence === HandlerPrecedence.WEAK;\n      const trait = Trait.pending(handler, result);\n      foundTraits.push(trait);\n\n      if (record === null) {\n        record = {\n          node: clazz,\n          traits: [trait],\n          metaDiagnostics: null,\n          hasPrimaryHandler: isPrimaryHandler,\n          hasWeakHandlers: isWeakHandler\n        };\n        this.classes.set(clazz, record);\n        const sf = clazz.getSourceFile();\n\n        if (!this.fileToClasses.has(sf)) {\n          this.fileToClasses.set(sf, new Set());\n        }\n\n        this.fileToClasses.get(sf).add(clazz);\n      } else {\n        if (!isWeakHandler && record.hasWeakHandlers) {\n          record.traits = record.traits.filter(field => field.handler.precedence !== HandlerPrecedence.WEAK);\n          record.hasWeakHandlers = false;\n        } else if (isWeakHandler && !record.hasWeakHandlers) {\n          continue;\n        }\n\n        if (isPrimaryHandler && record.hasPrimaryHandler) {\n          record.metaDiagnostics = [{\n            category: ts10.DiagnosticCategory.Error,\n            code: Number(\"-99\" + ErrorCode.DECORATOR_COLLISION),\n            file: getSourceFile(clazz),\n            start: clazz.getStart(void 0, false),\n            length: clazz.getWidth(),\n            messageText: \"Two incompatible decorators on class\"\n          }];\n          record.traits = foundTraits = [];\n          break;\n        }\n\n        record.traits.push(trait);\n        record.hasPrimaryHandler = record.hasPrimaryHandler || isPrimaryHandler;\n      }\n    }\n\n    return foundTraits.length > 0 ? foundTraits : null;\n  }\n\n  makeSymbolForTrait(handler, decl, analysis) {\n    if (analysis === null) {\n      return null;\n    }\n\n    const symbol = handler.symbol(decl, analysis);\n\n    if (symbol !== null && this.semanticDepGraphUpdater !== null) {\n      const isPrimary = handler.precedence === HandlerPrecedence.PRIMARY;\n\n      if (!isPrimary) {\n        throw new Error(`AssertionError: ${handler.name} returned a symbol but is not a primary handler.`);\n      }\n\n      this.semanticDepGraphUpdater.registerSymbol(symbol);\n    }\n\n    return symbol;\n  }\n\n  analyzeClass(clazz, preanalyzeQueue) {\n    const traits = this.scanClassForTraits(clazz);\n\n    if (traits === null) {\n      return;\n    }\n\n    for (const trait of traits) {\n      const analyze = () => this.analyzeTrait(clazz, trait);\n\n      let preanalysis = null;\n\n      if (preanalyzeQueue !== null && trait.handler.preanalyze !== void 0) {\n        try {\n          preanalysis = trait.handler.preanalyze(clazz, trait.detected.metadata) || null;\n        } catch (err) {\n          if (err instanceof FatalDiagnosticError) {\n            trait.toAnalyzed(null, [err.toDiagnostic()], null);\n            return;\n          } else {\n            throw err;\n          }\n        }\n      }\n\n      if (preanalysis !== null) {\n        preanalyzeQueue.push(preanalysis.then(analyze));\n      } else {\n        analyze();\n      }\n    }\n  }\n\n  analyzeTrait(clazz, trait, flags) {\n    var _a, _b, _c;\n\n    if (trait.state !== TraitState.Pending) {\n      throw new Error(`Attempt to analyze trait of ${clazz.name.text} in state ${TraitState[trait.state]} (expected DETECTED)`);\n    }\n\n    this.perf.eventCount(PerfEvent.TraitAnalyze);\n    let result;\n\n    try {\n      result = trait.handler.analyze(clazz, trait.detected.metadata, flags);\n    } catch (err) {\n      if (err instanceof FatalDiagnosticError) {\n        trait.toAnalyzed(null, [err.toDiagnostic()], null);\n        return;\n      } else {\n        throw err;\n      }\n    }\n\n    const symbol = this.makeSymbolForTrait(trait.handler, clazz, (_a = result.analysis) != null ? _a : null);\n\n    if (result.analysis !== void 0 && trait.handler.register !== void 0) {\n      trait.handler.register(clazz, result.analysis);\n    }\n\n    trait = trait.toAnalyzed((_b = result.analysis) != null ? _b : null, (_c = result.diagnostics) != null ? _c : null, symbol);\n  }\n\n  resolve() {\n    var _a, _b;\n\n    const classes = Array.from(this.classes.keys());\n\n    for (const clazz of classes) {\n      const record = this.classes.get(clazz);\n\n      for (let trait of record.traits) {\n        const handler = trait.handler;\n\n        switch (trait.state) {\n          case TraitState.Skipped:\n            continue;\n\n          case TraitState.Pending:\n            throw new Error(`Resolving a trait that hasn't been analyzed: ${clazz.name.text} / ${Object.getPrototypeOf(trait.handler).constructor.name}`);\n\n          case TraitState.Resolved:\n            throw new Error(`Resolving an already resolved trait`);\n        }\n\n        if (trait.analysis === null) {\n          continue;\n        }\n\n        if (handler.resolve === void 0) {\n          trait = trait.toResolved(null, null);\n          continue;\n        }\n\n        let result;\n\n        try {\n          result = handler.resolve(clazz, trait.analysis, trait.symbol);\n        } catch (err) {\n          if (err instanceof FatalDiagnosticError) {\n            trait = trait.toResolved(null, [err.toDiagnostic()]);\n            continue;\n          } else {\n            throw err;\n          }\n        }\n\n        trait = trait.toResolved((_a = result.data) != null ? _a : null, (_b = result.diagnostics) != null ? _b : null);\n\n        if (result.reexports !== void 0) {\n          const fileName = clazz.getSourceFile().fileName;\n\n          if (!this.reexportMap.has(fileName)) {\n            this.reexportMap.set(fileName, new Map());\n          }\n\n          const fileReexports = this.reexportMap.get(fileName);\n\n          for (const reexport of result.reexports) {\n            fileReexports.set(reexport.asAlias, [reexport.fromModule, reexport.symbolName]);\n          }\n        }\n      }\n    }\n  }\n\n  typeCheck(sf, ctx) {\n    if (!this.fileToClasses.has(sf)) {\n      return;\n    }\n\n    for (const clazz of this.fileToClasses.get(sf)) {\n      const record = this.classes.get(clazz);\n\n      for (const trait of record.traits) {\n        if (trait.state !== TraitState.Resolved) {\n          continue;\n        } else if (trait.handler.typeCheck === void 0) {\n          continue;\n        }\n\n        if (trait.resolution !== null) {\n          trait.handler.typeCheck(ctx, clazz, trait.analysis, trait.resolution);\n        }\n      }\n    }\n  }\n\n  extendedTemplateCheck(sf, extendedTemplateChecker) {\n    const classes = this.fileToClasses.get(sf);\n\n    if (classes === void 0) {\n      return [];\n    }\n\n    const diagnostics = [];\n\n    for (const clazz of classes) {\n      if (!isNamedClassDeclaration(clazz)) {\n        continue;\n      }\n\n      const record = this.classes.get(clazz);\n\n      for (const trait of record.traits) {\n        if (trait.handler.extendedTemplateCheck === void 0) {\n          continue;\n        }\n\n        diagnostics.push(...trait.handler.extendedTemplateCheck(clazz, extendedTemplateChecker));\n      }\n    }\n\n    return diagnostics;\n  }\n\n  index(ctx) {\n    for (const clazz of this.classes.keys()) {\n      const record = this.classes.get(clazz);\n\n      for (const trait of record.traits) {\n        if (trait.state !== TraitState.Resolved) {\n          continue;\n        } else if (trait.handler.index === void 0) {\n          continue;\n        }\n\n        if (trait.resolution !== null) {\n          trait.handler.index(ctx, clazz, trait.analysis, trait.resolution);\n        }\n      }\n    }\n  }\n\n  xi18n(bundle) {\n    for (const clazz of this.classes.keys()) {\n      const record = this.classes.get(clazz);\n\n      for (const trait of record.traits) {\n        if (trait.state !== TraitState.Analyzed && trait.state !== TraitState.Resolved) {\n          continue;\n        } else if (trait.handler.xi18n === void 0) {\n          continue;\n        }\n\n        if (trait.analysis !== null) {\n          trait.handler.xi18n(bundle, clazz, trait.analysis);\n        }\n      }\n    }\n  }\n\n  updateResources(clazz) {\n    if (!this.reflector.isClass(clazz) || !this.classes.has(clazz)) {\n      return;\n    }\n\n    const record = this.classes.get(clazz);\n\n    for (const trait of record.traits) {\n      if (trait.state !== TraitState.Resolved || trait.handler.updateResources === void 0) {\n        continue;\n      }\n\n      trait.handler.updateResources(clazz, trait.analysis, trait.resolution);\n    }\n  }\n\n  compile(clazz, constantPool) {\n    const original = ts10.getOriginalNode(clazz);\n\n    if (!this.reflector.isClass(clazz) || !this.reflector.isClass(original) || !this.classes.has(original)) {\n      return null;\n    }\n\n    const record = this.classes.get(original);\n    let res = [];\n\n    for (const trait of record.traits) {\n      if (trait.state !== TraitState.Resolved || trait.analysisDiagnostics !== null || trait.resolveDiagnostics !== null) {\n        continue;\n      }\n\n      let compileRes;\n\n      if (this.compilationMode === CompilationMode.PARTIAL && trait.handler.compilePartial !== void 0) {\n        compileRes = trait.handler.compilePartial(clazz, trait.analysis, trait.resolution);\n      } else {\n        compileRes = trait.handler.compileFull(clazz, trait.analysis, trait.resolution, constantPool);\n      }\n\n      const compileMatchRes = compileRes;\n\n      if (Array.isArray(compileMatchRes)) {\n        for (const result of compileMatchRes) {\n          if (!res.some(r => r.name === result.name)) {\n            res.push(result);\n          }\n        }\n      } else if (!res.some(result => result.name === compileMatchRes.name)) {\n        res.push(compileMatchRes);\n      }\n    }\n\n    this.dtsTransforms.getIvyDeclarationTransform(original.getSourceFile()).addFields(original, res);\n    return res.length > 0 ? res : null;\n  }\n\n  decoratorsFor(node) {\n    const original = ts10.getOriginalNode(node);\n\n    if (!this.reflector.isClass(original) || !this.classes.has(original)) {\n      return [];\n    }\n\n    const record = this.classes.get(original);\n    const decorators = [];\n\n    for (const trait of record.traits) {\n      if (trait.state !== TraitState.Resolved) {\n        continue;\n      }\n\n      if (trait.detected.trigger !== null && ts10.isDecorator(trait.detected.trigger)) {\n        decorators.push(trait.detected.trigger);\n      }\n    }\n\n    return decorators;\n  }\n\n  get diagnostics() {\n    const diagnostics = [];\n\n    for (const clazz of this.classes.keys()) {\n      const record = this.classes.get(clazz);\n\n      if (record.metaDiagnostics !== null) {\n        diagnostics.push(...record.metaDiagnostics);\n      }\n\n      for (const trait of record.traits) {\n        if ((trait.state === TraitState.Analyzed || trait.state === TraitState.Resolved) && trait.analysisDiagnostics !== null) {\n          diagnostics.push(...trait.analysisDiagnostics);\n        }\n\n        if (trait.state === TraitState.Resolved && trait.resolveDiagnostics !== null) {\n          diagnostics.push(...trait.resolveDiagnostics);\n        }\n      }\n    }\n\n    return diagnostics;\n  }\n\n  get exportStatements() {\n    return this.reexportMap;\n  }\n\n}; // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/declaration.mjs\n\nimport ts12 from \"typescript\"; // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/utils.mjs\n\nimport ts11 from \"typescript\";\n\nfunction addImports(importManager, sf, extraStatements = []) {\n  const addedImports = importManager.getAllImports(sf.fileName).map(i => {\n    const qualifier = ts11.createIdentifier(i.qualifier.text);\n    const importClause = ts11.createImportClause(void 0, ts11.createNamespaceImport(qualifier));\n    const decl = ts11.createImportDeclaration(void 0, void 0, importClause, ts11.createLiteral(i.specifier));\n    ts11.setOriginalNode(i.qualifier, decl);\n    return decl;\n  });\n  const existingImports = sf.statements.filter(stmt => isImportStatement(stmt));\n  const body = sf.statements.filter(stmt => !isImportStatement(stmt));\n\n  if (addedImports.length > 0) {\n    const fileoverviewAnchorStmt = ts11.createNotEmittedStatement(sf);\n    return ts11.updateSourceFileNode(sf, ts11.createNodeArray([fileoverviewAnchorStmt, ...existingImports, ...addedImports, ...extraStatements, ...body]));\n  }\n\n  return sf;\n}\n\nfunction isImportStatement(stmt) {\n  return ts11.isImportDeclaration(stmt) || ts11.isImportEqualsDeclaration(stmt) || ts11.isNamespaceImport(stmt);\n} // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/declaration.mjs\n\n\nvar DtsTransformRegistry = class {\n  constructor() {\n    this.ivyDeclarationTransforms = new Map();\n  }\n\n  getIvyDeclarationTransform(sf) {\n    if (!this.ivyDeclarationTransforms.has(sf)) {\n      this.ivyDeclarationTransforms.set(sf, new IvyDeclarationDtsTransform());\n    }\n\n    return this.ivyDeclarationTransforms.get(sf);\n  }\n\n  getAllTransforms(sf) {\n    if (!sf.isDeclarationFile) {\n      return null;\n    }\n\n    const originalSf = ts12.getOriginalNode(sf);\n    let transforms = null;\n\n    if (this.ivyDeclarationTransforms.has(originalSf)) {\n      transforms = [];\n      transforms.push(this.ivyDeclarationTransforms.get(originalSf));\n    }\n\n    return transforms;\n  }\n\n};\n\nfunction declarationTransformFactory(transformRegistry, importRewriter, importPrefix) {\n  return context => {\n    const transformer = new DtsTransformer(context, importRewriter, importPrefix);\n    return fileOrBundle => {\n      if (ts12.isBundle(fileOrBundle)) {\n        return fileOrBundle;\n      }\n\n      const transforms = transformRegistry.getAllTransforms(fileOrBundle);\n\n      if (transforms === null) {\n        return fileOrBundle;\n      }\n\n      return transformer.transform(fileOrBundle, transforms);\n    };\n  };\n}\n\nvar DtsTransformer = class {\n  constructor(ctx, importRewriter, importPrefix) {\n    this.ctx = ctx;\n    this.importRewriter = importRewriter;\n    this.importPrefix = importPrefix;\n  }\n\n  transform(sf, transforms) {\n    const imports = new ImportManager(this.importRewriter, this.importPrefix);\n\n    const visitor = node => {\n      if (ts12.isClassDeclaration(node)) {\n        return this.transformClassDeclaration(node, transforms, imports);\n      } else if (ts12.isFunctionDeclaration(node)) {\n        return this.transformFunctionDeclaration(node, transforms, imports);\n      } else {\n        return ts12.visitEachChild(node, visitor, this.ctx);\n      }\n    };\n\n    sf = ts12.visitNode(sf, visitor);\n    return addImports(imports, sf);\n  }\n\n  transformClassDeclaration(clazz, transforms, imports) {\n    let elements = clazz.members;\n    let elementsChanged = false;\n\n    for (const transform of transforms) {\n      if (transform.transformClassElement !== void 0) {\n        for (let i = 0; i < elements.length; i++) {\n          const res = transform.transformClassElement(elements[i], imports);\n\n          if (res !== elements[i]) {\n            if (!elementsChanged) {\n              elements = [...elements];\n              elementsChanged = true;\n            }\n\n            elements[i] = res;\n          }\n        }\n      }\n    }\n\n    let newClazz = clazz;\n\n    for (const transform of transforms) {\n      if (transform.transformClass !== void 0) {\n        const inputMembers = clazz === newClazz ? elements : newClazz.members;\n        newClazz = transform.transformClass(newClazz, inputMembers, imports);\n      }\n    }\n\n    if (elementsChanged && clazz === newClazz) {\n      newClazz = ts12.updateClassDeclaration(clazz, clazz.decorators, clazz.modifiers, clazz.name, clazz.typeParameters, clazz.heritageClauses, elements);\n    }\n\n    return newClazz;\n  }\n\n  transformFunctionDeclaration(declaration, transforms, imports) {\n    let newDecl = declaration;\n\n    for (const transform of transforms) {\n      if (transform.transformFunctionDeclaration !== void 0) {\n        newDecl = transform.transformFunctionDeclaration(newDecl, imports);\n      }\n    }\n\n    return newDecl;\n  }\n\n};\nvar IvyDeclarationDtsTransform = class {\n  constructor() {\n    this.declarationFields = new Map();\n  }\n\n  addFields(decl, fields) {\n    this.declarationFields.set(decl, fields);\n  }\n\n  transformClass(clazz, members, imports) {\n    const original = ts12.getOriginalNode(clazz);\n\n    if (!this.declarationFields.has(original)) {\n      return clazz;\n    }\n\n    const fields = this.declarationFields.get(original);\n    const newMembers = fields.map(decl => {\n      const modifiers = [ts12.createModifier(ts12.SyntaxKind.StaticKeyword)];\n      const typeRef = translateType(decl.type, imports);\n      markForEmitAsSingleLine(typeRef);\n      return ts12.createProperty(void 0, modifiers, decl.name, void 0, typeRef, void 0);\n    });\n    return ts12.updateClassDeclaration(clazz, clazz.decorators, clazz.modifiers, clazz.name, clazz.typeParameters, clazz.heritageClauses, [...members, ...newMembers]);\n  }\n\n};\n\nfunction markForEmitAsSingleLine(node) {\n  ts12.setEmitFlags(node, ts12.EmitFlags.SingleLine);\n  ts12.forEachChild(node, markForEmitAsSingleLine);\n} // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/transform.mjs\n\n\nimport { ConstantPool } from \"@angular/compiler\";\nimport ts14 from \"typescript\"; // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/util/src/visitor.mjs\n\nimport ts13 from \"typescript\";\n\nfunction visit(node, visitor, context) {\n  return visitor._visit(node, context);\n}\n\nvar Visitor = class {\n  constructor() {\n    this._before = new Map();\n    this._after = new Map();\n  }\n\n  _visitListEntryNode(node, visitor) {\n    const result = visitor(node);\n\n    if (result.before !== void 0) {\n      this._before.set(result.node, result.before);\n    }\n\n    if (result.after !== void 0) {\n      this._after.set(result.node, result.after);\n    }\n\n    return result.node;\n  }\n\n  visitOtherNode(node) {\n    return node;\n  }\n\n  _visit(node, context) {\n    let visitedNode = null;\n    node = ts13.visitEachChild(node, child => this._visit(child, context), context);\n\n    if (ts13.isClassDeclaration(node)) {\n      visitedNode = this._visitListEntryNode(node, node2 => this.visitClassDeclaration(node2));\n    } else {\n      visitedNode = this.visitOtherNode(node);\n    }\n\n    if (hasStatements(visitedNode)) {\n      visitedNode = this._maybeProcessStatements(visitedNode);\n    }\n\n    return visitedNode;\n  }\n\n  _maybeProcessStatements(node) {\n    if (node.statements.every(stmt => !this._before.has(stmt) && !this._after.has(stmt))) {\n      return node;\n    }\n\n    const clone = ts13.getMutableClone(node);\n    const newStatements = [];\n    clone.statements.forEach(stmt => {\n      if (this._before.has(stmt)) {\n        newStatements.push(...this._before.get(stmt));\n\n        this._before.delete(stmt);\n      }\n\n      newStatements.push(stmt);\n\n      if (this._after.has(stmt)) {\n        newStatements.push(...this._after.get(stmt));\n\n        this._after.delete(stmt);\n      }\n    });\n    clone.statements = ts13.createNodeArray(newStatements, node.statements.hasTrailingComma);\n    return clone;\n  }\n\n};\n\nfunction hasStatements(node) {\n  const block = node;\n  return block.statements !== void 0 && Array.isArray(block.statements);\n} // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/transform.mjs\n\n\nvar NO_DECORATORS = new Set();\nvar CLOSURE_FILE_OVERVIEW_REGEXP = /\\s+@fileoverview\\s+/i;\n\nfunction ivyTransformFactory(compilation, reflector, importRewriter, defaultImportTracker, perf, isCore, isClosureCompilerEnabled) {\n  const recordWrappedNode = createRecorderFn(defaultImportTracker);\n  return context => {\n    return file => {\n      return perf.inPhase(PerfPhase.Compile, () => transformIvySourceFile(compilation, context, reflector, importRewriter, file, isCore, isClosureCompilerEnabled, recordWrappedNode));\n    };\n  };\n}\n\nvar IvyCompilationVisitor = class extends Visitor {\n  constructor(compilation, constantPool) {\n    super();\n    this.compilation = compilation;\n    this.constantPool = constantPool;\n    this.classCompilationMap = new Map();\n  }\n\n  visitClassDeclaration(node) {\n    const result = this.compilation.compile(node, this.constantPool);\n\n    if (result !== null) {\n      this.classCompilationMap.set(node, result);\n    }\n\n    return {\n      node\n    };\n  }\n\n};\nvar IvyTransformationVisitor = class extends Visitor {\n  constructor(compilation, classCompilationMap, reflector, importManager, recordWrappedNodeExpr, isClosureCompilerEnabled, isCore) {\n    super();\n    this.compilation = compilation;\n    this.classCompilationMap = classCompilationMap;\n    this.reflector = reflector;\n    this.importManager = importManager;\n    this.recordWrappedNodeExpr = recordWrappedNodeExpr;\n    this.isClosureCompilerEnabled = isClosureCompilerEnabled;\n    this.isCore = isCore;\n  }\n\n  visitClassDeclaration(node) {\n    if (!this.classCompilationMap.has(node)) {\n      return {\n        node\n      };\n    }\n\n    const translateOptions = {\n      recordWrappedNode: this.recordWrappedNodeExpr,\n      annotateForClosureCompiler: this.isClosureCompilerEnabled\n    };\n    const statements = [];\n    const members = [...node.members];\n\n    for (const field of this.classCompilationMap.get(node)) {\n      const exprNode = translateExpression(field.initializer, this.importManager, translateOptions);\n      const property = ts14.createProperty(void 0, [ts14.createToken(ts14.SyntaxKind.StaticKeyword)], field.name, void 0, void 0, exprNode);\n\n      if (this.isClosureCompilerEnabled) {\n        ts14.addSyntheticLeadingComment(property, ts14.SyntaxKind.MultiLineCommentTrivia, \"* @nocollapse \", false);\n      }\n\n      field.statements.map(stmt => translateStatement(stmt, this.importManager, translateOptions)).forEach(stmt => statements.push(stmt));\n      members.push(property);\n    }\n\n    node = ts14.updateClassDeclaration(node, maybeFilterDecorator(node.decorators, this.compilation.decoratorsFor(node)), node.modifiers, node.name, node.typeParameters, node.heritageClauses || [], members.map(member => this._stripAngularDecorators(member)));\n    return {\n      node,\n      after: statements\n    };\n  }\n\n  _angularCoreDecorators(decl) {\n    const decorators = this.reflector.getDecoratorsOfDeclaration(decl);\n\n    if (decorators === null) {\n      return NO_DECORATORS;\n    }\n\n    const coreDecorators = decorators.filter(dec => this.isCore || isFromAngularCore(dec)).map(dec => dec.node);\n\n    if (coreDecorators.length > 0) {\n      return new Set(coreDecorators);\n    } else {\n      return NO_DECORATORS;\n    }\n  }\n\n  _nonCoreDecoratorsOnly(node) {\n    if (node.decorators === void 0) {\n      return void 0;\n    }\n\n    const coreDecorators = this._angularCoreDecorators(node);\n\n    if (coreDecorators.size === node.decorators.length) {\n      return void 0;\n    } else if (coreDecorators.size === 0) {\n      return node.decorators;\n    }\n\n    const filtered = node.decorators.filter(dec => !coreDecorators.has(dec));\n\n    if (filtered.length === 0) {\n      return void 0;\n    }\n\n    const array = ts14.createNodeArray(filtered);\n    array.pos = node.decorators.pos;\n    array.end = node.decorators.end;\n    return array;\n  }\n\n  _stripAngularDecorators(node) {\n    if (ts14.isParameter(node)) {\n      node = ts14.updateParameter(node, this._nonCoreDecoratorsOnly(node), node.modifiers, node.dotDotDotToken, node.name, node.questionToken, node.type, node.initializer);\n    } else if (ts14.isMethodDeclaration(node) && node.decorators !== void 0) {\n      node = ts14.updateMethod(node, this._nonCoreDecoratorsOnly(node), node.modifiers, node.asteriskToken, node.name, node.questionToken, node.typeParameters, node.parameters, node.type, node.body);\n    } else if (ts14.isPropertyDeclaration(node) && node.decorators !== void 0) {\n      node = ts14.updateProperty(node, this._nonCoreDecoratorsOnly(node), node.modifiers, node.name, node.questionToken, node.type, node.initializer);\n    } else if (ts14.isGetAccessor(node)) {\n      node = ts14.updateGetAccessor(node, this._nonCoreDecoratorsOnly(node), node.modifiers, node.name, node.parameters, node.type, node.body);\n    } else if (ts14.isSetAccessor(node)) {\n      node = ts14.updateSetAccessor(node, this._nonCoreDecoratorsOnly(node), node.modifiers, node.name, node.parameters, node.body);\n    } else if (ts14.isConstructorDeclaration(node)) {\n      const parameters = node.parameters.map(param => this._stripAngularDecorators(param));\n      node = ts14.updateConstructor(node, node.decorators, node.modifiers, parameters, node.body);\n    }\n\n    return node;\n  }\n\n};\n\nfunction transformIvySourceFile(compilation, context, reflector, importRewriter, file, isCore, isClosureCompilerEnabled, recordWrappedNode) {\n  const constantPool = new ConstantPool(isClosureCompilerEnabled);\n  const importManager = new ImportManager(importRewriter);\n  const compilationVisitor = new IvyCompilationVisitor(compilation, constantPool);\n  visit(file, compilationVisitor, context);\n  const transformationVisitor = new IvyTransformationVisitor(compilation, compilationVisitor.classCompilationMap, reflector, importManager, recordWrappedNode, isClosureCompilerEnabled, isCore);\n  let sf = visit(file, transformationVisitor, context);\n  const downlevelTranslatedCode = getLocalizeCompileTarget(context) < ts14.ScriptTarget.ES2015;\n  const constants = constantPool.statements.map(stmt => translateStatement(stmt, importManager, {\n    recordWrappedNode,\n    downlevelTaggedTemplates: downlevelTranslatedCode,\n    downlevelVariableDeclarations: downlevelTranslatedCode,\n    annotateForClosureCompiler: isClosureCompilerEnabled\n  }));\n  const fileOverviewMeta = isClosureCompilerEnabled ? getFileOverviewComment(sf.statements) : null;\n  sf = addImports(importManager, sf, constants);\n\n  if (fileOverviewMeta !== null) {\n    setFileOverviewComment(sf, fileOverviewMeta);\n  }\n\n  return sf;\n}\n\nfunction getLocalizeCompileTarget(context) {\n  const target = context.getCompilerOptions().target || ts14.ScriptTarget.ES2015;\n  return target !== ts14.ScriptTarget.JSON ? target : ts14.ScriptTarget.ES2015;\n}\n\nfunction getFileOverviewComment(statements) {\n  if (statements.length > 0) {\n    const host = statements[0];\n    let trailing = false;\n    let comments = ts14.getSyntheticLeadingComments(host);\n\n    if (!comments || comments.length === 0) {\n      trailing = true;\n      comments = ts14.getSyntheticTrailingComments(host);\n    }\n\n    if (comments && comments.length > 0 && CLOSURE_FILE_OVERVIEW_REGEXP.test(comments[0].text)) {\n      return {\n        comments,\n        host,\n        trailing\n      };\n    }\n  }\n\n  return null;\n}\n\nfunction setFileOverviewComment(sf, fileoverview) {\n  const {\n    comments,\n    host,\n    trailing\n  } = fileoverview;\n\n  if (sf.statements.length > 0 && host !== sf.statements[0]) {\n    if (trailing) {\n      ts14.setSyntheticTrailingComments(host, void 0);\n    } else {\n      ts14.setSyntheticLeadingComments(host, void 0);\n    }\n\n    ts14.setSyntheticLeadingComments(sf.statements[0], comments);\n  }\n}\n\nfunction maybeFilterDecorator(decorators, toRemove) {\n  if (decorators === void 0) {\n    return void 0;\n  }\n\n  const filtered = decorators.filter(dec => toRemove.find(decToRemove => ts14.getOriginalNode(dec) === decToRemove) === void 0);\n\n  if (filtered.length === 0) {\n    return void 0;\n  }\n\n  return ts14.createNodeArray(filtered);\n}\n\nfunction isFromAngularCore(decorator) {\n  return decorator.import !== null && decorator.import.from === \"@angular/core\";\n}\n\nfunction createRecorderFn(defaultImportTracker) {\n  return node => {\n    const importDecl = getDefaultImportDeclaration(node);\n\n    if (importDecl !== null) {\n      defaultImportTracker.recordUsedImport(importDecl);\n    }\n  };\n} // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/src/diagnostics.mjs\n\n\nimport ts15 from \"typescript\";\n\nfunction createValueHasWrongTypeError(node, value, messageText) {\n  var _a;\n\n  let chainedMessage;\n  let relatedInformation;\n\n  if (value instanceof DynamicValue) {\n    chainedMessage = \"Value could not be determined statically.\";\n    relatedInformation = traceDynamicValue(node, value);\n  } else if (value instanceof Reference) {\n    const target = value.debugName !== null ? `'${value.debugName}'` : \"an anonymous declaration\";\n    chainedMessage = `Value is a reference to ${target}.`;\n    const referenceNode = (_a = identifierOfNode(value.node)) != null ? _a : value.node;\n    relatedInformation = [makeRelatedInformation(referenceNode, \"Reference is declared here.\")];\n  } else {\n    chainedMessage = `Value is of type '${describeResolvedType(value)}'.`;\n  }\n\n  const chain = {\n    messageText,\n    category: ts15.DiagnosticCategory.Error,\n    code: 0,\n    next: [{\n      messageText: chainedMessage,\n      category: ts15.DiagnosticCategory.Message,\n      code: 0\n    }]\n  };\n  return new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, node, chain, relatedInformation);\n}\n\nfunction getProviderDiagnostics(providerClasses, providersDeclaration, registry) {\n  const diagnostics = [];\n\n  for (const provider of providerClasses) {\n    if (registry.isInjectable(provider.node)) {\n      continue;\n    }\n\n    const contextNode = provider.getOriginForDiagnostics(providersDeclaration);\n    diagnostics.push(makeDiagnostic(ErrorCode.UNDECORATED_PROVIDER, contextNode, `The class '${provider.node.name.text}' cannot be created via dependency injection, as it does not have an Angular decorator. This will result in an error at runtime.\n\nEither add the @Injectable() decorator to '${provider.node.name.text}', or configure a different provider (such as a provider with 'useFactory').\n`, [makeRelatedInformation(provider.node, `'${provider.node.name.text}' is declared here.`)]));\n  }\n\n  return diagnostics;\n}\n\nfunction getDirectiveDiagnostics(node, reader, evaluator, reflector, scopeRegistry, kind) {\n  let diagnostics = [];\n\n  const addDiagnostics = more => {\n    if (more === null) {\n      return;\n    } else if (diagnostics === null) {\n      diagnostics = Array.isArray(more) ? more : [more];\n    } else if (Array.isArray(more)) {\n      diagnostics.push(...more);\n    } else {\n      diagnostics.push(more);\n    }\n  };\n\n  const duplicateDeclarations = scopeRegistry.getDuplicateDeclarations(node);\n\n  if (duplicateDeclarations !== null) {\n    addDiagnostics(makeDuplicateDeclarationError(node, duplicateDeclarations, kind));\n  }\n\n  addDiagnostics(checkInheritanceOfDirective(node, reader, reflector, evaluator));\n  return diagnostics;\n}\n\nfunction getUndecoratedClassWithAngularFeaturesDiagnostic(node) {\n  return makeDiagnostic(ErrorCode.UNDECORATED_CLASS_USING_ANGULAR_FEATURES, node.name, `Class is using Angular features but is not decorated. Please add an explicit Angular decorator.`);\n}\n\nfunction checkInheritanceOfDirective(node, reader, reflector, evaluator) {\n  if (!reflector.isClass(node) || reflector.getConstructorParameters(node) !== null) {\n    return null;\n  }\n\n  let baseClass = readBaseClass(node, reflector, evaluator);\n\n  while (baseClass !== null) {\n    if (baseClass === \"dynamic\") {\n      return null;\n    }\n\n    const baseClassMeta = reader.getDirectiveMetadata(baseClass);\n\n    if (baseClassMeta !== null) {\n      return null;\n    }\n\n    const baseClassConstructorParams = reflector.getConstructorParameters(baseClass.node);\n    const newParentClass = readBaseClass(baseClass.node, reflector, evaluator);\n\n    if (baseClassConstructorParams !== null && baseClassConstructorParams.length > 0) {\n      return getInheritedUndecoratedCtorDiagnostic(node, baseClass, reader);\n    } else if (baseClassConstructorParams !== null || newParentClass === null) {\n      return null;\n    }\n\n    baseClass = newParentClass;\n  }\n\n  return null;\n}\n\nfunction getInheritedUndecoratedCtorDiagnostic(node, baseClass, reader) {\n  const subclassMeta = reader.getDirectiveMetadata(new Reference(node));\n  const dirOrComp = subclassMeta.isComponent ? \"Component\" : \"Directive\";\n  const baseClassName = baseClass.debugName;\n  return makeDiagnostic(ErrorCode.DIRECTIVE_INHERITS_UNDECORATED_CTOR, node.name, `The ${dirOrComp.toLowerCase()} ${node.name.text} inherits its constructor from ${baseClassName}, but the latter does not have an Angular decorator of its own. Dependency injection will not be able to resolve the parameters of ${baseClassName}'s constructor. Either add a @Directive decorator to ${baseClassName}, or add an explicit constructor to ${node.name.text}.`);\n} // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/src/directive.mjs\n\n\nimport { compileClassMetadata, compileDeclareClassMetadata, compileDeclareDirectiveFromMetadata, compileDirectiveFromMetadata, createMayBeForwardRefExpression, emitDistinctChangesOnlyDefaultValue, ExternalExpr as ExternalExpr3, FactoryTarget, getSafePropertyAccessString, makeBindingParser, parseHostBindings, verifyHostBindings, WrappedNodeExpr as WrappedNodeExpr3 } from \"@angular/compiler\";\nimport ts17 from \"typescript\"; // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/src/factory.mjs\n\nimport { compileDeclareFactoryFunction, compileFactoryFunction } from \"@angular/compiler\";\n\nfunction compileNgFactoryDefField(metadata) {\n  const res = compileFactoryFunction(metadata);\n  return {\n    name: \"\\u0275fac\",\n    initializer: res.expression,\n    statements: res.statements,\n    type: res.type\n  };\n}\n\nfunction compileDeclareFactory(metadata) {\n  const res = compileDeclareFactoryFunction(metadata);\n  return {\n    name: \"\\u0275fac\",\n    initializer: res.expression,\n    statements: res.statements,\n    type: res.type\n  };\n} // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/src/metadata.mjs\n\n\nimport { FunctionExpr, LiteralArrayExpr, LiteralExpr as LiteralExpr2, literalMap, ReturnStatement, WrappedNodeExpr as WrappedNodeExpr2 } from \"@angular/compiler\";\nimport ts16 from \"typescript\";\n\nfunction extractClassMetadata(clazz, reflection, isCore, annotateForClosureCompiler, angularDecoratorTransform = dec => dec) {\n  if (!reflection.isClass(clazz)) {\n    return null;\n  }\n\n  const id = reflection.getAdjacentNameOfClass(clazz);\n  const classDecorators = reflection.getDecoratorsOfDeclaration(clazz);\n\n  if (classDecorators === null) {\n    return null;\n  }\n\n  const ngClassDecorators = classDecorators.filter(dec => isAngularDecorator2(dec, isCore)).map(decorator => decoratorToMetadata(angularDecoratorTransform(decorator), annotateForClosureCompiler)).map(decorator => removeIdentifierReferences(decorator, id.text));\n\n  if (ngClassDecorators.length === 0) {\n    return null;\n  }\n\n  const metaDecorators = new WrappedNodeExpr2(ts16.createArrayLiteral(ngClassDecorators));\n  let metaCtorParameters = null;\n  const classCtorParameters = reflection.getConstructorParameters(clazz);\n\n  if (classCtorParameters !== null) {\n    const ctorParameters = classCtorParameters.map(param => ctorParameterToMetadata(param, isCore));\n    metaCtorParameters = new FunctionExpr([], [new ReturnStatement(new LiteralArrayExpr(ctorParameters))]);\n  }\n\n  let metaPropDecorators = null;\n  const classMembers = reflection.getMembersOfClass(clazz).filter(member => !member.isStatic && member.decorators !== null && member.decorators.length > 0);\n  const duplicateDecoratedMemberNames = classMembers.map(member => member.name).filter((name, i, arr) => arr.indexOf(name) < i);\n\n  if (duplicateDecoratedMemberNames.length > 0) {\n    throw new Error(`Duplicate decorated properties found on class '${clazz.name.text}': ` + duplicateDecoratedMemberNames.join(\", \"));\n  }\n\n  const decoratedMembers = classMembers.map(member => {\n    var _a;\n\n    return classMemberToMetadata((_a = member.nameNode) != null ? _a : member.name, member.decorators, isCore);\n  });\n\n  if (decoratedMembers.length > 0) {\n    metaPropDecorators = new WrappedNodeExpr2(ts16.createObjectLiteral(decoratedMembers));\n  }\n\n  return {\n    type: new WrappedNodeExpr2(id),\n    decorators: metaDecorators,\n    ctorParameters: metaCtorParameters,\n    propDecorators: metaPropDecorators\n  };\n}\n\nfunction ctorParameterToMetadata(param, isCore) {\n  const type = param.typeValueReference.kind !== 2 ? valueReferenceToExpression(param.typeValueReference) : new LiteralExpr2(void 0);\n  const mapEntries = [{\n    key: \"type\",\n    value: type,\n    quoted: false\n  }];\n\n  if (param.decorators !== null) {\n    const ngDecorators = param.decorators.filter(dec => isAngularDecorator2(dec, isCore)).map(decorator => decoratorToMetadata(decorator));\n    const value = new WrappedNodeExpr2(ts16.createArrayLiteral(ngDecorators));\n    mapEntries.push({\n      key: \"decorators\",\n      value,\n      quoted: false\n    });\n  }\n\n  return literalMap(mapEntries);\n}\n\nfunction classMemberToMetadata(name, decorators, isCore) {\n  const ngDecorators = decorators.filter(dec => isAngularDecorator2(dec, isCore)).map(decorator => decoratorToMetadata(decorator));\n  const decoratorMeta = ts16.createArrayLiteral(ngDecorators);\n  return ts16.createPropertyAssignment(name, decoratorMeta);\n}\n\nfunction decoratorToMetadata(decorator, wrapFunctionsInParens) {\n  if (decorator.identifier === null) {\n    throw new Error(\"Illegal state: synthesized decorator cannot be emitted in class metadata.\");\n  }\n\n  const properties = [ts16.createPropertyAssignment(\"type\", ts16.getMutableClone(decorator.identifier))];\n\n  if (decorator.args !== null && decorator.args.length > 0) {\n    const args = decorator.args.map(arg => {\n      const expr = ts16.getMutableClone(arg);\n      return wrapFunctionsInParens ? wrapFunctionExpressionsInParens(expr) : expr;\n    });\n    properties.push(ts16.createPropertyAssignment(\"args\", ts16.createArrayLiteral(args)));\n  }\n\n  return ts16.createObjectLiteral(properties, true);\n}\n\nfunction isAngularDecorator2(decorator, isCore) {\n  return isCore || decorator.import !== null && decorator.import.from === \"@angular/core\";\n}\n\nfunction removeIdentifierReferences(node, name) {\n  const result = ts16.transform(node, [context => root => ts16.visitNode(root, function walk(current) {\n    return ts16.isIdentifier(current) && current.text === name ? ts16.createIdentifier(current.text) : ts16.visitEachChild(current, walk, context);\n  })]);\n  return result.transformed[0];\n} // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/src/directive.mjs\n\n\nvar EMPTY_OBJECT = {};\nvar FIELD_DECORATORS = [\"Input\", \"Output\", \"ViewChild\", \"ViewChildren\", \"ContentChild\", \"ContentChildren\", \"HostBinding\", \"HostListener\"];\nvar LIFECYCLE_HOOKS = new Set([\"ngOnChanges\", \"ngOnInit\", \"ngOnDestroy\", \"ngDoCheck\", \"ngAfterViewInit\", \"ngAfterViewChecked\", \"ngAfterContentInit\", \"ngAfterContentChecked\"]);\nvar DirectiveSymbol = class extends SemanticSymbol {\n  constructor(decl, selector, inputs, outputs, exportAs, typeCheckMeta, typeParameters) {\n    super(decl);\n    this.selector = selector;\n    this.inputs = inputs;\n    this.outputs = outputs;\n    this.exportAs = exportAs;\n    this.typeCheckMeta = typeCheckMeta;\n    this.typeParameters = typeParameters;\n    this.baseClass = null;\n  }\n\n  isPublicApiAffected(previousSymbol) {\n    if (!(previousSymbol instanceof DirectiveSymbol)) {\n      return true;\n    }\n\n    return this.selector !== previousSymbol.selector || !isArrayEqual(this.inputs.propertyNames, previousSymbol.inputs.propertyNames) || !isArrayEqual(this.outputs.propertyNames, previousSymbol.outputs.propertyNames) || !isArrayEqual(this.exportAs, previousSymbol.exportAs);\n  }\n\n  isTypeCheckApiAffected(previousSymbol) {\n    if (this.isPublicApiAffected(previousSymbol)) {\n      return true;\n    }\n\n    if (!(previousSymbol instanceof DirectiveSymbol)) {\n      return true;\n    }\n\n    if (!isArrayEqual(Array.from(this.inputs), Array.from(previousSymbol.inputs), isInputMappingEqual) || !isArrayEqual(Array.from(this.outputs), Array.from(previousSymbol.outputs), isInputMappingEqual)) {\n      return true;\n    }\n\n    if (!areTypeParametersEqual(this.typeParameters, previousSymbol.typeParameters)) {\n      return true;\n    }\n\n    if (!isTypeCheckMetaEqual(this.typeCheckMeta, previousSymbol.typeCheckMeta)) {\n      return true;\n    }\n\n    if (!isBaseClassEqual(this.baseClass, previousSymbol.baseClass)) {\n      return true;\n    }\n\n    return false;\n  }\n\n};\n\nfunction isInputMappingEqual(current, previous) {\n  return current[0] === previous[0] && current[1] === previous[1];\n}\n\nfunction isTypeCheckMetaEqual(current, previous) {\n  if (current.hasNgTemplateContextGuard !== previous.hasNgTemplateContextGuard) {\n    return false;\n  }\n\n  if (current.isGeneric !== previous.isGeneric) {\n    return false;\n  }\n\n  if (!isArrayEqual(current.ngTemplateGuards, previous.ngTemplateGuards, isTemplateGuardEqual)) {\n    return false;\n  }\n\n  if (!isSetEqual(current.coercedInputFields, previous.coercedInputFields)) {\n    return false;\n  }\n\n  if (!isSetEqual(current.restrictedInputFields, previous.restrictedInputFields)) {\n    return false;\n  }\n\n  if (!isSetEqual(current.stringLiteralInputFields, previous.stringLiteralInputFields)) {\n    return false;\n  }\n\n  if (!isSetEqual(current.undeclaredInputFields, previous.undeclaredInputFields)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isTemplateGuardEqual(current, previous) {\n  return current.inputName === previous.inputName && current.type === previous.type;\n}\n\nfunction isBaseClassEqual(current, previous) {\n  if (current === null || previous === null) {\n    return current === previous;\n  }\n\n  return isSymbolEqual(current, previous);\n}\n\nvar DirectiveDecoratorHandler = class {\n  constructor(reflector, evaluator, metaRegistry, scopeRegistry, metaReader, injectableRegistry, isCore, semanticDepGraphUpdater, annotateForClosureCompiler, compileUndecoratedClassesWithAngularFeatures, perf) {\n    this.reflector = reflector;\n    this.evaluator = evaluator;\n    this.metaRegistry = metaRegistry;\n    this.scopeRegistry = scopeRegistry;\n    this.metaReader = metaReader;\n    this.injectableRegistry = injectableRegistry;\n    this.isCore = isCore;\n    this.semanticDepGraphUpdater = semanticDepGraphUpdater;\n    this.annotateForClosureCompiler = annotateForClosureCompiler;\n    this.compileUndecoratedClassesWithAngularFeatures = compileUndecoratedClassesWithAngularFeatures;\n    this.perf = perf;\n    this.precedence = HandlerPrecedence.PRIMARY;\n    this.name = DirectiveDecoratorHandler.name;\n  }\n\n  detect(node, decorators) {\n    if (!decorators) {\n      const angularField = this.findClassFieldWithAngularFeatures(node);\n      return angularField ? {\n        trigger: angularField.node,\n        decorator: null,\n        metadata: null\n      } : void 0;\n    } else {\n      const decorator = findAngularDecorator(decorators, \"Directive\", this.isCore);\n      return decorator ? {\n        trigger: decorator.node,\n        decorator,\n        metadata: decorator\n      } : void 0;\n    }\n  }\n\n  analyze(node, decorator, flags = HandlerFlags.NONE) {\n    if (this.compileUndecoratedClassesWithAngularFeatures === false && decorator === null) {\n      return {\n        diagnostics: [getUndecoratedClassWithAngularFeaturesDiagnostic(node)]\n      };\n    }\n\n    this.perf.eventCount(PerfEvent.AnalyzeDirective);\n    const directiveResult = extractDirectiveMetadata(node, decorator, this.reflector, this.evaluator, this.isCore, flags, this.annotateForClosureCompiler);\n\n    if (directiveResult === void 0) {\n      return {};\n    }\n\n    const analysis = directiveResult.metadata;\n    let providersRequiringFactory = null;\n\n    if (directiveResult !== void 0 && directiveResult.decorator.has(\"providers\")) {\n      providersRequiringFactory = resolveProvidersRequiringFactory(directiveResult.decorator.get(\"providers\"), this.reflector, this.evaluator);\n    }\n\n    return {\n      analysis: {\n        inputs: directiveResult.inputs,\n        outputs: directiveResult.outputs,\n        meta: analysis,\n        classMetadata: extractClassMetadata(node, this.reflector, this.isCore, this.annotateForClosureCompiler),\n        baseClass: readBaseClass(node, this.reflector, this.evaluator),\n        typeCheckMeta: extractDirectiveTypeCheckMeta(node, directiveResult.inputs, this.reflector),\n        providersRequiringFactory,\n        isPoisoned: false,\n        isStructural: directiveResult.isStructural\n      }\n    };\n  }\n\n  symbol(node, analysis) {\n    const typeParameters = extractSemanticTypeParameters(node);\n    return new DirectiveSymbol(node, analysis.meta.selector, analysis.inputs, analysis.outputs, analysis.meta.exportAs, analysis.typeCheckMeta, typeParameters);\n  }\n\n  register(node, analysis) {\n    const ref = new Reference(node);\n    this.metaRegistry.registerDirectiveMetadata(__spreadProps(__spreadValues({\n      type: MetaType.Directive,\n      ref,\n      name: node.name.text,\n      selector: analysis.meta.selector,\n      exportAs: analysis.meta.exportAs,\n      inputs: analysis.inputs,\n      outputs: analysis.outputs,\n      queries: analysis.meta.queries.map(query => query.propertyName),\n      isComponent: false,\n      baseClass: analysis.baseClass\n    }, analysis.typeCheckMeta), {\n      isPoisoned: analysis.isPoisoned,\n      isStructural: analysis.isStructural\n    }));\n    this.injectableRegistry.registerInjectable(node);\n  }\n\n  resolve(node, analysis, symbol) {\n    if (this.semanticDepGraphUpdater !== null && analysis.baseClass instanceof Reference) {\n      symbol.baseClass = this.semanticDepGraphUpdater.getSymbol(analysis.baseClass.node);\n    }\n\n    const diagnostics = [];\n\n    if (analysis.providersRequiringFactory !== null && analysis.meta.providers instanceof WrappedNodeExpr3) {\n      const providerDiagnostics = getProviderDiagnostics(analysis.providersRequiringFactory, analysis.meta.providers.node, this.injectableRegistry);\n      diagnostics.push(...providerDiagnostics);\n    }\n\n    const directiveDiagnostics = getDirectiveDiagnostics(node, this.metaReader, this.evaluator, this.reflector, this.scopeRegistry, \"Directive\");\n\n    if (directiveDiagnostics !== null) {\n      diagnostics.push(...directiveDiagnostics);\n    }\n\n    return {\n      diagnostics: diagnostics.length > 0 ? diagnostics : void 0\n    };\n  }\n\n  compileFull(node, analysis, resolution, pool) {\n    const fac = compileNgFactoryDefField(toFactoryMetadata(analysis.meta, FactoryTarget.Directive));\n    const def = compileDirectiveFromMetadata(analysis.meta, pool, makeBindingParser());\n    const classMetadata = analysis.classMetadata !== null ? compileClassMetadata(analysis.classMetadata).toStmt() : null;\n    return compileResults(fac, def, classMetadata, \"\\u0275dir\");\n  }\n\n  compilePartial(node, analysis, resolution) {\n    const fac = compileDeclareFactory(toFactoryMetadata(analysis.meta, FactoryTarget.Directive));\n    const def = compileDeclareDirectiveFromMetadata(analysis.meta);\n    const classMetadata = analysis.classMetadata !== null ? compileDeclareClassMetadata(analysis.classMetadata).toStmt() : null;\n    return compileResults(fac, def, classMetadata, \"\\u0275dir\");\n  }\n\n  findClassFieldWithAngularFeatures(node) {\n    return this.reflector.getMembersOfClass(node).find(member => {\n      if (!member.isStatic && member.kind === ClassMemberKind.Method && LIFECYCLE_HOOKS.has(member.name)) {\n        return true;\n      }\n\n      if (member.decorators) {\n        return member.decorators.some(decorator => FIELD_DECORATORS.some(decoratorName => isAngularDecorator(decorator, decoratorName, this.isCore)));\n      }\n\n      return false;\n    });\n  }\n\n};\n\nfunction extractDirectiveMetadata(clazz, decorator, reflector, evaluator, isCore, flags, annotateForClosureCompiler, defaultSelector = null) {\n  let directive;\n\n  if (decorator === null || decorator.args === null || decorator.args.length === 0) {\n    directive = new Map();\n  } else if (decorator.args.length !== 1) {\n    throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(decorator), `Incorrect number of arguments to @${decorator.name} decorator`);\n  } else {\n    const meta = unwrapExpression(decorator.args[0]);\n\n    if (!ts17.isObjectLiteralExpression(meta)) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, `@${decorator.name} argument must be an object literal`);\n    }\n\n    directive = reflectObjectLiteral(meta);\n  }\n\n  if (directive.has(\"jit\")) {\n    return void 0;\n  }\n\n  const members = reflector.getMembersOfClass(clazz);\n  const decoratedElements = members.filter(member => !member.isStatic && member.decorators !== null);\n  const coreModule = isCore ? void 0 : \"@angular/core\";\n  const inputsFromMeta = parseFieldToPropertyMapping(directive, \"inputs\", evaluator);\n  const inputsFromFields = parseDecoratedFields(filterToMembersWithDecorator(decoratedElements, \"Input\", coreModule), evaluator, resolveInput);\n  const outputsFromMeta = parseFieldToPropertyMapping(directive, \"outputs\", evaluator);\n  const outputsFromFields = parseDecoratedFields(filterToMembersWithDecorator(decoratedElements, \"Output\", coreModule), evaluator, resolveOutput);\n  const contentChildFromFields = queriesFromFields(filterToMembersWithDecorator(decoratedElements, \"ContentChild\", coreModule), reflector, evaluator);\n  const contentChildrenFromFields = queriesFromFields(filterToMembersWithDecorator(decoratedElements, \"ContentChildren\", coreModule), reflector, evaluator);\n  const queries = [...contentChildFromFields, ...contentChildrenFromFields];\n  const viewChildFromFields = queriesFromFields(filterToMembersWithDecorator(decoratedElements, \"ViewChild\", coreModule), reflector, evaluator);\n  const viewChildrenFromFields = queriesFromFields(filterToMembersWithDecorator(decoratedElements, \"ViewChildren\", coreModule), reflector, evaluator);\n  const viewQueries = [...viewChildFromFields, ...viewChildrenFromFields];\n\n  if (directive.has(\"queries\")) {\n    const queriesFromDecorator = extractQueriesFromDecorator(directive.get(\"queries\"), reflector, evaluator, isCore);\n    queries.push(...queriesFromDecorator.content);\n    viewQueries.push(...queriesFromDecorator.view);\n  }\n\n  let selector = defaultSelector;\n\n  if (directive.has(\"selector\")) {\n    const expr = directive.get(\"selector\");\n    const resolved = evaluator.evaluate(expr);\n\n    if (typeof resolved !== \"string\") {\n      throw createValueHasWrongTypeError(expr, resolved, `selector must be a string`);\n    }\n\n    selector = resolved === \"\" ? defaultSelector : resolved;\n\n    if (!selector) {\n      throw new FatalDiagnosticError(ErrorCode.DIRECTIVE_MISSING_SELECTOR, expr, `Directive ${clazz.name.text} has no selector, please add it!`);\n    }\n  }\n\n  const host = extractHostBindings(decoratedElements, evaluator, coreModule, directive);\n  const providers = directive.has(\"providers\") ? new WrappedNodeExpr3(annotateForClosureCompiler ? wrapFunctionExpressionsInParens(directive.get(\"providers\")) : directive.get(\"providers\")) : null;\n  const usesOnChanges = members.some(member => !member.isStatic && member.kind === ClassMemberKind.Method && member.name === \"ngOnChanges\");\n  let exportAs = null;\n\n  if (directive.has(\"exportAs\")) {\n    const expr = directive.get(\"exportAs\");\n    const resolved = evaluator.evaluate(expr);\n\n    if (typeof resolved !== \"string\") {\n      throw createValueHasWrongTypeError(expr, resolved, `exportAs must be a string`);\n    }\n\n    exportAs = resolved.split(\",\").map(part => part.trim());\n  }\n\n  const rawCtorDeps = getConstructorDependencies(clazz, reflector, isCore);\n  const ctorDeps = selector !== null ? validateConstructorDependencies(clazz, rawCtorDeps) : unwrapConstructorDependencies(rawCtorDeps);\n  const isStructural = ctorDeps !== null && ctorDeps !== \"invalid\" && ctorDeps.some(dep => dep.token instanceof ExternalExpr3 && dep.token.value.moduleName === \"@angular/core\" && dep.token.value.name === \"TemplateRef\");\n  const usesInheritance = reflector.hasBaseClass(clazz);\n  const type = wrapTypeReference(reflector, clazz);\n  const internalType = new WrappedNodeExpr3(reflector.getInternalNameOfClass(clazz));\n  const inputs = ClassPropertyMapping.fromMappedObject(__spreadValues(__spreadValues({}, inputsFromMeta), inputsFromFields));\n  const outputs = ClassPropertyMapping.fromMappedObject(__spreadValues(__spreadValues({}, outputsFromMeta), outputsFromFields));\n  const metadata = {\n    name: clazz.name.text,\n    deps: ctorDeps,\n    host,\n    lifecycle: {\n      usesOnChanges\n    },\n    inputs: inputs.toJointMappedObject(),\n    outputs: outputs.toDirectMappedObject(),\n    queries,\n    viewQueries,\n    selector,\n    fullInheritance: !!(flags & HandlerFlags.FULL_INHERITANCE),\n    type,\n    internalType,\n    typeArgumentCount: reflector.getGenericArityOfClass(clazz) || 0,\n    typeSourceSpan: createSourceSpan(clazz.name),\n    usesInheritance,\n    exportAs,\n    providers\n  };\n  return {\n    decorator: directive,\n    metadata,\n    inputs,\n    outputs,\n    isStructural\n  };\n}\n\nfunction extractQueryMetadata(exprNode, name, args, propertyName, reflector, evaluator) {\n  if (args.length === 0) {\n    throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, exprNode, `@${name} must have arguments`);\n  }\n\n  const first = name === \"ViewChild\" || name === \"ContentChild\";\n  const forwardReferenceTarget = tryUnwrapForwardRef(args[0], reflector);\n  const node = forwardReferenceTarget != null ? forwardReferenceTarget : args[0];\n  const arg = evaluator.evaluate(node);\n  let isStatic = false;\n  let predicate = null;\n\n  if (arg instanceof Reference || arg instanceof DynamicValue) {\n    predicate = createMayBeForwardRefExpression(new WrappedNodeExpr3(node), forwardReferenceTarget !== null ? 2 : 0);\n  } else if (typeof arg === \"string\") {\n    predicate = [arg];\n  } else if (isStringArrayOrDie(arg, `@${name} predicate`, node)) {\n    predicate = arg;\n  } else {\n    throw createValueHasWrongTypeError(node, arg, `@${name} predicate cannot be interpreted`);\n  }\n\n  let read = null;\n  let descendants = name !== \"ContentChildren\";\n  let emitDistinctChangesOnly = emitDistinctChangesOnlyDefaultValue;\n\n  if (args.length === 2) {\n    const optionsExpr = unwrapExpression(args[1]);\n\n    if (!ts17.isObjectLiteralExpression(optionsExpr)) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, optionsExpr, `@${name} options must be an object literal`);\n    }\n\n    const options = reflectObjectLiteral(optionsExpr);\n\n    if (options.has(\"read\")) {\n      read = new WrappedNodeExpr3(options.get(\"read\"));\n    }\n\n    if (options.has(\"descendants\")) {\n      const descendantsExpr = options.get(\"descendants\");\n      const descendantsValue = evaluator.evaluate(descendantsExpr);\n\n      if (typeof descendantsValue !== \"boolean\") {\n        throw createValueHasWrongTypeError(descendantsExpr, descendantsValue, `@${name} options.descendants must be a boolean`);\n      }\n\n      descendants = descendantsValue;\n    }\n\n    if (options.has(\"emitDistinctChangesOnly\")) {\n      const emitDistinctChangesOnlyExpr = options.get(\"emitDistinctChangesOnly\");\n      const emitDistinctChangesOnlyValue = evaluator.evaluate(emitDistinctChangesOnlyExpr);\n\n      if (typeof emitDistinctChangesOnlyValue !== \"boolean\") {\n        throw createValueHasWrongTypeError(emitDistinctChangesOnlyExpr, emitDistinctChangesOnlyValue, `@${name} options.emitDistinctChangesOnly must be a boolean`);\n      }\n\n      emitDistinctChangesOnly = emitDistinctChangesOnlyValue;\n    }\n\n    if (options.has(\"static\")) {\n      const staticValue = evaluator.evaluate(options.get(\"static\"));\n\n      if (typeof staticValue !== \"boolean\") {\n        throw createValueHasWrongTypeError(node, staticValue, `@${name} options.static must be a boolean`);\n      }\n\n      isStatic = staticValue;\n    }\n  } else if (args.length > 2) {\n    throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, node, `@${name} has too many arguments`);\n  }\n\n  return {\n    propertyName,\n    predicate,\n    first,\n    descendants,\n    read,\n    static: isStatic,\n    emitDistinctChangesOnly\n  };\n}\n\nfunction extractQueriesFromDecorator(queryData, reflector, evaluator, isCore) {\n  const content = [],\n        view = [];\n\n  if (!ts17.isObjectLiteralExpression(queryData)) {\n    throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, queryData, \"Decorator queries metadata must be an object literal\");\n  }\n\n  reflectObjectLiteral(queryData).forEach((queryExpr, propertyName) => {\n    queryExpr = unwrapExpression(queryExpr);\n\n    if (!ts17.isNewExpression(queryExpr)) {\n      throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, queryData, \"Decorator query metadata must be an instance of a query type\");\n    }\n\n    const queryType = ts17.isPropertyAccessExpression(queryExpr.expression) ? queryExpr.expression.name : queryExpr.expression;\n\n    if (!ts17.isIdentifier(queryType)) {\n      throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, queryData, \"Decorator query metadata must be an instance of a query type\");\n    }\n\n    const type = reflector.getImportOfIdentifier(queryType);\n\n    if (type === null || !isCore && type.from !== \"@angular/core\" || !QUERY_TYPES.has(type.name)) {\n      throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, queryData, \"Decorator query metadata must be an instance of a query type\");\n    }\n\n    const query = extractQueryMetadata(queryExpr, type.name, queryExpr.arguments || [], propertyName, reflector, evaluator);\n\n    if (type.name.startsWith(\"Content\")) {\n      content.push(query);\n    } else {\n      view.push(query);\n    }\n  });\n  return {\n    content,\n    view\n  };\n}\n\nfunction isStringArrayOrDie(value, name, node) {\n  if (!Array.isArray(value)) {\n    return false;\n  }\n\n  for (let i = 0; i < value.length; i++) {\n    if (typeof value[i] !== \"string\") {\n      throw createValueHasWrongTypeError(node, value[i], `Failed to resolve ${name} at position ${i} to a string`);\n    }\n  }\n\n  return true;\n}\n\nfunction parseFieldArrayValue(directive, field, evaluator) {\n  if (!directive.has(field)) {\n    return null;\n  }\n\n  const expression = directive.get(field);\n  const value = evaluator.evaluate(expression);\n\n  if (!isStringArrayOrDie(value, field, expression)) {\n    throw createValueHasWrongTypeError(expression, value, `Failed to resolve @Directive.${field} to a string array`);\n  }\n\n  return value;\n}\n\nfunction parseFieldToPropertyMapping(directive, field, evaluator) {\n  const metaValues = parseFieldArrayValue(directive, field, evaluator);\n\n  if (!metaValues) {\n    return EMPTY_OBJECT;\n  }\n\n  return metaValues.reduce((results, value) => {\n    const [field2, property] = value.split(\":\", 2).map(str => str.trim());\n    results[field2] = property || field2;\n    return results;\n  }, {});\n}\n\nfunction parseDecoratedFields(fields, evaluator, mapValueResolver) {\n  return fields.reduce((results, field) => {\n    const fieldName = field.member.name;\n    field.decorators.forEach(decorator => {\n      if (decorator.args == null || decorator.args.length === 0) {\n        results[fieldName] = fieldName;\n      } else if (decorator.args.length === 1) {\n        const property = evaluator.evaluate(decorator.args[0]);\n\n        if (typeof property !== \"string\") {\n          throw createValueHasWrongTypeError(Decorator.nodeForError(decorator), property, `@${decorator.name} decorator argument must resolve to a string`);\n        }\n\n        results[fieldName] = mapValueResolver(property, fieldName);\n      } else {\n        throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(decorator), `@${decorator.name} can have at most one argument, got ${decorator.args.length} argument(s)`);\n      }\n    });\n    return results;\n  }, {});\n}\n\nfunction resolveInput(publicName, internalName) {\n  return [publicName, internalName];\n}\n\nfunction resolveOutput(publicName, internalName) {\n  return publicName;\n}\n\nfunction queriesFromFields(fields, reflector, evaluator) {\n  return fields.map(({\n    member,\n    decorators\n  }) => {\n    const decorator = decorators[0];\n    const node = member.node || Decorator.nodeForError(decorator);\n\n    if (member.decorators.some(v => v.name === \"Input\")) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_COLLISION, node, \"Cannot combine @Input decorators with query decorators\");\n    }\n\n    if (decorators.length !== 1) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_COLLISION, node, \"Cannot have multiple query decorators on the same class member\");\n    } else if (!isPropertyTypeMember(member)) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_UNEXPECTED, node, \"Query decorator must go on a property-type member\");\n    }\n\n    return extractQueryMetadata(node, decorator.name, decorator.args || [], member.name, reflector, evaluator);\n  });\n}\n\nfunction isPropertyTypeMember(member) {\n  return member.kind === ClassMemberKind.Getter || member.kind === ClassMemberKind.Setter || member.kind === ClassMemberKind.Property;\n}\n\nfunction evaluateHostExpressionBindings(hostExpr, evaluator) {\n  const hostMetaMap = evaluator.evaluate(hostExpr);\n\n  if (!(hostMetaMap instanceof Map)) {\n    throw createValueHasWrongTypeError(hostExpr, hostMetaMap, `Decorator host metadata must be an object`);\n  }\n\n  const hostMetadata = {};\n  hostMetaMap.forEach((value, key) => {\n    if (value instanceof EnumValue) {\n      value = value.resolved;\n    }\n\n    if (typeof key !== \"string\") {\n      throw createValueHasWrongTypeError(hostExpr, key, `Decorator host metadata must be a string -> string object, but found unparseable key`);\n    }\n\n    if (typeof value == \"string\") {\n      hostMetadata[key] = value;\n    } else if (value instanceof DynamicValue) {\n      hostMetadata[key] = new WrappedNodeExpr3(value.node);\n    } else {\n      throw createValueHasWrongTypeError(hostExpr, value, `Decorator host metadata must be a string -> string object, but found unparseable value`);\n    }\n  });\n  const bindings = parseHostBindings(hostMetadata);\n  const errors = verifyHostBindings(bindings, createSourceSpan(hostExpr));\n\n  if (errors.length > 0) {\n    throw new FatalDiagnosticError(ErrorCode.HOST_BINDING_PARSE_ERROR, hostExpr, errors.map(error => error.msg).join(\"\\n\"));\n  }\n\n  return bindings;\n}\n\nfunction extractHostBindings(members, evaluator, coreModule, metadata) {\n  let bindings;\n\n  if (metadata && metadata.has(\"host\")) {\n    bindings = evaluateHostExpressionBindings(metadata.get(\"host\"), evaluator);\n  } else {\n    bindings = parseHostBindings({});\n  }\n\n  filterToMembersWithDecorator(members, \"HostBinding\", coreModule).forEach(({\n    member,\n    decorators\n  }) => {\n    decorators.forEach(decorator => {\n      let hostPropertyName = member.name;\n\n      if (decorator.args !== null && decorator.args.length > 0) {\n        if (decorator.args.length !== 1) {\n          throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(decorator), `@HostBinding can have at most one argument, got ${decorator.args.length} argument(s)`);\n        }\n\n        const resolved = evaluator.evaluate(decorator.args[0]);\n\n        if (typeof resolved !== \"string\") {\n          throw createValueHasWrongTypeError(Decorator.nodeForError(decorator), resolved, `@HostBinding's argument must be a string`);\n        }\n\n        hostPropertyName = resolved;\n      }\n\n      bindings.properties[hostPropertyName] = getSafePropertyAccessString(\"this\", member.name);\n    });\n  });\n  filterToMembersWithDecorator(members, \"HostListener\", coreModule).forEach(({\n    member,\n    decorators\n  }) => {\n    decorators.forEach(decorator => {\n      let eventName = member.name;\n      let args = [];\n\n      if (decorator.args !== null && decorator.args.length > 0) {\n        if (decorator.args.length > 2) {\n          throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, decorator.args[2], `@HostListener can have at most two arguments`);\n        }\n\n        const resolved = evaluator.evaluate(decorator.args[0]);\n\n        if (typeof resolved !== \"string\") {\n          throw createValueHasWrongTypeError(decorator.args[0], resolved, `@HostListener's event name argument must be a string`);\n        }\n\n        eventName = resolved;\n\n        if (decorator.args.length === 2) {\n          const expression = decorator.args[1];\n          const resolvedArgs = evaluator.evaluate(decorator.args[1]);\n\n          if (!isStringArrayOrDie(resolvedArgs, \"@HostListener.args\", expression)) {\n            throw createValueHasWrongTypeError(decorator.args[1], resolvedArgs, `@HostListener's second argument must be a string array`);\n          }\n\n          args = resolvedArgs;\n        }\n      }\n\n      bindings.listeners[eventName] = `${member.name}(${args.join(\",\")})`;\n    });\n  });\n  return bindings;\n}\n\nvar QUERY_TYPES = new Set([\"ContentChild\", \"ContentChildren\", \"ViewChild\", \"ViewChildren\"]); // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/src/ng_module.mjs\n\nimport { compileClassMetadata as compileClassMetadata2, compileDeclareClassMetadata as compileDeclareClassMetadata2, compileDeclareInjectorFromMetadata, compileDeclareNgModuleFromMetadata, compileInjector, compileNgModule, CUSTOM_ELEMENTS_SCHEMA, ExternalExpr as ExternalExpr4, FactoryTarget as FactoryTarget2, InvokeFunctionExpr, LiteralArrayExpr as LiteralArrayExpr2, NO_ERRORS_SCHEMA, R3Identifiers, WrappedNodeExpr as WrappedNodeExpr4 } from \"@angular/compiler\";\nimport ts18 from \"typescript\";\nvar NgModuleSymbol = class extends SemanticSymbol {\n  constructor() {\n    super(...arguments);\n    this.remotelyScopedComponents = [];\n  }\n\n  isPublicApiAffected(previousSymbol) {\n    if (!(previousSymbol instanceof NgModuleSymbol)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  isEmitAffected(previousSymbol) {\n    if (!(previousSymbol instanceof NgModuleSymbol)) {\n      return true;\n    }\n\n    if (previousSymbol.remotelyScopedComponents.length !== this.remotelyScopedComponents.length) {\n      return true;\n    }\n\n    for (const currEntry of this.remotelyScopedComponents) {\n      const prevEntry = previousSymbol.remotelyScopedComponents.find(prevEntry2 => {\n        return isSymbolEqual(prevEntry2.component, currEntry.component);\n      });\n\n      if (prevEntry === void 0) {\n        return true;\n      }\n\n      if (!isArrayEqual(currEntry.usedDirectives, prevEntry.usedDirectives, isReferenceEqual)) {\n        return true;\n      }\n\n      if (!isArrayEqual(currEntry.usedPipes, prevEntry.usedPipes, isReferenceEqual)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  isTypeCheckApiAffected(previousSymbol) {\n    if (!(previousSymbol instanceof NgModuleSymbol)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  addRemotelyScopedComponent(component, usedDirectives, usedPipes) {\n    this.remotelyScopedComponents.push({\n      component,\n      usedDirectives,\n      usedPipes\n    });\n  }\n\n};\nvar NgModuleDecoratorHandler = class {\n  constructor(reflector, evaluator, metaReader, metaRegistry, scopeRegistry, referencesRegistry, isCore, refEmitter, factoryTracker, annotateForClosureCompiler, injectableRegistry, perf) {\n    this.reflector = reflector;\n    this.evaluator = evaluator;\n    this.metaReader = metaReader;\n    this.metaRegistry = metaRegistry;\n    this.scopeRegistry = scopeRegistry;\n    this.referencesRegistry = referencesRegistry;\n    this.isCore = isCore;\n    this.refEmitter = refEmitter;\n    this.factoryTracker = factoryTracker;\n    this.annotateForClosureCompiler = annotateForClosureCompiler;\n    this.injectableRegistry = injectableRegistry;\n    this.perf = perf;\n    this.precedence = HandlerPrecedence.PRIMARY;\n    this.name = NgModuleDecoratorHandler.name;\n  }\n\n  detect(node, decorators) {\n    if (!decorators) {\n      return void 0;\n    }\n\n    const decorator = findAngularDecorator(decorators, \"NgModule\", this.isCore);\n\n    if (decorator !== void 0) {\n      return {\n        trigger: decorator.node,\n        decorator,\n        metadata: decorator\n      };\n    } else {\n      return void 0;\n    }\n  }\n\n  analyze(node, decorator) {\n    this.perf.eventCount(PerfEvent.AnalyzeNgModule);\n    const name = node.name.text;\n\n    if (decorator.args === null || decorator.args.length > 1) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(decorator), `Incorrect number of arguments to @NgModule decorator`);\n    }\n\n    const meta = decorator.args.length === 1 ? unwrapExpression(decorator.args[0]) : ts18.createObjectLiteral([]);\n\n    if (!ts18.isObjectLiteralExpression(meta)) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, \"@NgModule argument must be an object literal\");\n    }\n\n    const ngModule = reflectObjectLiteral(meta);\n\n    if (ngModule.has(\"jit\")) {\n      return {};\n    }\n\n    const moduleResolvers = combineResolvers([ref => this._extractModuleFromModuleWithProvidersFn(ref.node), forwardRefResolver]);\n    const diagnostics = [];\n    let declarationRefs = [];\n    let rawDeclarations = null;\n\n    if (ngModule.has(\"declarations\")) {\n      rawDeclarations = ngModule.get(\"declarations\");\n      const declarationMeta = this.evaluator.evaluate(rawDeclarations, forwardRefResolver);\n      declarationRefs = this.resolveTypeList(rawDeclarations, declarationMeta, name, \"declarations\");\n\n      for (const ref of declarationRefs) {\n        if (ref.node.getSourceFile().isDeclarationFile) {\n          const errorNode = ref.getOriginForDiagnostics(rawDeclarations);\n          diagnostics.push(makeDiagnostic(ErrorCode.NGMODULE_INVALID_DECLARATION, errorNode, `Cannot declare '${ref.node.name.text}' in an NgModule as it's not a part of the current compilation.`, [makeRelatedInformation(ref.node.name, `'${ref.node.name.text}' is declared here.`)]));\n        }\n      }\n    }\n\n    if (diagnostics.length > 0) {\n      return {\n        diagnostics\n      };\n    }\n\n    let importRefs = [];\n\n    if (ngModule.has(\"imports\")) {\n      const rawImports = ngModule.get(\"imports\");\n      const importsMeta = this.evaluator.evaluate(rawImports, moduleResolvers);\n      importRefs = this.resolveTypeList(rawImports, importsMeta, name, \"imports\");\n    }\n\n    let exportRefs = [];\n\n    if (ngModule.has(\"exports\")) {\n      const rawExports = ngModule.get(\"exports\");\n      const exportsMeta = this.evaluator.evaluate(rawExports, moduleResolvers);\n      exportRefs = this.resolveTypeList(rawExports, exportsMeta, name, \"exports\");\n      this.referencesRegistry.add(node, ...exportRefs);\n    }\n\n    let bootstrapRefs = [];\n\n    if (ngModule.has(\"bootstrap\")) {\n      const expr = ngModule.get(\"bootstrap\");\n      const bootstrapMeta = this.evaluator.evaluate(expr, forwardRefResolver);\n      bootstrapRefs = this.resolveTypeList(expr, bootstrapMeta, name, \"bootstrap\");\n    }\n\n    const schemas = [];\n\n    if (ngModule.has(\"schemas\")) {\n      const rawExpr = ngModule.get(\"schemas\");\n      const result = this.evaluator.evaluate(rawExpr);\n\n      if (!Array.isArray(result)) {\n        throw createValueHasWrongTypeError(rawExpr, result, `NgModule.schemas must be an array`);\n      }\n\n      for (const schemaRef of result) {\n        if (!(schemaRef instanceof Reference)) {\n          throw createValueHasWrongTypeError(rawExpr, result, \"NgModule.schemas must be an array of schemas\");\n        }\n\n        const id2 = schemaRef.getIdentityIn(schemaRef.node.getSourceFile());\n\n        if (id2 === null || schemaRef.ownedByModuleGuess !== \"@angular/core\") {\n          throw createValueHasWrongTypeError(rawExpr, result, \"NgModule.schemas must be an array of schemas\");\n        }\n\n        switch (id2.text) {\n          case \"CUSTOM_ELEMENTS_SCHEMA\":\n            schemas.push(CUSTOM_ELEMENTS_SCHEMA);\n            break;\n\n          case \"NO_ERRORS_SCHEMA\":\n            schemas.push(NO_ERRORS_SCHEMA);\n            break;\n\n          default:\n            throw createValueHasWrongTypeError(rawExpr, schemaRef, `'${schemaRef.debugName}' is not a valid NgModule schema`);\n        }\n      }\n    }\n\n    const id = ngModule.has(\"id\") ? new WrappedNodeExpr4(ngModule.get(\"id\")) : null;\n    const valueContext = node.getSourceFile();\n    let typeContext = valueContext;\n    const typeNode = this.reflector.getDtsDeclaration(node);\n\n    if (typeNode !== null) {\n      typeContext = typeNode.getSourceFile();\n    }\n\n    const bootstrap = bootstrapRefs.map(bootstrap2 => this._toR3Reference(bootstrap2, valueContext, typeContext));\n    const declarations = declarationRefs.map(decl => this._toR3Reference(decl, valueContext, typeContext));\n    const imports = importRefs.map(imp => this._toR3Reference(imp, valueContext, typeContext));\n    const exports = exportRefs.map(exp => this._toR3Reference(exp, valueContext, typeContext));\n\n    const isForwardReference = ref => isExpressionForwardReference(ref.value, node.name, valueContext);\n\n    const containsForwardDecls = bootstrap.some(isForwardReference) || declarations.some(isForwardReference) || imports.some(isForwardReference) || exports.some(isForwardReference);\n    const type = wrapTypeReference(this.reflector, node);\n    const internalType = new WrappedNodeExpr4(this.reflector.getInternalNameOfClass(node));\n    const adjacentType = new WrappedNodeExpr4(this.reflector.getAdjacentNameOfClass(node));\n    const ngModuleMetadata = {\n      type,\n      internalType,\n      adjacentType,\n      bootstrap,\n      declarations,\n      exports,\n      imports,\n      containsForwardDecls,\n      id,\n      emitInline: false,\n      schemas: []\n    };\n    const rawProviders = ngModule.has(\"providers\") ? ngModule.get(\"providers\") : null;\n    const wrapperProviders = rawProviders !== null ? new WrappedNodeExpr4(this.annotateForClosureCompiler ? wrapFunctionExpressionsInParens(rawProviders) : rawProviders) : null;\n    const injectorImports = [];\n\n    if (ngModule.has(\"imports\")) {\n      injectorImports.push(new WrappedNodeExpr4(ngModule.get(\"imports\")));\n    }\n\n    const injectorMetadata = {\n      name,\n      type,\n      internalType,\n      providers: wrapperProviders,\n      imports: injectorImports\n    };\n    const factoryMetadata = {\n      name,\n      type,\n      internalType,\n      typeArgumentCount: 0,\n      deps: getValidConstructorDependencies(node, this.reflector, this.isCore),\n      target: FactoryTarget2.NgModule\n    };\n    return {\n      analysis: {\n        id,\n        schemas,\n        mod: ngModuleMetadata,\n        inj: injectorMetadata,\n        fac: factoryMetadata,\n        declarations: declarationRefs,\n        rawDeclarations,\n        imports: importRefs,\n        exports: exportRefs,\n        providers: rawProviders,\n        providersRequiringFactory: rawProviders ? resolveProvidersRequiringFactory(rawProviders, this.reflector, this.evaluator) : null,\n        classMetadata: extractClassMetadata(node, this.reflector, this.isCore, this.annotateForClosureCompiler),\n        factorySymbolName: node.name.text\n      }\n    };\n  }\n\n  symbol(node) {\n    return new NgModuleSymbol(node);\n  }\n\n  register(node, analysis) {\n    this.metaRegistry.registerNgModuleMetadata({\n      ref: new Reference(node),\n      schemas: analysis.schemas,\n      declarations: analysis.declarations,\n      imports: analysis.imports,\n      exports: analysis.exports,\n      rawDeclarations: analysis.rawDeclarations\n    });\n\n    if (this.factoryTracker !== null) {\n      this.factoryTracker.track(node.getSourceFile(), {\n        name: analysis.factorySymbolName,\n        hasId: analysis.id !== null\n      });\n    }\n\n    this.injectableRegistry.registerInjectable(node);\n  }\n\n  resolve(node, analysis) {\n    const scope = this.scopeRegistry.getScopeOfModule(node);\n    const diagnostics = [];\n    const scopeDiagnostics = this.scopeRegistry.getDiagnosticsOfModule(node);\n\n    if (scopeDiagnostics !== null) {\n      diagnostics.push(...scopeDiagnostics);\n    }\n\n    if (analysis.providersRequiringFactory !== null) {\n      const providerDiagnostics = getProviderDiagnostics(analysis.providersRequiringFactory, analysis.providers, this.injectableRegistry);\n      diagnostics.push(...providerDiagnostics);\n    }\n\n    const data = {\n      injectorImports: []\n    };\n\n    if (scope !== null && !scope.compilation.isPoisoned) {\n      const context = getSourceFile(node);\n\n      for (const exportRef of analysis.exports) {\n        if (isNgModule(exportRef.node, scope.compilation)) {\n          data.injectorImports.push(this.refEmitter.emit(exportRef, context).expression);\n        }\n      }\n\n      for (const decl of analysis.declarations) {\n        const metadata = this.metaReader.getDirectiveMetadata(decl);\n\n        if (metadata !== null && metadata.selector === null) {\n          throw new FatalDiagnosticError(ErrorCode.DIRECTIVE_MISSING_SELECTOR, decl.node, `Directive ${decl.node.name.text} has no selector, please add it!`);\n        }\n      }\n    }\n\n    if (diagnostics.length > 0) {\n      return {\n        diagnostics\n      };\n    }\n\n    if (scope === null || scope.compilation.isPoisoned || scope.exported.isPoisoned || scope.reexports === null) {\n      return {\n        data\n      };\n    } else {\n      return {\n        data,\n        reexports: scope.reexports\n      };\n    }\n  }\n\n  compileFull(node, {\n    inj,\n    mod,\n    fac,\n    classMetadata,\n    declarations\n  }, {\n    injectorImports\n  }) {\n    const factoryFn = compileNgFactoryDefField(fac);\n    const ngInjectorDef = compileInjector(this.mergeInjectorImports(inj, injectorImports));\n    const ngModuleDef = compileNgModule(mod);\n    const statements = ngModuleDef.statements;\n    const metadata = classMetadata !== null ? compileClassMetadata2(classMetadata) : null;\n    this.insertMetadataStatement(statements, metadata);\n    this.appendRemoteScopingStatements(statements, node, declarations);\n    return this.compileNgModule(factoryFn, ngInjectorDef, ngModuleDef);\n  }\n\n  compilePartial(node, {\n    inj,\n    fac,\n    mod,\n    classMetadata\n  }, {\n    injectorImports\n  }) {\n    const factoryFn = compileDeclareFactory(fac);\n    const injectorDef = compileDeclareInjectorFromMetadata(this.mergeInjectorImports(inj, injectorImports));\n    const ngModuleDef = compileDeclareNgModuleFromMetadata(mod);\n    const metadata = classMetadata !== null ? compileDeclareClassMetadata2(classMetadata) : null;\n    this.insertMetadataStatement(ngModuleDef.statements, metadata);\n    return this.compileNgModule(factoryFn, injectorDef, ngModuleDef);\n  }\n\n  mergeInjectorImports(inj, injectorImports) {\n    return __spreadProps(__spreadValues({}, inj), {\n      imports: [...inj.imports, ...injectorImports]\n    });\n  }\n\n  insertMetadataStatement(ngModuleStatements, metadata) {\n    if (metadata !== null) {\n      ngModuleStatements.unshift(metadata.toStmt());\n    }\n  }\n\n  appendRemoteScopingStatements(ngModuleStatements, node, declarations) {\n    const context = getSourceFile(node);\n\n    for (const decl of declarations) {\n      const remoteScope = this.scopeRegistry.getRemoteScope(decl.node);\n\n      if (remoteScope !== null) {\n        const directives = remoteScope.directives.map(directive => this.refEmitter.emit(directive, context).expression);\n        const pipes = remoteScope.pipes.map(pipe => this.refEmitter.emit(pipe, context).expression);\n        const directiveArray = new LiteralArrayExpr2(directives);\n        const pipesArray = new LiteralArrayExpr2(pipes);\n        const declExpr = this.refEmitter.emit(decl, context).expression;\n        const setComponentScope = new ExternalExpr4(R3Identifiers.setComponentScope);\n        const callExpr = new InvokeFunctionExpr(setComponentScope, [declExpr, directiveArray, pipesArray]);\n        ngModuleStatements.push(callExpr.toStmt());\n      }\n    }\n  }\n\n  compileNgModule(factoryFn, injectorDef, ngModuleDef) {\n    const res = [factoryFn, {\n      name: \"\\u0275mod\",\n      initializer: ngModuleDef.expression,\n      statements: ngModuleDef.statements,\n      type: ngModuleDef.type\n    }, {\n      name: \"\\u0275inj\",\n      initializer: injectorDef.expression,\n      statements: injectorDef.statements,\n      type: injectorDef.type\n    }];\n    return res;\n  }\n\n  _toR3Reference(valueRef, valueContext, typeContext) {\n    if (valueRef.hasOwningModuleGuess) {\n      return toR3Reference(valueRef, valueRef, valueContext, valueContext, this.refEmitter);\n    } else {\n      let typeRef = valueRef;\n      let typeNode = this.reflector.getDtsDeclaration(typeRef.node);\n\n      if (typeNode !== null && isNamedClassDeclaration(typeNode)) {\n        typeRef = new Reference(typeNode);\n      }\n\n      return toR3Reference(valueRef, typeRef, valueContext, typeContext, this.refEmitter);\n    }\n  }\n\n  _extractModuleFromModuleWithProvidersFn(node) {\n    const type = node.type || null;\n    return type && (this._reflectModuleFromTypeParam(type, node) || this._reflectModuleFromLiteralType(type));\n  }\n\n  _reflectModuleFromTypeParam(type, node) {\n    if (!ts18.isTypeReferenceNode(type)) {\n      return null;\n    }\n\n    const typeName = type && (ts18.isIdentifier(type.typeName) && type.typeName || ts18.isQualifiedName(type.typeName) && type.typeName.right) || null;\n\n    if (typeName === null) {\n      return null;\n    }\n\n    const id = this.reflector.getImportOfIdentifier(typeName);\n\n    if (id === null || id.name !== \"ModuleWithProviders\") {\n      return null;\n    }\n\n    if (!this.isCore && id.from !== \"@angular/core\") {\n      return null;\n    }\n\n    if (type.typeArguments === void 0 || type.typeArguments.length !== 1) {\n      const parent = ts18.isMethodDeclaration(node) && ts18.isClassDeclaration(node.parent) ? node.parent : null;\n      const symbolName = (parent && parent.name ? parent.name.getText() + \".\" : \"\") + (node.name ? node.name.getText() : \"anonymous\");\n      throw new FatalDiagnosticError(ErrorCode.NGMODULE_MODULE_WITH_PROVIDERS_MISSING_GENERIC, type, `${symbolName} returns a ModuleWithProviders type without a generic type argument. Please add a generic type argument to the ModuleWithProviders type. If this occurrence is in library code you don't control, please contact the library authors.`);\n    }\n\n    const arg = type.typeArguments[0];\n    return typeNodeToValueExpr(arg);\n  }\n\n  _reflectModuleFromLiteralType(type) {\n    if (!ts18.isIntersectionTypeNode(type)) {\n      return null;\n    }\n\n    for (const t of type.types) {\n      if (ts18.isTypeLiteralNode(t)) {\n        for (const m of t.members) {\n          const ngModuleType = ts18.isPropertySignature(m) && ts18.isIdentifier(m.name) && m.name.text === \"ngModule\" && m.type || null;\n          const ngModuleExpression = ngModuleType && typeNodeToValueExpr(ngModuleType);\n\n          if (ngModuleExpression) {\n            return ngModuleExpression;\n          }\n        }\n      }\n    }\n\n    return null;\n  }\n\n  isClassDeclarationReference(ref) {\n    return this.reflector.isClass(ref.node);\n  }\n\n  resolveTypeList(expr, resolvedList, className, arrayName) {\n    const refList = [];\n\n    if (!Array.isArray(resolvedList)) {\n      throw createValueHasWrongTypeError(expr, resolvedList, `Expected array when reading the NgModule.${arrayName} of ${className}`);\n    }\n\n    resolvedList.forEach((entry, idx) => {\n      if (entry instanceof Map && entry.has(\"ngModule\")) {\n        entry = entry.get(\"ngModule\");\n      }\n\n      if (Array.isArray(entry)) {\n        refList.push(...this.resolveTypeList(expr, entry, className, arrayName));\n      } else if (entry instanceof Reference) {\n        if (!this.isClassDeclarationReference(entry)) {\n          throw createValueHasWrongTypeError(entry.node, entry, `Value at position ${idx} in the NgModule.${arrayName} of ${className} is not a class`);\n        }\n\n        refList.push(entry);\n      } else {\n        throw createValueHasWrongTypeError(expr, entry, `Value at position ${idx} in the NgModule.${arrayName} of ${className} is not a reference`);\n      }\n    });\n    return refList;\n  }\n\n};\n\nfunction isNgModule(node, compilation) {\n  return !compilation.directives.some(directive => directive.ref.node === node) && !compilation.pipes.some(pipe => pipe.ref.node === node);\n} // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/src/component.mjs\n\n\nvar EMPTY_MAP = new Map();\nvar EMPTY_ARRAY = [];\nvar ComponentSymbol = class extends DirectiveSymbol {\n  constructor() {\n    super(...arguments);\n    this.usedDirectives = [];\n    this.usedPipes = [];\n    this.isRemotelyScoped = false;\n  }\n\n  isEmitAffected(previousSymbol, publicApiAffected) {\n    if (!(previousSymbol instanceof ComponentSymbol)) {\n      return true;\n    }\n\n    const isSymbolUnaffected = (current, previous) => isReferenceEqual(current, previous) && !publicApiAffected.has(current.symbol);\n\n    return this.isRemotelyScoped !== previousSymbol.isRemotelyScoped || !isArrayEqual(this.usedDirectives, previousSymbol.usedDirectives, isSymbolUnaffected) || !isArrayEqual(this.usedPipes, previousSymbol.usedPipes, isSymbolUnaffected);\n  }\n\n  isTypeCheckBlockAffected(previousSymbol, typeCheckApiAffected) {\n    if (!(previousSymbol instanceof ComponentSymbol)) {\n      return true;\n    }\n\n    const isInheritanceChainAffected = symbol => {\n      let currentSymbol = symbol;\n\n      while (currentSymbol instanceof DirectiveSymbol) {\n        if (typeCheckApiAffected.has(currentSymbol)) {\n          return true;\n        }\n\n        currentSymbol = currentSymbol.baseClass;\n      }\n\n      return false;\n    };\n\n    const isDirectiveUnaffected = (current, previous) => isReferenceEqual(current, previous) && !isInheritanceChainAffected(current.symbol);\n\n    const isPipeUnaffected = (current, previous) => isReferenceEqual(current, previous) && !typeCheckApiAffected.has(current.symbol);\n\n    return !isArrayEqual(this.usedDirectives, previousSymbol.usedDirectives, isDirectiveUnaffected) || !isArrayEqual(this.usedPipes, previousSymbol.usedPipes, isPipeUnaffected);\n  }\n\n};\nvar ComponentDecoratorHandler = class {\n  constructor(reflector, evaluator, metaRegistry, metaReader, scopeReader, scopeRegistry, typeCheckScopeRegistry, resourceRegistry, isCore, resourceLoader, rootDirs, defaultPreserveWhitespaces, i18nUseExternalIds, enableI18nLegacyMessageIdFormat, usePoisonedData, i18nNormalizeLineEndingsInICUs, moduleResolver, cycleAnalyzer, cycleHandlingStrategy, refEmitter, depTracker, injectableRegistry, semanticDepGraphUpdater, annotateForClosureCompiler, perf) {\n    this.reflector = reflector;\n    this.evaluator = evaluator;\n    this.metaRegistry = metaRegistry;\n    this.metaReader = metaReader;\n    this.scopeReader = scopeReader;\n    this.scopeRegistry = scopeRegistry;\n    this.typeCheckScopeRegistry = typeCheckScopeRegistry;\n    this.resourceRegistry = resourceRegistry;\n    this.isCore = isCore;\n    this.resourceLoader = resourceLoader;\n    this.rootDirs = rootDirs;\n    this.defaultPreserveWhitespaces = defaultPreserveWhitespaces;\n    this.i18nUseExternalIds = i18nUseExternalIds;\n    this.enableI18nLegacyMessageIdFormat = enableI18nLegacyMessageIdFormat;\n    this.usePoisonedData = usePoisonedData;\n    this.i18nNormalizeLineEndingsInICUs = i18nNormalizeLineEndingsInICUs;\n    this.moduleResolver = moduleResolver;\n    this.cycleAnalyzer = cycleAnalyzer;\n    this.cycleHandlingStrategy = cycleHandlingStrategy;\n    this.refEmitter = refEmitter;\n    this.depTracker = depTracker;\n    this.injectableRegistry = injectableRegistry;\n    this.semanticDepGraphUpdater = semanticDepGraphUpdater;\n    this.annotateForClosureCompiler = annotateForClosureCompiler;\n    this.perf = perf;\n    this.literalCache = new Map();\n    this.elementSchemaRegistry = new DomElementSchemaRegistry();\n    this.preanalyzeTemplateCache = new Map();\n    this.preanalyzeStylesCache = new Map();\n    this.precedence = HandlerPrecedence.PRIMARY;\n    this.name = ComponentDecoratorHandler.name;\n  }\n\n  detect(node, decorators) {\n    if (!decorators) {\n      return void 0;\n    }\n\n    const decorator = findAngularDecorator(decorators, \"Component\", this.isCore);\n\n    if (decorator !== void 0) {\n      return {\n        trigger: decorator.node,\n        decorator,\n        metadata: decorator\n      };\n    } else {\n      return void 0;\n    }\n  }\n\n  preanalyze(node, decorator) {\n    if (!this.resourceLoader.canPreload) {\n      return void 0;\n    }\n\n    const meta = this._resolveLiteral(decorator);\n\n    const component = reflectObjectLiteral(meta);\n    const containingFile = node.getSourceFile().fileName;\n\n    const resolveStyleUrl = styleUrl => {\n      try {\n        const resourceUrl = this.resourceLoader.resolve(styleUrl, containingFile);\n        return this.resourceLoader.preload(resourceUrl, {\n          type: \"style\",\n          containingFile\n        });\n      } catch {\n        return void 0;\n      }\n    };\n\n    const templateAndTemplateStyleResources = this._preloadAndParseTemplate(node, decorator, component, containingFile).then(template => {\n      if (template === null) {\n        return void 0;\n      }\n\n      return Promise.all(template.styleUrls.map(styleUrl => resolveStyleUrl(styleUrl))).then(() => void 0);\n    });\n\n    const componentStyleUrls = this._extractComponentStyleUrls(component);\n\n    let inlineStyles;\n\n    if (component.has(\"styles\")) {\n      const litStyles = parseFieldArrayValue(component, \"styles\", this.evaluator);\n\n      if (litStyles === null) {\n        this.preanalyzeStylesCache.set(node, null);\n      } else {\n        inlineStyles = Promise.all(litStyles.map(style => this.resourceLoader.preprocessInline(style, {\n          type: \"style\",\n          containingFile\n        }))).then(styles => {\n          this.preanalyzeStylesCache.set(node, styles);\n        });\n      }\n    } else {\n      this.preanalyzeStylesCache.set(node, null);\n    }\n\n    return Promise.all([templateAndTemplateStyleResources, inlineStyles, ...componentStyleUrls.map(styleUrl => resolveStyleUrl(styleUrl.url))]).then(() => void 0);\n  }\n\n  analyze(node, decorator, flags = HandlerFlags.NONE) {\n    var _a, _b;\n\n    this.perf.eventCount(PerfEvent.AnalyzeComponent);\n    const containingFile = node.getSourceFile().fileName;\n    this.literalCache.delete(decorator);\n    let diagnostics;\n    let isPoisoned = false;\n    const directiveResult = extractDirectiveMetadata(node, decorator, this.reflector, this.evaluator, this.isCore, flags, this.annotateForClosureCompiler, this.elementSchemaRegistry.getDefaultComponentElementName());\n\n    if (directiveResult === void 0) {\n      return {};\n    }\n\n    const {\n      decorator: component,\n      metadata,\n      inputs,\n      outputs\n    } = directiveResult;\n    const encapsulation = (_a = this._resolveEnumValue(component, \"encapsulation\", \"ViewEncapsulation\")) != null ? _a : ViewEncapsulation.Emulated;\n\n    const changeDetection = this._resolveEnumValue(component, \"changeDetection\", \"ChangeDetectionStrategy\");\n\n    let animations = null;\n\n    if (component.has(\"animations\")) {\n      animations = new WrappedNodeExpr5(component.get(\"animations\"));\n    }\n\n    const relativeContextFilePath = this.rootDirs.reduce((previous, rootDir) => {\n      const candidate = relative(absoluteFrom(rootDir), absoluteFrom(containingFile));\n\n      if (previous === void 0 || candidate.length < previous.length) {\n        return candidate;\n      } else {\n        return previous;\n      }\n    }, void 0);\n    let viewProvidersRequiringFactory = null;\n    let providersRequiringFactory = null;\n    let wrappedViewProviders = null;\n\n    if (component.has(\"viewProviders\")) {\n      const viewProviders = component.get(\"viewProviders\");\n      viewProvidersRequiringFactory = resolveProvidersRequiringFactory(viewProviders, this.reflector, this.evaluator);\n      wrappedViewProviders = new WrappedNodeExpr5(this.annotateForClosureCompiler ? wrapFunctionExpressionsInParens(viewProviders) : viewProviders);\n    }\n\n    if (component.has(\"providers\")) {\n      providersRequiringFactory = resolveProvidersRequiringFactory(component.get(\"providers\"), this.reflector, this.evaluator);\n    }\n\n    let template;\n\n    if (this.preanalyzeTemplateCache.has(node)) {\n      const preanalyzed = this.preanalyzeTemplateCache.get(node);\n      this.preanalyzeTemplateCache.delete(node);\n      template = preanalyzed;\n    } else {\n      const templateDecl = this.parseTemplateDeclaration(decorator, component, containingFile);\n      template = this.extractTemplate(node, templateDecl);\n    }\n\n    const templateResource = template.declaration.isInline ? {\n      path: null,\n      expression: component.get(\"template\")\n    } : {\n      path: absoluteFrom(template.declaration.resolvedTemplateUrl),\n      expression: template.sourceMapping.node\n    };\n    let styles = [];\n\n    const styleResources = this._extractStyleResources(component, containingFile);\n\n    const styleUrls = [...this._extractComponentStyleUrls(component), ...this._extractTemplateStyleUrls(template)];\n\n    for (const styleUrl of styleUrls) {\n      try {\n        const resourceUrl = this.resourceLoader.resolve(styleUrl.url, containingFile);\n        const resourceStr = this.resourceLoader.load(resourceUrl);\n        styles.push(resourceStr);\n\n        if (this.depTracker !== null) {\n          this.depTracker.addResourceDependency(node.getSourceFile(), absoluteFrom(resourceUrl));\n        }\n      } catch {\n        if (diagnostics === void 0) {\n          diagnostics = [];\n        }\n\n        const resourceType = styleUrl.source === 2 ? 2 : 1;\n        diagnostics.push(this.makeResourceNotFoundError(styleUrl.url, styleUrl.nodeForError, resourceType).toDiagnostic());\n      }\n    }\n\n    if (encapsulation === ViewEncapsulation.ShadowDom && metadata.selector !== null) {\n      const selectorError = checkCustomElementSelectorForErrors(metadata.selector);\n\n      if (selectorError !== null) {\n        if (diagnostics === void 0) {\n          diagnostics = [];\n        }\n\n        diagnostics.push(makeDiagnostic(ErrorCode.COMPONENT_INVALID_SHADOW_DOM_SELECTOR, component.get(\"selector\"), selectorError));\n      }\n    }\n\n    let inlineStyles = null;\n\n    if (this.preanalyzeStylesCache.has(node)) {\n      inlineStyles = this.preanalyzeStylesCache.get(node);\n      this.preanalyzeStylesCache.delete(node);\n\n      if (inlineStyles !== null) {\n        styles.push(...inlineStyles);\n      }\n    } else {\n      if (this.resourceLoader.canPreprocess) {\n        throw new Error(\"Inline resource processing requires asynchronous preanalyze.\");\n      }\n\n      if (component.has(\"styles\")) {\n        const litStyles = parseFieldArrayValue(component, \"styles\", this.evaluator);\n\n        if (litStyles !== null) {\n          inlineStyles = [...litStyles];\n          styles.push(...litStyles);\n        }\n      }\n    }\n\n    if (template.styles.length > 0) {\n      styles.push(...template.styles);\n    }\n\n    const output = {\n      analysis: {\n        baseClass: readBaseClass(node, this.reflector, this.evaluator),\n        inputs,\n        outputs,\n        meta: __spreadProps(__spreadValues({}, metadata), {\n          template: {\n            nodes: template.nodes,\n            ngContentSelectors: template.ngContentSelectors\n          },\n          encapsulation,\n          interpolation: (_b = template.interpolationConfig) != null ? _b : DEFAULT_INTERPOLATION_CONFIG,\n          styles,\n          animations,\n          viewProviders: wrappedViewProviders,\n          i18nUseExternalIds: this.i18nUseExternalIds,\n          relativeContextFilePath\n        }),\n        typeCheckMeta: extractDirectiveTypeCheckMeta(node, inputs, this.reflector),\n        classMetadata: extractClassMetadata(node, this.reflector, this.isCore, this.annotateForClosureCompiler, dec => this._transformDecoratorToInlineResources(dec, component, styles, template)),\n        template,\n        providersRequiringFactory,\n        viewProvidersRequiringFactory,\n        inlineStyles,\n        styleUrls,\n        resources: {\n          styles: styleResources,\n          template: templateResource\n        },\n        isPoisoned\n      },\n      diagnostics\n    };\n\n    if (changeDetection !== null) {\n      output.analysis.meta.changeDetection = changeDetection;\n    }\n\n    return output;\n  }\n\n  symbol(node, analysis) {\n    const typeParameters = extractSemanticTypeParameters(node);\n    return new ComponentSymbol(node, analysis.meta.selector, analysis.inputs, analysis.outputs, analysis.meta.exportAs, analysis.typeCheckMeta, typeParameters);\n  }\n\n  register(node, analysis) {\n    const ref = new Reference(node);\n    this.metaRegistry.registerDirectiveMetadata(__spreadProps(__spreadValues({\n      type: MetaType.Directive,\n      ref,\n      name: node.name.text,\n      selector: analysis.meta.selector,\n      exportAs: analysis.meta.exportAs,\n      inputs: analysis.inputs,\n      outputs: analysis.outputs,\n      queries: analysis.meta.queries.map(query => query.propertyName),\n      isComponent: true,\n      baseClass: analysis.baseClass\n    }, analysis.typeCheckMeta), {\n      isPoisoned: analysis.isPoisoned,\n      isStructural: false\n    }));\n    this.resourceRegistry.registerResources(analysis.resources, node);\n    this.injectableRegistry.registerInjectable(node);\n  }\n\n  index(context, node, analysis) {\n    if (analysis.isPoisoned && !this.usePoisonedData) {\n      return null;\n    }\n\n    const scope = this.scopeReader.getScopeForComponent(node);\n    const selector = analysis.meta.selector;\n    const matcher = new SelectorMatcher();\n\n    if (scope !== null) {\n      if ((scope.compilation.isPoisoned || scope.exported.isPoisoned) && !this.usePoisonedData) {\n        return null;\n      }\n\n      for (const directive of scope.compilation.directives) {\n        if (directive.selector !== null) {\n          matcher.addSelectables(CssSelector.parse(directive.selector), directive);\n        }\n      }\n    }\n\n    const binder = new R3TargetBinder(matcher);\n    const boundTemplate = binder.bind({\n      template: analysis.template.diagNodes\n    });\n    context.addComponent({\n      declaration: node,\n      selector,\n      boundTemplate,\n      templateMeta: {\n        isInline: analysis.template.declaration.isInline,\n        file: analysis.template.file\n      }\n    });\n  }\n\n  typeCheck(ctx, node, meta) {\n    if (this.typeCheckScopeRegistry === null || !ts19.isClassDeclaration(node)) {\n      return;\n    }\n\n    if (meta.isPoisoned && !this.usePoisonedData) {\n      return;\n    }\n\n    const scope = this.typeCheckScopeRegistry.getTypeCheckScope(node);\n\n    if (scope.isPoisoned && !this.usePoisonedData) {\n      return;\n    }\n\n    const binder = new R3TargetBinder(scope.matcher);\n    ctx.addTemplate(new Reference(node), binder, meta.template.diagNodes, scope.pipes, scope.schemas, meta.template.sourceMapping, meta.template.file, meta.template.errors);\n  }\n\n  extendedTemplateCheck(component, extendedTemplateChecker) {\n    return extendedTemplateChecker.getDiagnosticsForComponent(component);\n  }\n\n  resolve(node, analysis, symbol) {\n    if (this.semanticDepGraphUpdater !== null && analysis.baseClass instanceof Reference) {\n      symbol.baseClass = this.semanticDepGraphUpdater.getSymbol(analysis.baseClass.node);\n    }\n\n    if (analysis.isPoisoned && !this.usePoisonedData) {\n      return {};\n    }\n\n    const context = node.getSourceFile();\n    const scope = this.scopeReader.getScopeForComponent(node);\n    let metadata = analysis.meta;\n    const data = {\n      directives: EMPTY_ARRAY,\n      pipes: EMPTY_MAP,\n      declarationListEmitMode: 0\n    };\n\n    if (scope !== null && (!scope.compilation.isPoisoned || this.usePoisonedData)) {\n      const matcher = new SelectorMatcher();\n\n      for (const dir of scope.compilation.directives) {\n        if (dir.selector !== null) {\n          matcher.addSelectables(CssSelector.parse(dir.selector), dir);\n        }\n      }\n\n      const pipes = new Map();\n\n      for (const pipe of scope.compilation.pipes) {\n        pipes.set(pipe.name, pipe.ref);\n      }\n\n      const binder = new R3TargetBinder(matcher);\n      const bound = binder.bind({\n        template: metadata.template.nodes\n      });\n      const usedDirectives = bound.getUsedDirectives().map(directive => {\n        const type = this.refEmitter.emit(directive.ref, context);\n        return {\n          ref: directive.ref,\n          type: type.expression,\n          importedFile: type.importedFile,\n          selector: directive.selector,\n          inputs: directive.inputs.propertyNames,\n          outputs: directive.outputs.propertyNames,\n          exportAs: directive.exportAs,\n          isComponent: directive.isComponent\n        };\n      });\n      const usedPipes = [];\n\n      for (const pipeName of bound.getUsedPipes()) {\n        if (!pipes.has(pipeName)) {\n          continue;\n        }\n\n        const pipe = pipes.get(pipeName);\n        const type = this.refEmitter.emit(pipe, context);\n        usedPipes.push({\n          ref: pipe,\n          pipeName,\n          expression: type.expression,\n          importedFile: type.importedFile\n        });\n      }\n\n      if (this.semanticDepGraphUpdater !== null) {\n        symbol.usedDirectives = usedDirectives.map(dir => this.semanticDepGraphUpdater.getSemanticReference(dir.ref.node, dir.type));\n        symbol.usedPipes = usedPipes.map(pipe => this.semanticDepGraphUpdater.getSemanticReference(pipe.ref.node, pipe.expression));\n      }\n\n      const cyclesFromDirectives = new Map();\n\n      for (const usedDirective of usedDirectives) {\n        const cycle = this._checkForCyclicImport(usedDirective.importedFile, usedDirective.type, context);\n\n        if (cycle !== null) {\n          cyclesFromDirectives.set(usedDirective, cycle);\n        }\n      }\n\n      const cyclesFromPipes = new Map();\n\n      for (const usedPipe of usedPipes) {\n        const cycle = this._checkForCyclicImport(usedPipe.importedFile, usedPipe.expression, context);\n\n        if (cycle !== null) {\n          cyclesFromPipes.set(usedPipe, cycle);\n        }\n      }\n\n      const cycleDetected = cyclesFromDirectives.size !== 0 || cyclesFromPipes.size !== 0;\n\n      if (!cycleDetected) {\n        for (const {\n          type,\n          importedFile\n        } of usedDirectives) {\n          this._recordSyntheticImport(importedFile, type, context);\n        }\n\n        for (const {\n          expression,\n          importedFile\n        } of usedPipes) {\n          this._recordSyntheticImport(importedFile, expression, context);\n        }\n\n        const wrapDirectivesAndPipesInClosure = usedDirectives.some(dir => isExpressionForwardReference(dir.type, node.name, context)) || usedPipes.some(pipe => isExpressionForwardReference(pipe.expression, node.name, context));\n        data.directives = usedDirectives;\n        data.pipes = new Map(usedPipes.map(pipe => [pipe.pipeName, pipe.expression]));\n        data.declarationListEmitMode = wrapDirectivesAndPipesInClosure ? 1 : 0;\n      } else {\n        if (this.cycleHandlingStrategy === 0) {\n          this.scopeRegistry.setComponentRemoteScope(node, usedDirectives.map(dir => dir.ref), usedPipes.map(pipe => pipe.ref));\n          symbol.isRemotelyScoped = true;\n\n          if (this.semanticDepGraphUpdater !== null) {\n            const moduleSymbol = this.semanticDepGraphUpdater.getSymbol(scope.ngModule);\n\n            if (!(moduleSymbol instanceof NgModuleSymbol)) {\n              throw new Error(`AssertionError: Expected ${scope.ngModule.name} to be an NgModuleSymbol.`);\n            }\n\n            moduleSymbol.addRemotelyScopedComponent(symbol, symbol.usedDirectives, symbol.usedPipes);\n          }\n        } else {\n          const relatedMessages = [];\n\n          for (const [dir, cycle] of cyclesFromDirectives) {\n            relatedMessages.push(makeCyclicImportInfo(dir.ref, dir.isComponent ? \"component\" : \"directive\", cycle));\n          }\n\n          for (const [pipe, cycle] of cyclesFromPipes) {\n            relatedMessages.push(makeCyclicImportInfo(pipe.ref, \"pipe\", cycle));\n          }\n\n          throw new FatalDiagnosticError(ErrorCode.IMPORT_CYCLE_DETECTED, node, \"One or more import cycles would need to be created to compile this component, which is not supported by the current compiler configuration.\", relatedMessages);\n        }\n      }\n    }\n\n    const diagnostics = [];\n\n    if (analysis.providersRequiringFactory !== null && analysis.meta.providers instanceof WrappedNodeExpr5) {\n      const providerDiagnostics = getProviderDiagnostics(analysis.providersRequiringFactory, analysis.meta.providers.node, this.injectableRegistry);\n      diagnostics.push(...providerDiagnostics);\n    }\n\n    if (analysis.viewProvidersRequiringFactory !== null && analysis.meta.viewProviders instanceof WrappedNodeExpr5) {\n      const viewProviderDiagnostics = getProviderDiagnostics(analysis.viewProvidersRequiringFactory, analysis.meta.viewProviders.node, this.injectableRegistry);\n      diagnostics.push(...viewProviderDiagnostics);\n    }\n\n    const directiveDiagnostics = getDirectiveDiagnostics(node, this.metaReader, this.evaluator, this.reflector, this.scopeRegistry, \"Component\");\n\n    if (directiveDiagnostics !== null) {\n      diagnostics.push(...directiveDiagnostics);\n    }\n\n    if (diagnostics.length > 0) {\n      return {\n        diagnostics\n      };\n    }\n\n    return {\n      data\n    };\n  }\n\n  xi18n(ctx, node, analysis) {\n    var _a;\n\n    ctx.updateFromTemplate(analysis.template.content, analysis.template.declaration.resolvedTemplateUrl, (_a = analysis.template.interpolationConfig) != null ? _a : DEFAULT_INTERPOLATION_CONFIG);\n  }\n\n  updateResources(node, analysis) {\n    const containingFile = node.getSourceFile().fileName;\n    const templateDecl = analysis.template.declaration;\n\n    if (!templateDecl.isInline) {\n      analysis.template = this.extractTemplate(node, templateDecl);\n    }\n\n    let styles = [];\n\n    if (analysis.styleUrls !== null) {\n      for (const styleUrl of analysis.styleUrls) {\n        try {\n          const resolvedStyleUrl = this.resourceLoader.resolve(styleUrl.url, containingFile);\n          const styleText = this.resourceLoader.load(resolvedStyleUrl);\n          styles.push(styleText);\n        } catch (e) {}\n      }\n    }\n\n    if (analysis.inlineStyles !== null) {\n      for (const styleText of analysis.inlineStyles) {\n        styles.push(styleText);\n      }\n    }\n\n    for (const styleText of analysis.template.styles) {\n      styles.push(styleText);\n    }\n\n    analysis.meta.styles = styles;\n  }\n\n  compileFull(node, analysis, resolution, pool) {\n    if (analysis.template.errors !== null && analysis.template.errors.length > 0) {\n      return [];\n    }\n\n    const meta = __spreadValues(__spreadValues({}, analysis.meta), resolution);\n\n    const fac = compileNgFactoryDefField(toFactoryMetadata(meta, FactoryTarget3.Component));\n    const def = compileComponentFromMetadata(meta, pool, makeBindingParser2());\n    const classMetadata = analysis.classMetadata !== null ? compileClassMetadata3(analysis.classMetadata).toStmt() : null;\n    return compileResults(fac, def, classMetadata, \"\\u0275cmp\");\n  }\n\n  compilePartial(node, analysis, resolution) {\n    if (analysis.template.errors !== null && analysis.template.errors.length > 0) {\n      return [];\n    }\n\n    const templateInfo = {\n      content: analysis.template.content,\n      sourceUrl: analysis.template.declaration.resolvedTemplateUrl,\n      isInline: analysis.template.declaration.isInline,\n      inlineTemplateLiteralExpression: analysis.template.sourceMapping.type === \"direct\" ? new WrappedNodeExpr5(analysis.template.sourceMapping.node) : null\n    };\n\n    const meta = __spreadValues(__spreadValues({}, analysis.meta), resolution);\n\n    const fac = compileDeclareFactory(toFactoryMetadata(meta, FactoryTarget3.Component));\n    const def = compileDeclareComponentFromMetadata(meta, analysis.template, templateInfo);\n    const classMetadata = analysis.classMetadata !== null ? compileDeclareClassMetadata3(analysis.classMetadata).toStmt() : null;\n    return compileResults(fac, def, classMetadata, \"\\u0275cmp\");\n  }\n\n  _transformDecoratorToInlineResources(dec, component, styles, template) {\n    if (dec.name !== \"Component\") {\n      return dec;\n    }\n\n    if (!component.has(\"templateUrl\") && !component.has(\"styleUrls\")) {\n      return dec;\n    }\n\n    const metadata = new Map(component);\n\n    if (metadata.has(\"templateUrl\")) {\n      metadata.delete(\"templateUrl\");\n      metadata.set(\"template\", ts19.createStringLiteral(template.content));\n    }\n\n    if (metadata.has(\"styleUrls\")) {\n      metadata.delete(\"styleUrls\");\n      metadata.set(\"styles\", ts19.createArrayLiteral(styles.map(s => ts19.createStringLiteral(s))));\n    }\n\n    const newMetadataFields = [];\n\n    for (const [name, value] of metadata.entries()) {\n      newMetadataFields.push(ts19.createPropertyAssignment(name, value));\n    }\n\n    return __spreadProps(__spreadValues({}, dec), {\n      args: [ts19.createObjectLiteral(newMetadataFields)]\n    });\n  }\n\n  _resolveLiteral(decorator) {\n    if (this.literalCache.has(decorator)) {\n      return this.literalCache.get(decorator);\n    }\n\n    if (decorator.args === null || decorator.args.length !== 1) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(decorator), `Incorrect number of arguments to @Component decorator`);\n    }\n\n    const meta = unwrapExpression(decorator.args[0]);\n\n    if (!ts19.isObjectLiteralExpression(meta)) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, `Decorator argument must be literal.`);\n    }\n\n    this.literalCache.set(decorator, meta);\n    return meta;\n  }\n\n  _resolveEnumValue(component, field, enumSymbolName) {\n    let resolved = null;\n\n    if (component.has(field)) {\n      const expr = component.get(field);\n      const value = this.evaluator.evaluate(expr);\n\n      if (value instanceof EnumValue && isAngularCoreReference(value.enumRef, enumSymbolName)) {\n        resolved = value.resolved;\n      } else {\n        throw createValueHasWrongTypeError(expr, value, `${field} must be a member of ${enumSymbolName} enum from @angular/core`);\n      }\n    }\n\n    return resolved;\n  }\n\n  _extractComponentStyleUrls(component) {\n    if (!component.has(\"styleUrls\")) {\n      return [];\n    }\n\n    return this._extractStyleUrlsFromExpression(component.get(\"styleUrls\"));\n  }\n\n  _extractStyleUrlsFromExpression(styleUrlsExpr) {\n    const styleUrls = [];\n\n    if (ts19.isArrayLiteralExpression(styleUrlsExpr)) {\n      for (const styleUrlExpr of styleUrlsExpr.elements) {\n        if (ts19.isSpreadElement(styleUrlExpr)) {\n          styleUrls.push(...this._extractStyleUrlsFromExpression(styleUrlExpr.expression));\n        } else {\n          const styleUrl = this.evaluator.evaluate(styleUrlExpr);\n\n          if (typeof styleUrl !== \"string\") {\n            throw createValueHasWrongTypeError(styleUrlExpr, styleUrl, \"styleUrl must be a string\");\n          }\n\n          styleUrls.push({\n            url: styleUrl,\n            source: 2,\n            nodeForError: styleUrlExpr\n          });\n        }\n      }\n    } else {\n      const evaluatedStyleUrls = this.evaluator.evaluate(styleUrlsExpr);\n\n      if (!isStringArray(evaluatedStyleUrls)) {\n        throw createValueHasWrongTypeError(styleUrlsExpr, evaluatedStyleUrls, \"styleUrls must be an array of strings\");\n      }\n\n      for (const styleUrl of evaluatedStyleUrls) {\n        styleUrls.push({\n          url: styleUrl,\n          source: 2,\n          nodeForError: styleUrlsExpr\n        });\n      }\n    }\n\n    return styleUrls;\n  }\n\n  _extractStyleResources(component, containingFile) {\n    const styles = new Set();\n\n    function stringLiteralElements(array) {\n      return array.elements.filter(e => ts19.isStringLiteralLike(e));\n    }\n\n    const styleUrlsExpr = component.get(\"styleUrls\");\n\n    if (styleUrlsExpr !== void 0 && ts19.isArrayLiteralExpression(styleUrlsExpr)) {\n      for (const expression of stringLiteralElements(styleUrlsExpr)) {\n        try {\n          const resourceUrl = this.resourceLoader.resolve(expression.text, containingFile);\n          styles.add({\n            path: absoluteFrom(resourceUrl),\n            expression\n          });\n        } catch {}\n      }\n    }\n\n    const stylesExpr = component.get(\"styles\");\n\n    if (stylesExpr !== void 0 && ts19.isArrayLiteralExpression(stylesExpr)) {\n      for (const expression of stringLiteralElements(stylesExpr)) {\n        styles.add({\n          path: null,\n          expression\n        });\n      }\n    }\n\n    return styles;\n  }\n\n  _preloadAndParseTemplate(node, decorator, component, containingFile) {\n    if (component.has(\"templateUrl\")) {\n      const templateUrlExpr = component.get(\"templateUrl\");\n      const templateUrl = this.evaluator.evaluate(templateUrlExpr);\n\n      if (typeof templateUrl !== \"string\") {\n        throw createValueHasWrongTypeError(templateUrlExpr, templateUrl, \"templateUrl must be a string\");\n      }\n\n      try {\n        const resourceUrl = this.resourceLoader.resolve(templateUrl, containingFile);\n        const templatePromise = this.resourceLoader.preload(resourceUrl, {\n          type: \"template\",\n          containingFile\n        });\n\n        if (templatePromise !== void 0) {\n          return templatePromise.then(() => {\n            const templateDecl = this.parseTemplateDeclaration(decorator, component, containingFile);\n            const template = this.extractTemplate(node, templateDecl);\n            this.preanalyzeTemplateCache.set(node, template);\n            return template;\n          });\n        } else {\n          return Promise.resolve(null);\n        }\n      } catch (e) {\n        throw this.makeResourceNotFoundError(templateUrl, templateUrlExpr, 0);\n      }\n    } else {\n      const templateDecl = this.parseTemplateDeclaration(decorator, component, containingFile);\n      const template = this.extractTemplate(node, templateDecl);\n      this.preanalyzeTemplateCache.set(node, template);\n      return Promise.resolve(template);\n    }\n  }\n\n  extractTemplate(node, template) {\n    if (template.isInline) {\n      let sourceStr;\n      let sourceParseRange = null;\n      let templateContent;\n      let sourceMapping;\n      let escapedString = false;\n      let sourceMapUrl;\n\n      if (ts19.isStringLiteral(template.expression) || ts19.isNoSubstitutionTemplateLiteral(template.expression)) {\n        sourceParseRange = getTemplateRange(template.expression);\n        sourceStr = template.expression.getSourceFile().text;\n        templateContent = template.expression.text;\n        escapedString = true;\n        sourceMapping = {\n          type: \"direct\",\n          node: template.expression\n        };\n        sourceMapUrl = template.resolvedTemplateUrl;\n      } else {\n        const resolvedTemplate = this.evaluator.evaluate(template.expression);\n\n        if (typeof resolvedTemplate !== \"string\") {\n          throw createValueHasWrongTypeError(template.expression, resolvedTemplate, \"template must be a string\");\n        }\n\n        sourceStr = resolvedTemplate;\n        templateContent = resolvedTemplate;\n        sourceMapping = {\n          type: \"indirect\",\n          node: template.expression,\n          componentClass: node,\n          template: templateContent\n        };\n        sourceMapUrl = null;\n      }\n\n      return __spreadProps(__spreadValues({}, this._parseTemplate(template, sourceStr, sourceParseRange, escapedString, sourceMapUrl)), {\n        content: templateContent,\n        sourceMapping,\n        declaration: template\n      });\n    } else {\n      const templateContent = this.resourceLoader.load(template.resolvedTemplateUrl);\n\n      if (this.depTracker !== null) {\n        this.depTracker.addResourceDependency(node.getSourceFile(), absoluteFrom(template.resolvedTemplateUrl));\n      }\n\n      return __spreadProps(__spreadValues({}, this._parseTemplate(template, templateContent, null, false, template.resolvedTemplateUrl)), {\n        content: templateContent,\n        sourceMapping: {\n          type: \"external\",\n          componentClass: node,\n          node: template.templateUrlExpression,\n          template: templateContent,\n          templateUrl: template.resolvedTemplateUrl\n        },\n        declaration: template\n      });\n    }\n  }\n\n  _parseTemplate(template, sourceStr, sourceParseRange, escapedString, sourceMapUrl) {\n    const i18nNormalizeLineEndingsInICUs = escapedString || this.i18nNormalizeLineEndingsInICUs;\n    const parsedTemplate = parseTemplate(sourceStr, sourceMapUrl != null ? sourceMapUrl : \"\", {\n      preserveWhitespaces: template.preserveWhitespaces,\n      interpolationConfig: template.interpolationConfig,\n      range: sourceParseRange != null ? sourceParseRange : void 0,\n      escapedString,\n      enableI18nLegacyMessageIdFormat: this.enableI18nLegacyMessageIdFormat,\n      i18nNormalizeLineEndingsInICUs,\n      alwaysAttemptHtmlToR3AstConversion: this.usePoisonedData\n    });\n    const {\n      nodes: diagNodes\n    } = parseTemplate(sourceStr, sourceMapUrl != null ? sourceMapUrl : \"\", {\n      preserveWhitespaces: true,\n      preserveLineEndings: true,\n      interpolationConfig: template.interpolationConfig,\n      range: sourceParseRange != null ? sourceParseRange : void 0,\n      escapedString,\n      enableI18nLegacyMessageIdFormat: this.enableI18nLegacyMessageIdFormat,\n      i18nNormalizeLineEndingsInICUs,\n      leadingTriviaChars: [],\n      alwaysAttemptHtmlToR3AstConversion: this.usePoisonedData\n    });\n    return __spreadProps(__spreadValues({}, parsedTemplate), {\n      diagNodes,\n      file: new ParseSourceFile2(sourceStr, sourceMapUrl != null ? sourceMapUrl : \"\")\n    });\n  }\n\n  parseTemplateDeclaration(decorator, component, containingFile) {\n    let preserveWhitespaces = this.defaultPreserveWhitespaces;\n\n    if (component.has(\"preserveWhitespaces\")) {\n      const expr = component.get(\"preserveWhitespaces\");\n      const value = this.evaluator.evaluate(expr);\n\n      if (typeof value !== \"boolean\") {\n        throw createValueHasWrongTypeError(expr, value, \"preserveWhitespaces must be a boolean\");\n      }\n\n      preserveWhitespaces = value;\n    }\n\n    let interpolationConfig = DEFAULT_INTERPOLATION_CONFIG;\n\n    if (component.has(\"interpolation\")) {\n      const expr = component.get(\"interpolation\");\n      const value = this.evaluator.evaluate(expr);\n\n      if (!Array.isArray(value) || value.length !== 2 || !value.every(element => typeof element === \"string\")) {\n        throw createValueHasWrongTypeError(expr, value, \"interpolation must be an array with 2 elements of string type\");\n      }\n\n      interpolationConfig = InterpolationConfig.fromArray(value);\n    }\n\n    if (component.has(\"templateUrl\")) {\n      const templateUrlExpr = component.get(\"templateUrl\");\n      const templateUrl = this.evaluator.evaluate(templateUrlExpr);\n\n      if (typeof templateUrl !== \"string\") {\n        throw createValueHasWrongTypeError(templateUrlExpr, templateUrl, \"templateUrl must be a string\");\n      }\n\n      try {\n        const resourceUrl = this.resourceLoader.resolve(templateUrl, containingFile);\n        return {\n          isInline: false,\n          interpolationConfig,\n          preserveWhitespaces,\n          templateUrl,\n          templateUrlExpression: templateUrlExpr,\n          resolvedTemplateUrl: resourceUrl\n        };\n      } catch (e) {\n        throw this.makeResourceNotFoundError(templateUrl, templateUrlExpr, 0);\n      }\n    } else if (component.has(\"template\")) {\n      return {\n        isInline: true,\n        interpolationConfig,\n        preserveWhitespaces,\n        expression: component.get(\"template\"),\n        templateUrl: containingFile,\n        resolvedTemplateUrl: containingFile\n      };\n    } else {\n      throw new FatalDiagnosticError(ErrorCode.COMPONENT_MISSING_TEMPLATE, Decorator.nodeForError(decorator), \"component is missing a template\");\n    }\n  }\n\n  _resolveImportedFile(importedFile, expr, origin) {\n    if (importedFile !== \"unknown\") {\n      return importedFile;\n    }\n\n    if (!(expr instanceof ExternalExpr5)) {\n      return null;\n    }\n\n    return this.moduleResolver.resolveModule(expr.value.moduleName, origin.fileName);\n  }\n\n  _checkForCyclicImport(importedFile, expr, origin) {\n    const imported = this._resolveImportedFile(importedFile, expr, origin);\n\n    if (imported === null) {\n      return null;\n    }\n\n    return this.cycleAnalyzer.wouldCreateCycle(origin, imported);\n  }\n\n  _recordSyntheticImport(importedFile, expr, origin) {\n    const imported = this._resolveImportedFile(importedFile, expr, origin);\n\n    if (imported === null) {\n      return;\n    }\n\n    this.cycleAnalyzer.recordSyntheticImport(origin, imported);\n  }\n\n  makeResourceNotFoundError(file, nodeForError, resourceType) {\n    let errorText;\n\n    switch (resourceType) {\n      case 0:\n        errorText = `Could not find template file '${file}'.`;\n        break;\n\n      case 1:\n        errorText = `Could not find stylesheet file '${file}' linked from the template.`;\n        break;\n\n      case 2:\n        errorText = `Could not find stylesheet file '${file}'.`;\n        break;\n    }\n\n    return new FatalDiagnosticError(ErrorCode.COMPONENT_RESOURCE_NOT_FOUND, nodeForError, errorText);\n  }\n\n  _extractTemplateStyleUrls(template) {\n    if (template.styleUrls === null) {\n      return [];\n    }\n\n    const nodeForError = getTemplateDeclarationNodeForError(template.declaration);\n    return template.styleUrls.map(url => ({\n      url,\n      source: 1,\n      nodeForError\n    }));\n  }\n\n};\n\nfunction getTemplateRange(templateExpr) {\n  const startPos = templateExpr.getStart() + 1;\n  const {\n    line,\n    character\n  } = ts19.getLineAndCharacterOfPosition(templateExpr.getSourceFile(), startPos);\n  return {\n    startPos,\n    startLine: line,\n    startCol: character,\n    endPos: templateExpr.getEnd() - 1\n  };\n}\n\nfunction isStringArray(resolvedValue) {\n  return Array.isArray(resolvedValue) && resolvedValue.every(elem => typeof elem === \"string\");\n}\n\nfunction getTemplateDeclarationNodeForError(declaration) {\n  switch (declaration.isInline) {\n    case true:\n      return declaration.expression;\n\n    case false:\n      return declaration.templateUrlExpression;\n  }\n}\n\nfunction makeCyclicImportInfo(ref, type, cycle) {\n  const name = ref.debugName || \"(unknown)\";\n  const path = cycle.getPath().map(sf => sf.fileName).join(\" -> \");\n  const message = `The ${type} '${name}' is used in the template but importing it would create a cycle: `;\n  return makeRelatedInformation(ref.node, message + path);\n}\n\nfunction checkCustomElementSelectorForErrors(selector) {\n  if (selector.includes(\".\") || selector.includes(\"[\") && selector.includes(\"]\")) {\n    return null;\n  }\n\n  if (!/^[a-z]/.test(selector)) {\n    return \"Selector of a ShadowDom-encapsulated component must start with a lower case letter.\";\n  }\n\n  if (/[A-Z]/.test(selector)) {\n    return \"Selector of a ShadowDom-encapsulated component must all be in lower case.\";\n  }\n\n  if (!selector.includes(\"-\")) {\n    return \"Selector of a component that uses ViewEncapsulation.ShadowDom must contain a hyphen.\";\n  }\n\n  return null;\n} // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/src/injectable.mjs\n\n\nimport { compileClassMetadata as compileClassMetadata4, compileDeclareClassMetadata as compileDeclareClassMetadata4, compileDeclareInjectableFromMetadata, compileInjectable, createMayBeForwardRefExpression as createMayBeForwardRefExpression2, FactoryTarget as FactoryTarget4, LiteralExpr as LiteralExpr3, WrappedNodeExpr as WrappedNodeExpr6 } from \"@angular/compiler\";\nimport ts20 from \"typescript\";\nvar InjectableDecoratorHandler = class {\n  constructor(reflector, isCore, strictCtorDeps, injectableRegistry, perf, errorOnDuplicateProv = true) {\n    this.reflector = reflector;\n    this.isCore = isCore;\n    this.strictCtorDeps = strictCtorDeps;\n    this.injectableRegistry = injectableRegistry;\n    this.perf = perf;\n    this.errorOnDuplicateProv = errorOnDuplicateProv;\n    this.precedence = HandlerPrecedence.SHARED;\n    this.name = InjectableDecoratorHandler.name;\n  }\n\n  detect(node, decorators) {\n    if (!decorators) {\n      return void 0;\n    }\n\n    const decorator = findAngularDecorator(decorators, \"Injectable\", this.isCore);\n\n    if (decorator !== void 0) {\n      return {\n        trigger: decorator.node,\n        decorator,\n        metadata: decorator\n      };\n    } else {\n      return void 0;\n    }\n  }\n\n  analyze(node, decorator) {\n    this.perf.eventCount(PerfEvent.AnalyzeInjectable);\n    const meta = extractInjectableMetadata(node, decorator, this.reflector);\n    const decorators = this.reflector.getDecoratorsOfDeclaration(node);\n    return {\n      analysis: {\n        meta,\n        ctorDeps: extractInjectableCtorDeps(node, meta, decorator, this.reflector, this.isCore, this.strictCtorDeps),\n        classMetadata: extractClassMetadata(node, this.reflector, this.isCore),\n        needsFactory: !decorators || decorators.every(current => !isAngularCore(current) || current.name === \"Injectable\")\n      }\n    };\n  }\n\n  symbol() {\n    return null;\n  }\n\n  register(node) {\n    this.injectableRegistry.registerInjectable(node);\n  }\n\n  compileFull(node, analysis) {\n    return this.compile(compileNgFactoryDefField, meta => compileInjectable(meta, false), compileClassMetadata4, node, analysis);\n  }\n\n  compilePartial(node, analysis) {\n    return this.compile(compileDeclareFactory, compileDeclareInjectableFromMetadata, compileDeclareClassMetadata4, node, analysis);\n  }\n\n  compile(compileFactoryFn, compileInjectableFn, compileClassMetadataFn, node, analysis) {\n    const results = [];\n\n    if (analysis.needsFactory) {\n      const meta = analysis.meta;\n      const factoryRes = compileFactoryFn(toFactoryMetadata(__spreadProps(__spreadValues({}, meta), {\n        deps: analysis.ctorDeps\n      }), FactoryTarget4.Injectable));\n\n      if (analysis.classMetadata !== null) {\n        factoryRes.statements.push(compileClassMetadataFn(analysis.classMetadata).toStmt());\n      }\n\n      results.push(factoryRes);\n    }\n\n    const ɵprov = this.reflector.getMembersOfClass(node).find(member => member.name === \"\\u0275prov\");\n\n    if (ɵprov !== void 0 && this.errorOnDuplicateProv) {\n      throw new FatalDiagnosticError(ErrorCode.INJECTABLE_DUPLICATE_PROV, ɵprov.nameNode || ɵprov.node || node, \"Injectables cannot contain a static \\u0275prov property, because the compiler is going to generate one.\");\n    }\n\n    if (ɵprov === void 0) {\n      const res = compileInjectableFn(analysis.meta);\n      results.push({\n        name: \"\\u0275prov\",\n        initializer: res.expression,\n        statements: res.statements,\n        type: res.type\n      });\n    }\n\n    return results;\n  }\n\n};\n\nfunction extractInjectableMetadata(clazz, decorator, reflector) {\n  const name = clazz.name.text;\n  const type = wrapTypeReference(reflector, clazz);\n  const internalType = new WrappedNodeExpr6(reflector.getInternalNameOfClass(clazz));\n  const typeArgumentCount = reflector.getGenericArityOfClass(clazz) || 0;\n\n  if (decorator.args === null) {\n    throw new FatalDiagnosticError(ErrorCode.DECORATOR_NOT_CALLED, Decorator.nodeForError(decorator), \"@Injectable must be called\");\n  }\n\n  if (decorator.args.length === 0) {\n    return {\n      name,\n      type,\n      typeArgumentCount,\n      internalType,\n      providedIn: createMayBeForwardRefExpression2(new LiteralExpr3(null), 0)\n    };\n  } else if (decorator.args.length === 1) {\n    const metaNode = decorator.args[0];\n\n    if (!ts20.isObjectLiteralExpression(metaNode)) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, metaNode, `@Injectable argument must be an object literal`);\n    }\n\n    const meta = reflectObjectLiteral(metaNode);\n    const providedIn = meta.has(\"providedIn\") ? getProviderExpression(meta.get(\"providedIn\"), reflector) : createMayBeForwardRefExpression2(new LiteralExpr3(null), 0);\n    let deps = void 0;\n\n    if ((meta.has(\"useClass\") || meta.has(\"useFactory\")) && meta.has(\"deps\")) {\n      const depsExpr = meta.get(\"deps\");\n\n      if (!ts20.isArrayLiteralExpression(depsExpr)) {\n        throw new FatalDiagnosticError(ErrorCode.VALUE_NOT_LITERAL, depsExpr, `@Injectable deps metadata must be an inline array`);\n      }\n\n      deps = depsExpr.elements.map(dep => getDep(dep, reflector));\n    }\n\n    const result = {\n      name,\n      type,\n      typeArgumentCount,\n      internalType,\n      providedIn\n    };\n\n    if (meta.has(\"useValue\")) {\n      result.useValue = getProviderExpression(meta.get(\"useValue\"), reflector);\n    } else if (meta.has(\"useExisting\")) {\n      result.useExisting = getProviderExpression(meta.get(\"useExisting\"), reflector);\n    } else if (meta.has(\"useClass\")) {\n      result.useClass = getProviderExpression(meta.get(\"useClass\"), reflector);\n      result.deps = deps;\n    } else if (meta.has(\"useFactory\")) {\n      result.useFactory = new WrappedNodeExpr6(meta.get(\"useFactory\"));\n      result.deps = deps;\n    }\n\n    return result;\n  } else {\n    throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, decorator.args[2], \"Too many arguments to @Injectable\");\n  }\n}\n\nfunction getProviderExpression(expression, reflector) {\n  const forwardRefValue = tryUnwrapForwardRef(expression, reflector);\n  return createMayBeForwardRefExpression2(new WrappedNodeExpr6(forwardRefValue != null ? forwardRefValue : expression), forwardRefValue !== null ? 2 : 0);\n}\n\nfunction extractInjectableCtorDeps(clazz, meta, decorator, reflector, isCore, strictCtorDeps) {\n  if (decorator.args === null) {\n    throw new FatalDiagnosticError(ErrorCode.DECORATOR_NOT_CALLED, Decorator.nodeForError(decorator), \"@Injectable must be called\");\n  }\n\n  let ctorDeps = null;\n\n  if (decorator.args.length === 0) {\n    if (strictCtorDeps) {\n      ctorDeps = getValidConstructorDependencies(clazz, reflector, isCore);\n    } else {\n      ctorDeps = unwrapConstructorDependencies(getConstructorDependencies(clazz, reflector, isCore));\n    }\n\n    return ctorDeps;\n  } else if (decorator.args.length === 1) {\n    const rawCtorDeps = getConstructorDependencies(clazz, reflector, isCore);\n\n    if (strictCtorDeps && meta.useValue === void 0 && meta.useExisting === void 0 && meta.useClass === void 0 && meta.useFactory === void 0) {\n      ctorDeps = validateConstructorDependencies(clazz, rawCtorDeps);\n    } else {\n      ctorDeps = unwrapConstructorDependencies(rawCtorDeps);\n    }\n  }\n\n  return ctorDeps;\n}\n\nfunction getDep(dep, reflector) {\n  const meta = {\n    token: new WrappedNodeExpr6(dep),\n    attributeNameType: null,\n    host: false,\n    optional: false,\n    self: false,\n    skipSelf: false\n  };\n\n  function maybeUpdateDecorator(dec, reflector2, token) {\n    const source = reflector2.getImportOfIdentifier(dec);\n\n    if (source === null || source.from !== \"@angular/core\") {\n      return false;\n    }\n\n    switch (source.name) {\n      case \"Inject\":\n        if (token !== void 0) {\n          meta.token = new WrappedNodeExpr6(token);\n        }\n\n        break;\n\n      case \"Optional\":\n        meta.optional = true;\n        break;\n\n      case \"SkipSelf\":\n        meta.skipSelf = true;\n        break;\n\n      case \"Self\":\n        meta.self = true;\n        break;\n\n      default:\n        return false;\n    }\n\n    return true;\n  }\n\n  if (ts20.isArrayLiteralExpression(dep)) {\n    dep.elements.forEach(el => {\n      let isDecorator = false;\n\n      if (ts20.isIdentifier(el)) {\n        isDecorator = maybeUpdateDecorator(el, reflector);\n      } else if (ts20.isNewExpression(el) && ts20.isIdentifier(el.expression)) {\n        const token = el.arguments && el.arguments.length > 0 && el.arguments[0] || void 0;\n        isDecorator = maybeUpdateDecorator(el.expression, reflector, token);\n      }\n\n      if (!isDecorator) {\n        meta.token = new WrappedNodeExpr6(el);\n      }\n    });\n  }\n\n  return meta;\n} // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/src/pipe.mjs\n\n\nimport { compileClassMetadata as compileClassMetadata5, compileDeclareClassMetadata as compileDeclareClassMetadata5, compileDeclarePipeFromMetadata, compilePipeFromMetadata, FactoryTarget as FactoryTarget5, WrappedNodeExpr as WrappedNodeExpr7 } from \"@angular/compiler\";\nimport ts21 from \"typescript\";\nvar PipeSymbol = class extends SemanticSymbol {\n  constructor(decl, name) {\n    super(decl);\n    this.name = name;\n  }\n\n  isPublicApiAffected(previousSymbol) {\n    if (!(previousSymbol instanceof PipeSymbol)) {\n      return true;\n    }\n\n    return this.name !== previousSymbol.name;\n  }\n\n  isTypeCheckApiAffected(previousSymbol) {\n    return this.isPublicApiAffected(previousSymbol);\n  }\n\n};\nvar PipeDecoratorHandler = class {\n  constructor(reflector, evaluator, metaRegistry, scopeRegistry, injectableRegistry, isCore, perf) {\n    this.reflector = reflector;\n    this.evaluator = evaluator;\n    this.metaRegistry = metaRegistry;\n    this.scopeRegistry = scopeRegistry;\n    this.injectableRegistry = injectableRegistry;\n    this.isCore = isCore;\n    this.perf = perf;\n    this.precedence = HandlerPrecedence.PRIMARY;\n    this.name = PipeDecoratorHandler.name;\n  }\n\n  detect(node, decorators) {\n    if (!decorators) {\n      return void 0;\n    }\n\n    const decorator = findAngularDecorator(decorators, \"Pipe\", this.isCore);\n\n    if (decorator !== void 0) {\n      return {\n        trigger: decorator.node,\n        decorator,\n        metadata: decorator\n      };\n    } else {\n      return void 0;\n    }\n  }\n\n  analyze(clazz, decorator) {\n    this.perf.eventCount(PerfEvent.AnalyzePipe);\n    const name = clazz.name.text;\n    const type = wrapTypeReference(this.reflector, clazz);\n    const internalType = new WrappedNodeExpr7(this.reflector.getInternalNameOfClass(clazz));\n\n    if (decorator.args === null) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_NOT_CALLED, Decorator.nodeForError(decorator), `@Pipe must be called`);\n    }\n\n    if (decorator.args.length !== 1) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(decorator), \"@Pipe must have exactly one argument\");\n    }\n\n    const meta = unwrapExpression(decorator.args[0]);\n\n    if (!ts21.isObjectLiteralExpression(meta)) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, \"@Pipe must have a literal argument\");\n    }\n\n    const pipe = reflectObjectLiteral(meta);\n\n    if (!pipe.has(\"name\")) {\n      throw new FatalDiagnosticError(ErrorCode.PIPE_MISSING_NAME, meta, `@Pipe decorator is missing name field`);\n    }\n\n    const pipeNameExpr = pipe.get(\"name\");\n    const pipeName = this.evaluator.evaluate(pipeNameExpr);\n\n    if (typeof pipeName !== \"string\") {\n      throw createValueHasWrongTypeError(pipeNameExpr, pipeName, `@Pipe.name must be a string`);\n    }\n\n    let pure = true;\n\n    if (pipe.has(\"pure\")) {\n      const expr = pipe.get(\"pure\");\n      const pureValue = this.evaluator.evaluate(expr);\n\n      if (typeof pureValue !== \"boolean\") {\n        throw createValueHasWrongTypeError(expr, pureValue, `@Pipe.pure must be a boolean`);\n      }\n\n      pure = pureValue;\n    }\n\n    return {\n      analysis: {\n        meta: {\n          name,\n          type,\n          internalType,\n          typeArgumentCount: this.reflector.getGenericArityOfClass(clazz) || 0,\n          pipeName,\n          deps: getValidConstructorDependencies(clazz, this.reflector, this.isCore),\n          pure\n        },\n        classMetadata: extractClassMetadata(clazz, this.reflector, this.isCore),\n        pipeNameExpr\n      }\n    };\n  }\n\n  symbol(node, analysis) {\n    return new PipeSymbol(node, analysis.meta.name);\n  }\n\n  register(node, analysis) {\n    const ref = new Reference(node);\n    this.metaRegistry.registerPipeMetadata({\n      type: MetaType.Pipe,\n      ref,\n      name: analysis.meta.pipeName,\n      nameExpr: analysis.pipeNameExpr\n    });\n    this.injectableRegistry.registerInjectable(node);\n  }\n\n  resolve(node) {\n    const duplicateDeclData = this.scopeRegistry.getDuplicateDeclarations(node);\n\n    if (duplicateDeclData !== null) {\n      return {\n        diagnostics: [makeDuplicateDeclarationError(node, duplicateDeclData, \"Pipe\")]\n      };\n    }\n\n    return {};\n  }\n\n  compileFull(node, analysis) {\n    const fac = compileNgFactoryDefField(toFactoryMetadata(analysis.meta, FactoryTarget5.Pipe));\n    const def = compilePipeFromMetadata(analysis.meta);\n    const classMetadata = analysis.classMetadata !== null ? compileClassMetadata5(analysis.classMetadata).toStmt() : null;\n    return compileResults(fac, def, classMetadata, \"\\u0275pipe\");\n  }\n\n  compilePartial(node, analysis) {\n    const fac = compileDeclareFactory(toFactoryMetadata(analysis.meta, FactoryTarget5.Pipe));\n    const def = compileDeclarePipeFromMetadata(analysis.meta);\n    const classMetadata = analysis.classMetadata !== null ? compileDeclareClassMetadata5(analysis.classMetadata).toStmt() : null;\n    return compileResults(fac, def, classMetadata, \"\\u0275pipe\");\n  }\n\n}; // bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/src/references_registry.mjs\n\nvar NoopReferencesRegistry = class {\n  add(source, ...references) {}\n\n};\nexport { ErrorCode, COMPILER_ERRORS_WITH_GUIDES, replaceTsWithNgInErrors, ngErrorCode, makeDiagnostic, makeRelatedInformation, isFatalDiagnosticError, ERROR_DETAILS_PAGE_BASE_URL, SemanticDepGraphUpdater, CompoundMetadataReader, DtsMetadataReader, flattenInheritedDirectiveMetadata, LocalMetadataRegistry, CompoundMetadataRegistry, InjectableClassRegistry, ResourceRegistry, DynamicValue, StaticInterpreter, PartialEvaluator, CompilationMode, HandlerFlags, aliasTransformFactory, TraitState, TraitCompiler, DtsTransformRegistry, declarationTransformFactory, ivyTransformFactory, forwardRefResolver, readBaseClass, DirectiveDecoratorHandler, NgModuleDecoratorHandler, ComponentDecoratorHandler, InjectableDecoratorHandler, PipeDecoratorHandler, NoopReferencesRegistry };\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */","map":{"version":3,"sources":["/Users/baptiste/Desktop/DILL_XP/app/node_modules/@angular/compiler-cli/bundles/chunk-FUXNWM54.js"],"names":["createRequire","__cjsCompatRequire","require","import","meta","url","__ESM_IMPORT_META_URL__","ClassMemberKind","Decorator","KnownDeclaration","filterToMembersWithDecorator","isConcreteDeclaration","isNamedClassDeclaration","reflectObjectLiteral","reflectTypeEntityToDeclaration","typeNodeToValueExpr","ImportFlags","ImportManager","Reference","attachDefaultImportDeclaration","createExportSpecifier","getDefaultImportDeclaration","getSourceFile","identifierOfNode","isDeclaration","nodeDebugInfo","translateExpression","translateStatement","translateType","absoluteFrom","absoluteFromSourceFile","relative","PerfEvent","PerfPhase","__spreadProps","__spreadValues","DynamicValue","constructor","node","reason","code","fromDynamicInput","input","fromDynamicString","fromExternalReference","ref","fromUnsupportedSyntax","fromUnknownIdentifier","fromInvalidExpressionType","value","fromComplexFunctionCall","fn","fromDynamicType","fromUnknown","isFromDynamicInput","isFromDynamicString","isFromExternalReference","isFromUnsupportedSyntax","isFromUnknownIdentifier","isFromInvalidExpressionType","isFromComplexFunctionCall","isFromDynamicType","isFromUnknown","accept","visitor","visitDynamicInput","visitDynamicString","visitExternalReference","visitUnsupportedSyntax","visitUnknownIdentifier","visitInvalidExpressionType","visitComplexFunctionCall","visitDynamicType","visitUnknown","ts","ResolvedModule","exports","evaluate","getExport","name","has","get","getExports","map","Map","forEach","decl","set","EnumValue","enumRef","resolved","KnownFn","ArraySliceBuiltinFn","lhs","args","length","ArrayConcatBuiltinFn","result","arg","push","Array","isArray","StringConcatBuiltinFn","concat","ObjectAssignBuiltinFn","target","sources","source","key","AssignHelperFn","SpreadHelperFn","SpreadArrayHelperFn","to","from","ReadHelperFn","jsGlobalObjectValue","assignTsHelperFn","spreadTsHelperFn","spreadArrayTsHelperFn","readTsHelperFn","resolveKnownDeclaration","JsGlobalObject","TsHelperAssign","TsHelperSpread","TsHelperSpreadArrays","TsHelperSpreadArray","TsHelperRead","Error","literalBinaryOp","op","literal","referenceBinaryOp","BINARY_OPERATORS","SyntaxKind","PlusToken","a","b","MinusToken","AsteriskToken","SlashToken","PercentToken","AmpersandToken","BarToken","CaretToken","LessThanToken","LessThanEqualsToken","GreaterThanToken","GreaterThanEqualsToken","EqualsEqualsToken","EqualsEqualsEqualsToken","ExclamationEqualsToken","ExclamationEqualsEqualsToken","LessThanLessThanToken","GreaterThanGreaterThanToken","GreaterThanGreaterThanGreaterThanToken","AsteriskAsteriskToken","Math","pow","AmpersandAmpersandToken","BarBarToken","UNARY_OPERATORS","TildeToken","ExclamationToken","StaticInterpreter","host","checker","dependencyTracker","visit","context","visitExpression","kind","TrueKeyword","FalseKeyword","NullKeyword","isStringLiteral","text","isNoSubstitutionTemplateLiteral","isTemplateExpression","visitTemplateExpression","isNumericLiteral","parseFloat","isObjectLiteralExpression","visitObjectLiteralExpression","isIdentifier","visitIdentifier","isPropertyAccessExpression","visitPropertyAccessExpression","isCallExpression","visitCallExpression","isConditionalExpression","visitConditionalExpression","isPrefixUnaryExpression","visitPrefixUnaryExpression","isBinaryExpression","visitBinaryExpression","isArrayLiteralExpression","visitArrayLiteralExpression","isParenthesizedExpression","visitParenthesizedExpression","isElementAccessExpression","visitElementAccessExpression","isAsExpression","expression","isNonNullExpression","isClass","visitDeclaration","array","i","elements","element","isSpreadElement","visitSpreadElement","properties","property","isPropertyAssignment","stringNameFromPropertyName","initializer","isShorthandPropertyAssignment","symbol","getShorthandAssignmentValueSymbol","valueDeclaration","isSpreadAssignment","spread","pieces","head","templateSpans","span","join","getDeclarationOfIdentifier","originalKeywordKind","UndefinedKeyword","getImportOfIdentifier","recordDependencyAnalysisFailure","originatingFile","known","identity","getResolvedEnum","enumMembers","declContext","joinModuleContext","visitAmbiguousDeclaration","synthetic","addIdentifier","addDependency","getReference","isVariableDeclaration","visitVariableDeclaration","isParameter","scope","isExportAssignment","isEnumDeclaration","visitEnumDeclaration","isSourceFile","visitSourceFile","isBindingElement","visitBindingElement","getVariableValue","isVariableDeclarationDeclared","type","evaluatedType","visitType","members","member","rhs","argumentExpression","accessHelper","declarations","getExportsOfModule","implementation","strIndex","Number","isInteger","module","owningModule","bestGuessOwningModule","getMembersOfClass","find","member2","isStatic","evaluateFunctionArguments","getDefinitionOfFunction","isFunctionOrMethodReference","body","expr","foreignFunctionResolver","arguments","absoluteModuleName","specifier","resolutionContext","visitFfrExpression","res","visitFunctionBody","ffrExpr","ffrRes","isReturnStatement","ret","newScope","calleeContext","parameters","param","index","dotDotDotToken","slice","condition","whenTrue","whenFalse","operatorKind","operator","operand","tokenKind","operatorToken","opRecord","left","right","path","closestDeclaration","isArrayBindingPattern","isObjectBindingPattern","unshift","parent","indexOf","propertyName","isComputedPropertyName","literal2","isLiteralTypeNode","isTupleTypeNode","visitTupleType","isNamedTupleMember","elem","isFunctionDeclaration","isMethodDeclaration","isFunctionExpression","reject","isVariableDeclarationList","declList","isVariableStatement","varStmt","modifiers","some","mod","DeclareKeyword","EMPTY","existing","viaModule","fileName","override","PartialEvaluator","interpreter","sourceFile","ts3","ErrorCode","ErrorCode2","COMPILER_ERRORS_WITH_GUIDES","Set","DECORATOR_ARG_NOT_LITERAL","IMPORT_CYCLE_DETECTED","PARAM_MISSING_TOKEN","SCHEMA_INVALID_ELEMENT","SCHEMA_INVALID_ATTRIBUTE","MISSING_REFERENCE_TARGET","COMPONENT_INVALID_SHADOW_DOM_SELECTOR","ts2","ERROR_CODE_MATCHER","replaceTsWithNgInErrors","errors","replace","ngErrorCode","parseInt","FatalDiagnosticError","message","relatedInformation","_isFatalDiagnosticError","toDiagnostic","makeDiagnostic","messageText","getOriginalNode","category","DiagnosticCategory","file","start","getStart","getWidth","makeRelatedInformation","Message","isFatalDiagnosticError","err","ERROR_DETAILS_PAGE_BASE_URL","describeResolvedType","maxDepth","_a","_b","entries","v","quoteKey","debugName","test","traceDynamicValue","TraceDynamicValueVisitor","currentContainerNode","trace","shouldTrace","info","description","container","getContainerNode","currentNode","ExpressionStatement","VariableStatement","ReturnStatement","IfStatement","SwitchStatement","DoStatement","WhileStatement","ForStatement","ForInStatement","ForOfStatement","ContinueStatement","BreakStatement","ThrowStatement","ObjectBindingPattern","ArrayBindingPattern","ExternalExpr","LiteralExpr","ParseLocation","ParseSourceFile","ParseSourceSpan","ReadPropExpr","WrappedNodeExpr","ts4","getConstructorDependencies","clazz","reflector","isCore","deps","ctorParams","getConstructorParameters","hasBaseClass","idx","token","valueReferenceToExpression","typeValueReference","attributeNameType","optional","self","skipSelf","decorators","filter","dec","isAngularCore","DECORATOR_ARITY_WRONG","nodeForError","attributeName","isStringLiteralLike","createKeywordTypeNode","UnknownKeyword","DECORATOR_UNEXPECTED","valueRef","defaultImportStatement","importExpr","moduleName","importedName","nestedPath","unwrapConstructorDependencies","getValidConstructorDependencies","validateConstructorDependencies","error","createUnsuitableInjectionTokenError","chainMessage","hints","typeNode","importClause","chain","next","nameNode","toR3Reference","typeRef","valueContext","typeContext","refEmitter","emit","ForceNewImport","AllowTypeImports","decorator","isAngularCoreReference","reference","symbolName","ownedByModuleGuess","findAngularDecorator","isAngularDecorator","unwrapExpression","expandForwardRef","isArrowFunction","isBlock","statements","stmt","tryUnwrapForwardRef","imp","forwardRefResolver","combineResolvers","resolvers","resolver","isExpressionForwardReference","contextSource","isWrappedTsNodeExpr","pos","readBaseClass","evaluator","baseExpression","getBaseClassExpression","baseClass","parensWrapperTransformerFactory","visited","visitEachChild","createParen","wrapFunctionExpressionsInParens","transform","transformed","makeDuplicateDeclarationError","data","rawDeclarations","contextNode","getOriginForDiagnostics","ngModule","NGMODULE_DECLARATION_NOT_UNIQUE","resolveProvidersRequiringFactory","rawProviders","providers","resolvedProviders","processProviders","provider","tokenClass","useExisting","isDeclarationFile","constructorParameters","add","wrapTypeReference","dtsClass","getDtsDeclaration","createSourceSpan","sf","startOffset","endOffset","getEnd","line","startLine","character","startCol","getLineAndCharacterOfPosition","endLine","endCol","parseSf","getFullText","compileResults","fac","def","metadataStmt","propName","toFactoryMetadata","internalType","typeArgumentCount","compileClassMetadata","compileClassMetadata3","compileComponentFromMetadata","compileDeclareClassMetadata","compileDeclareClassMetadata3","compileDeclareComponentFromMetadata","CssSelector","DEFAULT_INTERPOLATION_CONFIG","DomElementSchemaRegistry","ExternalExpr5","FactoryTarget","FactoryTarget3","InterpolationConfig","makeBindingParser","makeBindingParser2","ParseSourceFile2","parseTemplate","R3TargetBinder","SelectorMatcher","ViewEncapsulation","WrappedNodeExpr5","ts19","ts5","SemanticSymbol","identifier","getSymbolIdentifier","ExternalExpr2","OpaqueSymbol","isPublicApiAffected","isTypeCheckApiAffected","SemanticDepGraph","files","symbolByDecl","registerSymbol","getEquivalentSymbol","previousSymbol","getSymbolByDecl","getSymbolByName","SemanticDepGraphUpdater","priorGraph","newGraph","opaqueSymbols","finalize","needsEmit","needsTypeCheckEmit","determineInvalidatedFiles","determineInvalidatedTypeCheckFiles","values","isEmitAffected","isTypeCheckBlockAffected","getSemanticReference","getSymbol","importPath","getImportPath","getOpaqueSymbol","ts6","isSymbolEqual","isReferenceEqual","referenceEquality","isArrayEqual","equalityTester","item","isSetEqual","size","itemA","found","itemB","extractSemanticTypeParameters","isClassDeclaration","typeParameters","typeParam","hasGenericTypeBound","constraint","areTypeParametersEqual","current","previous","isTypeParameterEqual","MetaType","MetaType2","ts8","ClassPropertyMapping","forwardMap","reverseMap","reverseMapFromForwardMap","empty","fromMappedObject","obj","classPropertyName","Object","keys","bindingPropertyName","inputOrOutput","merge","classPropertyNames","propertyNames","hasBindingPropertyName","getByBindingPropertyName","getByClassPropertyName","toDirectMappedObject","toJointMappedObject","Symbol","iterator","_","ts7","extractReferencesFromType","isTypeQueryNode","exprName","startsWith","readStringType","readStringMapType","isTypeLiteralNode","isPropertySignature","readStringArrayType","el","extractDirectiveTypeCheckMeta","inputs","staticMembers","ngTemplateGuards","extractTemplateGuard","guard","hasNgTemplateContextGuard","Method","coercedInputFields","extractCoercedInput","inputName","restrictedInputFields","stringLiteralInputFields","undeclaredInputFields","field","isRestricted","arity","getGenericArityOfClass","isGeneric","modifier","PrivateKeyword","ProtectedKeyword","ReadonlyKeyword","afterUnderscore","Property","CompoundMetadataReader","readers","getDirectiveMetadata","reader","getNgModuleMetadata","getPipeMetadata","str","substr","hasInjectableFields","DtsMetadataReader","ngModuleDef","isTypeReferenceNode","typeArguments","declarationMetadata","importMetadata","exportMetadata","imports","schemas","isComponent","isStructural","outputs","Directive","selector","exportAs","queries","readBaseClass2","isPoisoned","Pipe","nameExpr","heritageClauses","clause","ExtendsKeyword","baseExpr","types","getSymbolAtLocation","flags","SymbolFlags","Alias","getAliasedSymbol","flattenInheritedDirectiveMetadata","dir","topMeta","isDynamic","addMetadata","baseMeta","coercedInputField","undeclaredInputField","restrictedInputField","LocalMetadataRegistry","directives","ngModules","pipes","registerDirectiveMetadata","registerNgModuleMetadata","registerPipeMetadata","CompoundMetadataRegistry","registries","registry","InjectableClassRegistry","classes","registerInjectable","declaration","isInjectable","ResourceRegistry","externalTemplateToComponentsMap","componentToTemplateMap","componentToStylesMap","externalStyleToComponentsMap","getComponentsWithTemplate","template","registerResources","resources","component","registerTemplate","style","styles","registerStyle","templateResource","getTemplate","styleResource","getStyles","getComponentsWithStyle","styleUrl","CompilationMode","CompilationMode2","HandlerPrecedence","HandlerPrecedence2","HandlerFlags","HandlerFlags2","ts9","aliasTransformFactory","exportStatements","isBundle","aliasName","createExportDeclaration","createNamedExports","createStringLiteral","updateSourceFileNode","ts10","TraitState","TraitState2","Trait","pending","handler","detected","TraitImpl","state","Pending","analysis","resolution","analysisDiagnostics","resolveDiagnostics","toAnalyzed","diagnostics","assertTransitionLegal","Analyzed","toResolved","Resolved","toSkipped","Skipped","allowedState","transitionTo","TraitCompiler","handlers","perf","incrementalBuild","compileNonExportedClasses","compilationMode","dtsTransforms","semanticDepGraphUpdater","fileToClasses","filesWithoutTraits","reexportMap","handlersByName","analyzeSync","analyze","analyzeAsync","preanalyze","promises","priorWork","priorAnalysisFor","eventCount","SourceFileReuseAnalysis","priorRecord","adopt","TraitReuseAnalysis","visit2","analyzeClass","forEachChild","Promise","all","then","recordFor","recordsFor","records","getAnalyzedRecords","record","hasPrimaryHandler","hasWeakHandlers","metaDiagnostics","traits","priorTrait","trait","makeSymbolForTrait","register","scanClassForTraits","isStaticallyExported","getDecoratorsOfDeclaration","detectTraits","foundTraits","detect","isPrimaryHandler","precedence","PRIMARY","isWeakHandler","WEAK","DECORATOR_COLLISION","isPrimary","preanalyzeQueue","analyzeTrait","preanalysis","metadata","_c","TraitAnalyze","resolve","getPrototypeOf","reexports","fileReexports","reexport","asAlias","fromModule","typeCheck","ctx","extendedTemplateCheck","extendedTemplateChecker","xi18n","bundle","updateResources","compile","constantPool","original","compileRes","PARTIAL","compilePartial","compileFull","compileMatchRes","r","getIvyDeclarationTransform","addFields","decoratorsFor","trigger","isDecorator","ts12","ts11","addImports","importManager","extraStatements","addedImports","getAllImports","qualifier","createIdentifier","createImportClause","createNamespaceImport","createImportDeclaration","createLiteral","setOriginalNode","existingImports","isImportStatement","fileoverviewAnchorStmt","createNotEmittedStatement","createNodeArray","isImportDeclaration","isImportEqualsDeclaration","isNamespaceImport","DtsTransformRegistry","ivyDeclarationTransforms","IvyDeclarationDtsTransform","getAllTransforms","originalSf","transforms","declarationTransformFactory","transformRegistry","importRewriter","importPrefix","transformer","DtsTransformer","fileOrBundle","transformClassDeclaration","transformFunctionDeclaration","visitNode","elementsChanged","transformClassElement","newClazz","transformClass","inputMembers","updateClassDeclaration","newDecl","declarationFields","fields","newMembers","createModifier","StaticKeyword","markForEmitAsSingleLine","createProperty","setEmitFlags","EmitFlags","SingleLine","ConstantPool","ts14","ts13","_visit","Visitor","_before","_after","_visitListEntryNode","before","after","visitOtherNode","visitedNode","child","node2","visitClassDeclaration","hasStatements","_maybeProcessStatements","every","clone","getMutableClone","newStatements","delete","hasTrailingComma","block","NO_DECORATORS","CLOSURE_FILE_OVERVIEW_REGEXP","ivyTransformFactory","compilation","defaultImportTracker","isClosureCompilerEnabled","recordWrappedNode","createRecorderFn","inPhase","Compile","transformIvySourceFile","IvyCompilationVisitor","classCompilationMap","IvyTransformationVisitor","recordWrappedNodeExpr","translateOptions","annotateForClosureCompiler","exprNode","createToken","addSyntheticLeadingComment","MultiLineCommentTrivia","maybeFilterDecorator","_stripAngularDecorators","_angularCoreDecorators","coreDecorators","isFromAngularCore","_nonCoreDecoratorsOnly","filtered","end","updateParameter","questionToken","updateMethod","asteriskToken","isPropertyDeclaration","updateProperty","isGetAccessor","updateGetAccessor","isSetAccessor","updateSetAccessor","isConstructorDeclaration","updateConstructor","compilationVisitor","transformationVisitor","downlevelTranslatedCode","getLocalizeCompileTarget","ScriptTarget","ES2015","constants","downlevelTaggedTemplates","downlevelVariableDeclarations","fileOverviewMeta","getFileOverviewComment","setFileOverviewComment","getCompilerOptions","JSON","trailing","comments","getSyntheticLeadingComments","getSyntheticTrailingComments","fileoverview","setSyntheticTrailingComments","setSyntheticLeadingComments","toRemove","decToRemove","importDecl","recordUsedImport","ts15","createValueHasWrongTypeError","chainedMessage","referenceNode","VALUE_HAS_WRONG_TYPE","getProviderDiagnostics","providerClasses","providersDeclaration","UNDECORATED_PROVIDER","getDirectiveDiagnostics","scopeRegistry","addDiagnostics","more","duplicateDeclarations","getDuplicateDeclarations","checkInheritanceOfDirective","getUndecoratedClassWithAngularFeaturesDiagnostic","UNDECORATED_CLASS_USING_ANGULAR_FEATURES","baseClassMeta","baseClassConstructorParams","newParentClass","getInheritedUndecoratedCtorDiagnostic","subclassMeta","dirOrComp","baseClassName","DIRECTIVE_INHERITS_UNDECORATED_CTOR","toLowerCase","compileDeclareDirectiveFromMetadata","compileDirectiveFromMetadata","createMayBeForwardRefExpression","emitDistinctChangesOnlyDefaultValue","ExternalExpr3","getSafePropertyAccessString","parseHostBindings","verifyHostBindings","WrappedNodeExpr3","ts17","compileDeclareFactoryFunction","compileFactoryFunction","compileNgFactoryDefField","compileDeclareFactory","FunctionExpr","LiteralArrayExpr","LiteralExpr2","literalMap","WrappedNodeExpr2","ts16","extractClassMetadata","reflection","angularDecoratorTransform","id","getAdjacentNameOfClass","classDecorators","ngClassDecorators","isAngularDecorator2","decoratorToMetadata","removeIdentifierReferences","metaDecorators","createArrayLiteral","metaCtorParameters","classCtorParameters","ctorParameters","ctorParameterToMetadata","metaPropDecorators","classMembers","duplicateDecoratedMemberNames","arr","decoratedMembers","classMemberToMetadata","createObjectLiteral","propDecorators","mapEntries","quoted","ngDecorators","decoratorMeta","createPropertyAssignment","wrapFunctionsInParens","root","walk","EMPTY_OBJECT","FIELD_DECORATORS","LIFECYCLE_HOOKS","DirectiveSymbol","typeCheckMeta","isInputMappingEqual","isTypeCheckMetaEqual","isBaseClassEqual","isTemplateGuardEqual","DirectiveDecoratorHandler","metaRegistry","metaReader","injectableRegistry","compileUndecoratedClassesWithAngularFeatures","angularField","findClassFieldWithAngularFeatures","NONE","AnalyzeDirective","directiveResult","extractDirectiveMetadata","providersRequiringFactory","classMetadata","query","providerDiagnostics","directiveDiagnostics","pool","toStmt","decoratorName","defaultSelector","directive","decoratedElements","coreModule","inputsFromMeta","parseFieldToPropertyMapping","inputsFromFields","parseDecoratedFields","resolveInput","outputsFromMeta","outputsFromFields","resolveOutput","contentChildFromFields","queriesFromFields","contentChildrenFromFields","viewChildFromFields","viewChildrenFromFields","viewQueries","queriesFromDecorator","extractQueriesFromDecorator","content","view","DIRECTIVE_MISSING_SELECTOR","extractHostBindings","usesOnChanges","split","part","trim","rawCtorDeps","ctorDeps","dep","usesInheritance","getInternalNameOfClass","lifecycle","fullInheritance","FULL_INHERITANCE","typeSourceSpan","extractQueryMetadata","first","forwardReferenceTarget","predicate","isStringArrayOrDie","read","descendants","emitDistinctChangesOnly","optionsExpr","options","descendantsExpr","descendantsValue","emitDistinctChangesOnlyExpr","emitDistinctChangesOnlyValue","staticValue","static","queryData","queryExpr","isNewExpression","queryType","QUERY_TYPES","parseFieldArrayValue","metaValues","reduce","results","field2","mapValueResolver","fieldName","publicName","internalName","isPropertyTypeMember","Getter","Setter","evaluateHostExpressionBindings","hostExpr","hostMetaMap","hostMetadata","bindings","HOST_BINDING_PARSE_ERROR","msg","hostPropertyName","eventName","resolvedArgs","listeners","compileClassMetadata2","compileDeclareClassMetadata2","compileDeclareInjectorFromMetadata","compileDeclareNgModuleFromMetadata","compileInjector","compileNgModule","CUSTOM_ELEMENTS_SCHEMA","ExternalExpr4","FactoryTarget2","InvokeFunctionExpr","LiteralArrayExpr2","NO_ERRORS_SCHEMA","R3Identifiers","WrappedNodeExpr4","ts18","NgModuleSymbol","remotelyScopedComponents","currEntry","prevEntry","prevEntry2","usedDirectives","usedPipes","addRemotelyScopedComponent","NgModuleDecoratorHandler","referencesRegistry","factoryTracker","AnalyzeNgModule","moduleResolvers","_extractModuleFromModuleWithProvidersFn","declarationRefs","declarationMeta","resolveTypeList","errorNode","NGMODULE_INVALID_DECLARATION","importRefs","rawImports","importsMeta","exportRefs","rawExports","exportsMeta","bootstrapRefs","bootstrapMeta","rawExpr","schemaRef","id2","getIdentityIn","bootstrap","bootstrap2","_toR3Reference","exp","isForwardReference","containsForwardDecls","adjacentType","ngModuleMetadata","emitInline","wrapperProviders","injectorImports","injectorMetadata","factoryMetadata","NgModule","inj","factorySymbolName","track","hasId","getScopeOfModule","scopeDiagnostics","getDiagnosticsOfModule","exportRef","isNgModule","exported","factoryFn","ngInjectorDef","mergeInjectorImports","insertMetadataStatement","appendRemoteScopingStatements","injectorDef","ngModuleStatements","remoteScope","getRemoteScope","pipe","directiveArray","pipesArray","declExpr","setComponentScope","callExpr","hasOwningModuleGuess","_reflectModuleFromTypeParam","_reflectModuleFromLiteralType","typeName","isQualifiedName","getText","NGMODULE_MODULE_WITH_PROVIDERS_MISSING_GENERIC","isIntersectionTypeNode","t","m","ngModuleType","ngModuleExpression","isClassDeclarationReference","resolvedList","className","arrayName","refList","entry","EMPTY_MAP","EMPTY_ARRAY","ComponentSymbol","isRemotelyScoped","publicApiAffected","isSymbolUnaffected","typeCheckApiAffected","isInheritanceChainAffected","currentSymbol","isDirectiveUnaffected","isPipeUnaffected","ComponentDecoratorHandler","scopeReader","typeCheckScopeRegistry","resourceRegistry","resourceLoader","rootDirs","defaultPreserveWhitespaces","i18nUseExternalIds","enableI18nLegacyMessageIdFormat","usePoisonedData","i18nNormalizeLineEndingsInICUs","moduleResolver","cycleAnalyzer","cycleHandlingStrategy","depTracker","literalCache","elementSchemaRegistry","preanalyzeTemplateCache","preanalyzeStylesCache","canPreload","_resolveLiteral","containingFile","resolveStyleUrl","resourceUrl","preload","templateAndTemplateStyleResources","_preloadAndParseTemplate","styleUrls","componentStyleUrls","_extractComponentStyleUrls","inlineStyles","litStyles","preprocessInline","AnalyzeComponent","getDefaultComponentElementName","encapsulation","_resolveEnumValue","Emulated","changeDetection","animations","relativeContextFilePath","rootDir","candidate","viewProvidersRequiringFactory","wrappedViewProviders","viewProviders","preanalyzed","templateDecl","parseTemplateDeclaration","extractTemplate","isInline","resolvedTemplateUrl","sourceMapping","styleResources","_extractStyleResources","_extractTemplateStyleUrls","resourceStr","load","addResourceDependency","resourceType","makeResourceNotFoundError","ShadowDom","selectorError","checkCustomElementSelectorForErrors","canPreprocess","output","nodes","ngContentSelectors","interpolation","interpolationConfig","_transformDecoratorToInlineResources","getScopeForComponent","matcher","addSelectables","parse","binder","boundTemplate","bind","diagNodes","addComponent","templateMeta","getTypeCheckScope","addTemplate","getDiagnosticsForComponent","declarationListEmitMode","bound","getUsedDirectives","importedFile","pipeName","getUsedPipes","cyclesFromDirectives","usedDirective","cycle","_checkForCyclicImport","cyclesFromPipes","usedPipe","cycleDetected","_recordSyntheticImport","wrapDirectivesAndPipesInClosure","setComponentRemoteScope","moduleSymbol","relatedMessages","makeCyclicImportInfo","viewProviderDiagnostics","updateFromTemplate","resolvedStyleUrl","styleText","e","Component","templateInfo","sourceUrl","inlineTemplateLiteralExpression","s","newMetadataFields","enumSymbolName","_extractStyleUrlsFromExpression","styleUrlsExpr","styleUrlExpr","evaluatedStyleUrls","isStringArray","stringLiteralElements","stylesExpr","templateUrlExpr","templateUrl","templatePromise","sourceStr","sourceParseRange","templateContent","escapedString","sourceMapUrl","getTemplateRange","resolvedTemplate","componentClass","_parseTemplate","templateUrlExpression","parsedTemplate","preserveWhitespaces","range","alwaysAttemptHtmlToR3AstConversion","preserveLineEndings","leadingTriviaChars","fromArray","COMPONENT_MISSING_TEMPLATE","_resolveImportedFile","origin","resolveModule","imported","wouldCreateCycle","recordSyntheticImport","errorText","COMPONENT_RESOURCE_NOT_FOUND","getTemplateDeclarationNodeForError","templateExpr","startPos","endPos","resolvedValue","getPath","includes","compileClassMetadata4","compileDeclareClassMetadata4","compileDeclareInjectableFromMetadata","compileInjectable","createMayBeForwardRefExpression2","FactoryTarget4","LiteralExpr3","WrappedNodeExpr6","ts20","InjectableDecoratorHandler","strictCtorDeps","errorOnDuplicateProv","SHARED","AnalyzeInjectable","extractInjectableMetadata","extractInjectableCtorDeps","needsFactory","compileFactoryFn","compileInjectableFn","compileClassMetadataFn","factoryRes","Injectable","ɵprov","INJECTABLE_DUPLICATE_PROV","DECORATOR_NOT_CALLED","providedIn","metaNode","getProviderExpression","depsExpr","VALUE_NOT_LITERAL","getDep","useValue","useClass","useFactory","forwardRefValue","maybeUpdateDecorator","reflector2","compileClassMetadata5","compileDeclareClassMetadata5","compileDeclarePipeFromMetadata","compilePipeFromMetadata","FactoryTarget5","WrappedNodeExpr7","ts21","PipeSymbol","PipeDecoratorHandler","AnalyzePipe","PIPE_MISSING_NAME","pipeNameExpr","pure","pureValue","duplicateDeclData","NoopReferencesRegistry","references"],"mappings":"AACM,SAAQA,aAAa,IAAIC,kBAAzB,QAAkD,QAAlD;;AACA,MAAMC,OAAO,GAAGD,kBAAkB,CAACE,MAAM,CAACC,IAAP,CAAYC,GAAb,CAAlC;;AACA,MAAMC,uBAAuB,GAAGH,MAAM,CAACC,IAAP,CAAYC,GAA5C;AAEN,SACEE,eADF,EAEEC,SAFF,EAGEC,gBAHF,EAIEC,4BAJF,EAKEC,qBALF,EAMEC,uBANF,EAOEC,oBAPF,EAQEC,8BARF,EASEC,mBATF,QAUO,qBAVP;AAWA,SACEC,WADF,EAEEC,aAFF,EAGEC,SAHF,EAIEC,8BAJF,EAKEC,qBALF,EAMEC,2BANF,EAOEC,aAPF,EAQEC,gBARF,EASEC,aATF,EAUEC,aAVF,EAWEC,mBAXF,EAYEC,kBAZF,EAaEC,aAbF,QAcO,qBAdP;AAeA,SACEC,YADF,EAEEC,sBAFF,EAGEC,QAHF,QAIO,qBAJP;AAKA,SACEC,SADF,EAEEC,SAFF,QAGO,qBAHP;AAIA,SACEC,aADF,EAEEC,cAFF,QAGO,qBAHP,C,CAKA;;AACA,IAAIC,YAAY,GAAG,MAAM;AACvBC,EAAAA,WAAW,CAACC,IAAD,EAAOC,MAAP,EAAeC,IAAf,EAAqB;AAC9B,SAAKF,IAAL,GAAYA,IAAZ;AACA,SAAKC,MAAL,GAAcA,MAAd;AACA,SAAKC,IAAL,GAAYA,IAAZ;AACD;;AACsB,SAAhBC,gBAAgB,CAACH,IAAD,EAAOI,KAAP,EAAc;AACnC,WAAO,IAAIN,YAAJ,CAAiBE,IAAjB,EAAuBI,KAAvB,EAA8B,CAA9B,CAAP;AACD;;AACuB,SAAjBC,iBAAiB,CAACL,IAAD,EAAO;AAC7B,WAAO,IAAIF,YAAJ,CAAiBE,IAAjB,EAAuB,KAAK,CAA5B,EAA+B,CAA/B,CAAP;AACD;;AAC2B,SAArBM,qBAAqB,CAACN,IAAD,EAAOO,GAAP,EAAY;AACtC,WAAO,IAAIT,YAAJ,CAAiBE,IAAjB,EAAuBO,GAAvB,EAA4B,CAA5B,CAAP;AACD;;AAC2B,SAArBC,qBAAqB,CAACR,IAAD,EAAO;AACjC,WAAO,IAAIF,YAAJ,CAAiBE,IAAjB,EAAuB,KAAK,CAA5B,EAA+B,CAA/B,CAAP;AACD;;AAC2B,SAArBS,qBAAqB,CAACT,IAAD,EAAO;AACjC,WAAO,IAAIF,YAAJ,CAAiBE,IAAjB,EAAuB,KAAK,CAA5B,EAA+B,CAA/B,CAAP;AACD;;AAC+B,SAAzBU,yBAAyB,CAACV,IAAD,EAAOW,KAAP,EAAc;AAC5C,WAAO,IAAIb,YAAJ,CAAiBE,IAAjB,EAAuBW,KAAvB,EAA8B,CAA9B,CAAP;AACD;;AAC6B,SAAvBC,uBAAuB,CAACZ,IAAD,EAAOa,EAAP,EAAW;AACvC,WAAO,IAAIf,YAAJ,CAAiBE,IAAjB,EAAuBa,EAAvB,EAA2B,CAA3B,CAAP;AACD;;AACqB,SAAfC,eAAe,CAACd,IAAD,EAAO;AAC3B,WAAO,IAAIF,YAAJ,CAAiBE,IAAjB,EAAuB,KAAK,CAA5B,EAA+B,CAA/B,CAAP;AACD;;AACiB,SAAXe,WAAW,CAACf,IAAD,EAAO;AACvB,WAAO,IAAIF,YAAJ,CAAiBE,IAAjB,EAAuB,KAAK,CAA5B,EAA+B,CAA/B,CAAP;AACD;;AACDgB,EAAAA,kBAAkB,GAAG;AACnB,WAAO,KAAKd,IAAL,KAAc,CAArB;AACD;;AACDe,EAAAA,mBAAmB,GAAG;AACpB,WAAO,KAAKf,IAAL,KAAc,CAArB;AACD;;AACDgB,EAAAA,uBAAuB,GAAG;AACxB,WAAO,KAAKhB,IAAL,KAAc,CAArB;AACD;;AACDiB,EAAAA,uBAAuB,GAAG;AACxB,WAAO,KAAKjB,IAAL,KAAc,CAArB;AACD;;AACDkB,EAAAA,uBAAuB,GAAG;AACxB,WAAO,KAAKlB,IAAL,KAAc,CAArB;AACD;;AACDmB,EAAAA,2BAA2B,GAAG;AAC5B,WAAO,KAAKnB,IAAL,KAAc,CAArB;AACD;;AACDoB,EAAAA,yBAAyB,GAAG;AAC1B,WAAO,KAAKpB,IAAL,KAAc,CAArB;AACD;;AACDqB,EAAAA,iBAAiB,GAAG;AAClB,WAAO,KAAKrB,IAAL,KAAc,CAArB;AACD;;AACDsB,EAAAA,aAAa,GAAG;AACd,WAAO,KAAKtB,IAAL,KAAc,CAArB;AACD;;AACDuB,EAAAA,MAAM,CAACC,OAAD,EAAU;AACd,YAAQ,KAAKxB,IAAb;AACE,WAAK,CAAL;AACE,eAAOwB,OAAO,CAACC,iBAAR,CAA0B,IAA1B,CAAP;;AACF,WAAK,CAAL;AACE,eAAOD,OAAO,CAACE,kBAAR,CAA2B,IAA3B,CAAP;;AACF,WAAK,CAAL;AACE,eAAOF,OAAO,CAACG,sBAAR,CAA+B,IAA/B,CAAP;;AACF,WAAK,CAAL;AACE,eAAOH,OAAO,CAACI,sBAAR,CAA+B,IAA/B,CAAP;;AACF,WAAK,CAAL;AACE,eAAOJ,OAAO,CAACK,sBAAR,CAA+B,IAA/B,CAAP;;AACF,WAAK,CAAL;AACE,eAAOL,OAAO,CAACM,0BAAR,CAAmC,IAAnC,CAAP;;AACF,WAAK,CAAL;AACE,eAAON,OAAO,CAACO,wBAAR,CAAiC,IAAjC,CAAP;;AACF,WAAK,CAAL;AACE,eAAOP,OAAO,CAACQ,gBAAR,CAAyB,IAAzB,CAAP;;AACF,WAAK,CAAL;AACE,eAAOR,OAAO,CAACS,YAAR,CAAqB,IAArB,CAAP;AAlBJ;AAoBD;;AAjFsB,CAAzB,C,CAoFA;;AACA,OAAOC,EAAP,MAAe,YAAf,C,CAEA;;AACA,IAAIC,cAAc,GAAG,MAAM;AACzBtC,EAAAA,WAAW,CAACuC,OAAD,EAAUC,QAAV,EAAoB;AAC7B,SAAKD,OAAL,GAAeA,OAAf;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACD;;AACDC,EAAAA,SAAS,CAACC,IAAD,EAAO;AACd,QAAI,CAAC,KAAKH,OAAL,CAAaI,GAAb,CAAiBD,IAAjB,CAAL,EAA6B;AAC3B,aAAO,KAAK,CAAZ;AACD;;AACD,WAAO,KAAKF,QAAL,CAAc,KAAKD,OAAL,CAAaK,GAAb,CAAiBF,IAAjB,CAAd,CAAP;AACD;;AACDG,EAAAA,UAAU,GAAG;AACX,UAAMC,GAAG,GAAG,IAAIC,GAAJ,EAAZ;AACA,SAAKR,OAAL,CAAaS,OAAb,CAAqB,CAACC,IAAD,EAAOP,IAAP,KAAgB;AACnCI,MAAAA,GAAG,CAACI,GAAJ,CAAQR,IAAR,EAAc,KAAKF,QAAL,CAAcS,IAAd,CAAd;AACD,KAFD;AAGA,WAAOH,GAAP;AACD;;AAjBwB,CAA3B;AAmBA,IAAIK,SAAS,GAAG,MAAM;AACpBnD,EAAAA,WAAW,CAACoD,OAAD,EAAUV,IAAV,EAAgBW,QAAhB,EAA0B;AACnC,SAAKD,OAAL,GAAeA,OAAf;AACA,SAAKV,IAAL,GAAYA,IAAZ;AACA,SAAKW,QAAL,GAAgBA,QAAhB;AACD;;AALmB,CAAtB;AAOA,IAAIC,OAAO,GAAG,MAAM,EAApB,C,CAGA;;AACA,IAAIC,mBAAmB,GAAG,cAAcD,OAAd,CAAsB;AAC9CtD,EAAAA,WAAW,CAACwD,GAAD,EAAM;AACf;AACA,SAAKA,GAAL,GAAWA,GAAX;AACD;;AACDhB,EAAAA,QAAQ,CAACvC,IAAD,EAAOwD,IAAP,EAAa;AACnB,QAAIA,IAAI,CAACC,MAAL,KAAgB,CAApB,EAAuB;AACrB,aAAO,KAAKF,GAAZ;AACD,KAFD,MAEO;AACL,aAAOzD,YAAY,CAACiB,WAAb,CAAyBf,IAAzB,CAAP;AACD;AACF;;AAX6C,CAAhD;AAaA,IAAI0D,oBAAoB,GAAG,cAAcL,OAAd,CAAsB;AAC/CtD,EAAAA,WAAW,CAACwD,GAAD,EAAM;AACf;AACA,SAAKA,GAAL,GAAWA,GAAX;AACD;;AACDhB,EAAAA,QAAQ,CAACvC,IAAD,EAAOwD,IAAP,EAAa;AACnB,UAAMG,MAAM,GAAG,CAAC,GAAG,KAAKJ,GAAT,CAAf;;AACA,SAAK,MAAMK,GAAX,IAAkBJ,IAAlB,EAAwB;AACtB,UAAII,GAAG,YAAY9D,YAAnB,EAAiC;AAC/B6D,QAAAA,MAAM,CAACE,IAAP,CAAY/D,YAAY,CAACK,gBAAb,CAA8BH,IAA9B,EAAoC4D,GAApC,CAAZ;AACD,OAFD,MAEO,IAAIE,KAAK,CAACC,OAAN,CAAcH,GAAd,CAAJ,EAAwB;AAC7BD,QAAAA,MAAM,CAACE,IAAP,CAAY,GAAGD,GAAf;AACD,OAFM,MAEA;AACLD,QAAAA,MAAM,CAACE,IAAP,CAAYD,GAAZ;AACD;AACF;;AACD,WAAOD,MAAP;AACD;;AAjB8C,CAAjD;AAmBA,IAAIK,qBAAqB,GAAG,cAAcX,OAAd,CAAsB;AAChDtD,EAAAA,WAAW,CAACwD,GAAD,EAAM;AACf;AACA,SAAKA,GAAL,GAAWA,GAAX;AACD;;AACDhB,EAAAA,QAAQ,CAACvC,IAAD,EAAOwD,IAAP,EAAa;AACnB,QAAIG,MAAM,GAAG,KAAKJ,GAAlB;;AACA,SAAK,MAAMK,GAAX,IAAkBJ,IAAlB,EAAwB;AACtB,YAAMJ,QAAQ,GAAGQ,GAAG,YAAYV,SAAf,GAA2BU,GAAG,CAACR,QAA/B,GAA0CQ,GAA3D;;AACA,UAAI,OAAOR,QAAP,KAAoB,QAApB,IAAgC,OAAOA,QAAP,KAAoB,QAApD,IAAgE,OAAOA,QAAP,KAAoB,SAApF,IAAiGA,QAAQ,IAAI,IAAjH,EAAuH;AACrHO,QAAAA,MAAM,GAAGA,MAAM,CAACM,MAAP,CAAcb,QAAd,CAAT;AACD,OAFD,MAEO;AACL,eAAOtD,YAAY,CAACiB,WAAb,CAAyBf,IAAzB,CAAP;AACD;AACF;;AACD,WAAO2D,MAAP;AACD;;AAhB+C,CAAlD;AAkBA,IAAIO,qBAAqB,GAAG,cAAcb,OAAd,CAAsB;AAChDd,EAAAA,QAAQ,CAACvC,IAAD,EAAOwD,IAAP,EAAa;AACnB,QAAIA,IAAI,CAACC,MAAL,KAAgB,CAApB,EAAuB;AACrB,aAAO3D,YAAY,CAACU,qBAAb,CAAmCR,IAAnC,CAAP;AACD;;AACD,SAAK,MAAM4D,GAAX,IAAkBJ,IAAlB,EAAwB;AACtB,UAAII,GAAG,YAAY9D,YAAnB,EAAiC;AAC/B,eAAOA,YAAY,CAACK,gBAAb,CAA8BH,IAA9B,EAAoC4D,GAApC,CAAP;AACD,OAFD,MAEO,IAAI,EAAEA,GAAG,YAAYd,GAAjB,CAAJ,EAA2B;AAChC,eAAOhD,YAAY,CAACU,qBAAb,CAAmCR,IAAnC,CAAP;AACD;AACF;;AACD,UAAM,CAACmE,MAAD,EAAS,GAAGC,OAAZ,IAAuBZ,IAA7B;;AACA,SAAK,MAAMa,MAAX,IAAqBD,OAArB,EAA8B;AAC5BC,MAAAA,MAAM,CAACtB,OAAP,CAAe,CAACpC,KAAD,EAAQ2D,GAAR,KAAgBH,MAAM,CAAClB,GAAP,CAAWqB,GAAX,EAAgB3D,KAAhB,CAA/B;AACD;;AACD,WAAOwD,MAAP;AACD;;AAjB+C,CAAlD,C,CAoBA;;AACA,IAAII,cAAc,GAAG,cAAcL,qBAAd,CAAoC,EAAzD;AAEA,IAAIM,cAAc,GAAG,cAAcnB,OAAd,CAAsB;AACzCd,EAAAA,QAAQ,CAACvC,IAAD,EAAOwD,IAAP,EAAa;AACnB,UAAMG,MAAM,GAAG,EAAf;;AACA,SAAK,MAAMC,GAAX,IAAkBJ,IAAlB,EAAwB;AACtB,UAAII,GAAG,YAAY9D,YAAnB,EAAiC;AAC/B6D,QAAAA,MAAM,CAACE,IAAP,CAAY/D,YAAY,CAACK,gBAAb,CAA8BH,IAA9B,EAAoC4D,GAApC,CAAZ;AACD,OAFD,MAEO,IAAIE,KAAK,CAACC,OAAN,CAAcH,GAAd,CAAJ,EAAwB;AAC7BD,QAAAA,MAAM,CAACE,IAAP,CAAY,GAAGD,GAAf;AACD,OAFM,MAEA;AACLD,QAAAA,MAAM,CAACE,IAAP,CAAYD,GAAZ;AACD;AACF;;AACD,WAAOD,MAAP;AACD;;AAbwC,CAA3C;AAeA,IAAIc,mBAAmB,GAAG,cAAcpB,OAAd,CAAsB;AAC9Cd,EAAAA,QAAQ,CAACvC,IAAD,EAAOwD,IAAP,EAAa;AACnB,QAAIA,IAAI,CAACC,MAAL,KAAgB,CAAhB,IAAqBD,IAAI,CAACC,MAAL,KAAgB,CAAzC,EAA4C;AAC1C,aAAO3D,YAAY,CAACiB,WAAb,CAAyBf,IAAzB,CAAP;AACD;;AACD,UAAM,CAAC0E,EAAD,EAAKC,IAAL,IAAanB,IAAnB;;AACA,QAAIkB,EAAE,YAAY5E,YAAlB,EAAgC;AAC9B,aAAOA,YAAY,CAACK,gBAAb,CAA8BH,IAA9B,EAAoC0E,EAApC,CAAP;AACD,KAFD,MAEO,IAAIC,IAAI,YAAY7E,YAApB,EAAkC;AACvC,aAAOA,YAAY,CAACK,gBAAb,CAA8BH,IAA9B,EAAoC2E,IAApC,CAAP;AACD;;AACD,QAAI,CAACb,KAAK,CAACC,OAAN,CAAcW,EAAd,CAAL,EAAwB;AACtB,aAAO5E,YAAY,CAACY,yBAAb,CAAuCV,IAAvC,EAA6C0E,EAA7C,CAAP;AACD,KAFD,MAEO,IAAI,CAACZ,KAAK,CAACC,OAAN,CAAcY,IAAd,CAAL,EAA0B;AAC/B,aAAO7E,YAAY,CAACY,yBAAb,CAAuCV,IAAvC,EAA6C2E,IAA7C,CAAP;AACD;;AACD,WAAOD,EAAE,CAACT,MAAH,CAAUU,IAAV,CAAP;AACD;;AAjB6C,CAAhD;AAmBA,IAAIC,YAAY,GAAG,cAAcvB,OAAd,CAAsB;AACvCd,EAAAA,QAAQ,CAACvC,IAAD,EAAOwD,IAAP,EAAa;AACnB,QAAIA,IAAI,CAACC,MAAL,KAAgB,CAApB,EAAuB;AACrB,aAAO3D,YAAY,CAACiB,WAAb,CAAyBf,IAAzB,CAAP;AACD;;AACD,UAAM,CAACW,KAAD,IAAU6C,IAAhB;;AACA,QAAI7C,KAAK,YAAYb,YAArB,EAAmC;AACjC,aAAOA,YAAY,CAACK,gBAAb,CAA8BH,IAA9B,EAAoCW,KAApC,CAAP;AACD;;AACD,QAAI,CAACmD,KAAK,CAACC,OAAN,CAAcpD,KAAd,CAAL,EAA2B;AACzB,aAAOb,YAAY,CAACY,yBAAb,CAAuCV,IAAvC,EAA6CW,KAA7C,CAAP;AACD;;AACD,WAAOA,KAAP;AACD;;AAbsC,CAAzC,C,CAgBA;;AACA,IAAIkE,mBAAmB,GAAG,IAAI/B,GAAJ,CAAQ,CAAC,CAAC,QAAD,EAAW,IAAIoB,qBAAJ,EAAX,CAAD,CAAR,CAA1B;AACA,IAAIY,gBAAgB,GAAG,IAAIP,cAAJ,EAAvB;AACA,IAAIQ,gBAAgB,GAAG,IAAIP,cAAJ,EAAvB;AACA,IAAIQ,qBAAqB,GAAG,IAAIP,mBAAJ,EAA5B;AACA,IAAIQ,cAAc,GAAG,IAAIL,YAAJ,EAArB;;AACA,SAASM,uBAAT,CAAiClC,IAAjC,EAAuC;AACrC,UAAQA,IAAR;AACE,SAAK7E,gBAAgB,CAACgH,cAAtB;AACE,aAAON,mBAAP;;AACF,SAAK1G,gBAAgB,CAACiH,cAAtB;AACE,aAAON,gBAAP;;AACF,SAAK3G,gBAAgB,CAACkH,cAAtB;AACA,SAAKlH,gBAAgB,CAACmH,oBAAtB;AACE,aAAOP,gBAAP;;AACF,SAAK5G,gBAAgB,CAACoH,mBAAtB;AACE,aAAOP,qBAAP;;AACF,SAAK7G,gBAAgB,CAACqH,YAAtB;AACE,aAAOP,cAAP;;AACF;AACE,YAAM,IAAIQ,KAAJ,CAAW,+CAA8CtH,gBAAgB,CAAC6E,IAAD,CAAO,GAAhF,CAAN;AAbJ;AAeD,C,CAED;;;AACA,SAAS0C,eAAT,CAAyBC,EAAzB,EAA6B;AAC3B,SAAO;AAAEA,IAAAA,EAAF;AAAMC,IAAAA,OAAO,EAAE;AAAf,GAAP;AACD;;AACD,SAASC,iBAAT,CAA2BF,EAA3B,EAA+B;AAC7B,SAAO;AAAEA,IAAAA,EAAF;AAAMC,IAAAA,OAAO,EAAE;AAAf,GAAP;AACD;;AACD,IAAIE,gBAAgB,GAAG,IAAIhD,GAAJ,CAAQ,CAC7B,CAACV,EAAE,CAAC2D,UAAH,CAAcC,SAAf,EAA0BN,eAAe,CAAC,CAACO,CAAD,EAAIC,CAAJ,KAAUD,CAAC,GAAGC,CAAf,CAAzC,CAD6B,EAE7B,CAAC9D,EAAE,CAAC2D,UAAH,CAAcI,UAAf,EAA2BT,eAAe,CAAC,CAACO,CAAD,EAAIC,CAAJ,KAAUD,CAAC,GAAGC,CAAf,CAA1C,CAF6B,EAG7B,CAAC9D,EAAE,CAAC2D,UAAH,CAAcK,aAAf,EAA8BV,eAAe,CAAC,CAACO,CAAD,EAAIC,CAAJ,KAAUD,CAAC,GAAGC,CAAf,CAA7C,CAH6B,EAI7B,CAAC9D,EAAE,CAAC2D,UAAH,CAAcM,UAAf,EAA2BX,eAAe,CAAC,CAACO,CAAD,EAAIC,CAAJ,KAAUD,CAAC,GAAGC,CAAf,CAA1C,CAJ6B,EAK7B,CAAC9D,EAAE,CAAC2D,UAAH,CAAcO,YAAf,EAA6BZ,eAAe,CAAC,CAACO,CAAD,EAAIC,CAAJ,KAAUD,CAAC,GAAGC,CAAf,CAA5C,CAL6B,EAM7B,CAAC9D,EAAE,CAAC2D,UAAH,CAAcQ,cAAf,EAA+Bb,eAAe,CAAC,CAACO,CAAD,EAAIC,CAAJ,KAAUD,CAAC,GAAGC,CAAf,CAA9C,CAN6B,EAO7B,CAAC9D,EAAE,CAAC2D,UAAH,CAAcS,QAAf,EAAyBd,eAAe,CAAC,CAACO,CAAD,EAAIC,CAAJ,KAAUD,CAAC,GAAGC,CAAf,CAAxC,CAP6B,EAQ7B,CAAC9D,EAAE,CAAC2D,UAAH,CAAcU,UAAf,EAA2Bf,eAAe,CAAC,CAACO,CAAD,EAAIC,CAAJ,KAAUD,CAAC,GAAGC,CAAf,CAA1C,CAR6B,EAS7B,CAAC9D,EAAE,CAAC2D,UAAH,CAAcW,aAAf,EAA8BhB,eAAe,CAAC,CAACO,CAAD,EAAIC,CAAJ,KAAUD,CAAC,GAAGC,CAAf,CAA7C,CAT6B,EAU7B,CAAC9D,EAAE,CAAC2D,UAAH,CAAcY,mBAAf,EAAoCjB,eAAe,CAAC,CAACO,CAAD,EAAIC,CAAJ,KAAUD,CAAC,IAAIC,CAAhB,CAAnD,CAV6B,EAW7B,CAAC9D,EAAE,CAAC2D,UAAH,CAAca,gBAAf,EAAiClB,eAAe,CAAC,CAACO,CAAD,EAAIC,CAAJ,KAAUD,CAAC,GAAGC,CAAf,CAAhD,CAX6B,EAY7B,CAAC9D,EAAE,CAAC2D,UAAH,CAAcc,sBAAf,EAAuCnB,eAAe,CAAC,CAACO,CAAD,EAAIC,CAAJ,KAAUD,CAAC,IAAIC,CAAhB,CAAtD,CAZ6B,EAa7B,CAAC9D,EAAE,CAAC2D,UAAH,CAAce,iBAAf,EAAkCpB,eAAe,CAAC,CAACO,CAAD,EAAIC,CAAJ,KAAUD,CAAC,IAAIC,CAAhB,CAAjD,CAb6B,EAc7B,CAAC9D,EAAE,CAAC2D,UAAH,CAAcgB,uBAAf,EAAwCrB,eAAe,CAAC,CAACO,CAAD,EAAIC,CAAJ,KAAUD,CAAC,KAAKC,CAAjB,CAAvD,CAd6B,EAe7B,CAAC9D,EAAE,CAAC2D,UAAH,CAAciB,sBAAf,EAAuCtB,eAAe,CAAC,CAACO,CAAD,EAAIC,CAAJ,KAAUD,CAAC,IAAIC,CAAhB,CAAtD,CAf6B,EAgB7B,CAAC9D,EAAE,CAAC2D,UAAH,CAAckB,4BAAf,EAA6CvB,eAAe,CAAC,CAACO,CAAD,EAAIC,CAAJ,KAAUD,CAAC,KAAKC,CAAjB,CAA5D,CAhB6B,EAiB7B,CAAC9D,EAAE,CAAC2D,UAAH,CAAcmB,qBAAf,EAAsCxB,eAAe,CAAC,CAACO,CAAD,EAAIC,CAAJ,KAAUD,CAAC,IAAIC,CAAhB,CAArD,CAjB6B,EAkB7B,CAAC9D,EAAE,CAAC2D,UAAH,CAAcoB,2BAAf,EAA4CzB,eAAe,CAAC,CAACO,CAAD,EAAIC,CAAJ,KAAUD,CAAC,IAAIC,CAAhB,CAA3D,CAlB6B,EAmB7B,CAAC9D,EAAE,CAAC2D,UAAH,CAAcqB,sCAAf,EAAuD1B,eAAe,CAAC,CAACO,CAAD,EAAIC,CAAJ,KAAUD,CAAC,KAAKC,CAAjB,CAAtE,CAnB6B,EAoB7B,CAAC9D,EAAE,CAAC2D,UAAH,CAAcsB,qBAAf,EAAsC3B,eAAe,CAAC,CAACO,CAAD,EAAIC,CAAJ,KAAUoB,IAAI,CAACC,GAAL,CAAStB,CAAT,EAAYC,CAAZ,CAAX,CAArD,CApB6B,EAqB7B,CAAC9D,EAAE,CAAC2D,UAAH,CAAcyB,uBAAf,EAAwC3B,iBAAiB,CAAC,CAACI,CAAD,EAAIC,CAAJ,KAAUD,CAAC,IAAIC,CAAhB,CAAzD,CArB6B,EAsB7B,CAAC9D,EAAE,CAAC2D,UAAH,CAAc0B,WAAf,EAA4B5B,iBAAiB,CAAC,CAACI,CAAD,EAAIC,CAAJ,KAAUD,CAAC,IAAIC,CAAhB,CAA7C,CAtB6B,CAAR,CAAvB;AAwBA,IAAIwB,eAAe,GAAG,IAAI5E,GAAJ,CAAQ,CAC5B,CAACV,EAAE,CAAC2D,UAAH,CAAc4B,UAAf,EAA4B1B,CAAD,IAAO,CAACA,CAAnC,CAD4B,EAE5B,CAAC7D,EAAE,CAAC2D,UAAH,CAAcI,UAAf,EAA4BF,CAAD,IAAO,CAACA,CAAnC,CAF4B,EAG5B,CAAC7D,EAAE,CAAC2D,UAAH,CAAcC,SAAf,EAA2BC,CAAD,IAAO,CAACA,CAAlC,CAH4B,EAI5B,CAAC7D,EAAE,CAAC2D,UAAH,CAAc6B,gBAAf,EAAkC3B,CAAD,IAAO,CAACA,CAAzC,CAJ4B,CAAR,CAAtB;AAMA,IAAI4B,iBAAiB,GAAG,MAAM;AAC5B9H,EAAAA,WAAW,CAAC+H,IAAD,EAAOC,OAAP,EAAgBC,iBAAhB,EAAmC;AAC5C,SAAKF,IAAL,GAAYA,IAAZ;AACA,SAAKC,OAAL,GAAeA,OAAf;AACA,SAAKC,iBAAL,GAAyBA,iBAAzB;AACD;;AACDC,EAAAA,KAAK,CAACjI,IAAD,EAAOkI,OAAP,EAAgB;AACnB,WAAO,KAAKC,eAAL,CAAqBnI,IAArB,EAA2BkI,OAA3B,CAAP;AACD;;AACDC,EAAAA,eAAe,CAACnI,IAAD,EAAOkI,OAAP,EAAgB;AAC7B,QAAIvE,MAAJ;;AACA,QAAI3D,IAAI,CAACoI,IAAL,KAAchG,EAAE,CAAC2D,UAAH,CAAcsC,WAAhC,EAA6C;AAC3C,aAAO,IAAP;AACD,KAFD,MAEO,IAAIrI,IAAI,CAACoI,IAAL,KAAchG,EAAE,CAAC2D,UAAH,CAAcuC,YAAhC,EAA8C;AACnD,aAAO,KAAP;AACD,KAFM,MAEA,IAAItI,IAAI,CAACoI,IAAL,KAAchG,EAAE,CAAC2D,UAAH,CAAcwC,WAAhC,EAA6C;AAClD,aAAO,IAAP;AACD,KAFM,MAEA,IAAInG,EAAE,CAACoG,eAAH,CAAmBxI,IAAnB,CAAJ,EAA8B;AACnC,aAAOA,IAAI,CAACyI,IAAZ;AACD,KAFM,MAEA,IAAIrG,EAAE,CAACsG,+BAAH,CAAmC1I,IAAnC,CAAJ,EAA8C;AACnD,aAAOA,IAAI,CAACyI,IAAZ;AACD,KAFM,MAEA,IAAIrG,EAAE,CAACuG,oBAAH,CAAwB3I,IAAxB,CAAJ,EAAmC;AACxC2D,MAAAA,MAAM,GAAG,KAAKiF,uBAAL,CAA6B5I,IAA7B,EAAmCkI,OAAnC,CAAT;AACD,KAFM,MAEA,IAAI9F,EAAE,CAACyG,gBAAH,CAAoB7I,IAApB,CAAJ,EAA+B;AACpC,aAAO8I,UAAU,CAAC9I,IAAI,CAACyI,IAAN,CAAjB;AACD,KAFM,MAEA,IAAIrG,EAAE,CAAC2G,yBAAH,CAA6B/I,IAA7B,CAAJ,EAAwC;AAC7C2D,MAAAA,MAAM,GAAG,KAAKqF,4BAAL,CAAkChJ,IAAlC,EAAwCkI,OAAxC,CAAT;AACD,KAFM,MAEA,IAAI9F,EAAE,CAAC6G,YAAH,CAAgBjJ,IAAhB,CAAJ,EAA2B;AAChC2D,MAAAA,MAAM,GAAG,KAAKuF,eAAL,CAAqBlJ,IAArB,EAA2BkI,OAA3B,CAAT;AACD,KAFM,MAEA,IAAI9F,EAAE,CAAC+G,0BAAH,CAA8BnJ,IAA9B,CAAJ,EAAyC;AAC9C2D,MAAAA,MAAM,GAAG,KAAKyF,6BAAL,CAAmCpJ,IAAnC,EAAyCkI,OAAzC,CAAT;AACD,KAFM,MAEA,IAAI9F,EAAE,CAACiH,gBAAH,CAAoBrJ,IAApB,CAAJ,EAA+B;AACpC2D,MAAAA,MAAM,GAAG,KAAK2F,mBAAL,CAAyBtJ,IAAzB,EAA+BkI,OAA/B,CAAT;AACD,KAFM,MAEA,IAAI9F,EAAE,CAACmH,uBAAH,CAA2BvJ,IAA3B,CAAJ,EAAsC;AAC3C2D,MAAAA,MAAM,GAAG,KAAK6F,0BAAL,CAAgCxJ,IAAhC,EAAsCkI,OAAtC,CAAT;AACD,KAFM,MAEA,IAAI9F,EAAE,CAACqH,uBAAH,CAA2BzJ,IAA3B,CAAJ,EAAsC;AAC3C2D,MAAAA,MAAM,GAAG,KAAK+F,0BAAL,CAAgC1J,IAAhC,EAAsCkI,OAAtC,CAAT;AACD,KAFM,MAEA,IAAI9F,EAAE,CAACuH,kBAAH,CAAsB3J,IAAtB,CAAJ,EAAiC;AACtC2D,MAAAA,MAAM,GAAG,KAAKiG,qBAAL,CAA2B5J,IAA3B,EAAiCkI,OAAjC,CAAT;AACD,KAFM,MAEA,IAAI9F,EAAE,CAACyH,wBAAH,CAA4B7J,IAA5B,CAAJ,EAAuC;AAC5C2D,MAAAA,MAAM,GAAG,KAAKmG,2BAAL,CAAiC9J,IAAjC,EAAuCkI,OAAvC,CAAT;AACD,KAFM,MAEA,IAAI9F,EAAE,CAAC2H,yBAAH,CAA6B/J,IAA7B,CAAJ,EAAwC;AAC7C2D,MAAAA,MAAM,GAAG,KAAKqG,4BAAL,CAAkChK,IAAlC,EAAwCkI,OAAxC,CAAT;AACD,KAFM,MAEA,IAAI9F,EAAE,CAAC6H,yBAAH,CAA6BjK,IAA7B,CAAJ,EAAwC;AAC7C2D,MAAAA,MAAM,GAAG,KAAKuG,4BAAL,CAAkClK,IAAlC,EAAwCkI,OAAxC,CAAT;AACD,KAFM,MAEA,IAAI9F,EAAE,CAAC+H,cAAH,CAAkBnK,IAAlB,CAAJ,EAA6B;AAClC2D,MAAAA,MAAM,GAAG,KAAKwE,eAAL,CAAqBnI,IAAI,CAACoK,UAA1B,EAAsClC,OAAtC,CAAT;AACD,KAFM,MAEA,IAAI9F,EAAE,CAACiI,mBAAH,CAAuBrK,IAAvB,CAAJ,EAAkC;AACvC2D,MAAAA,MAAM,GAAG,KAAKwE,eAAL,CAAqBnI,IAAI,CAACoK,UAA1B,EAAsClC,OAAtC,CAAT;AACD,KAFM,MAEA,IAAI,KAAKJ,IAAL,CAAUwC,OAAV,CAAkBtK,IAAlB,CAAJ,EAA6B;AAClC2D,MAAAA,MAAM,GAAG,KAAK4G,gBAAL,CAAsBvK,IAAtB,EAA4BkI,OAA5B,CAAT;AACD,KAFM,MAEA;AACL,aAAOpI,YAAY,CAACU,qBAAb,CAAmCR,IAAnC,CAAP;AACD;;AACD,QAAI2D,MAAM,YAAY7D,YAAlB,IAAkC6D,MAAM,CAAC3D,IAAP,KAAgBA,IAAtD,EAA4D;AAC1D,aAAOF,YAAY,CAACK,gBAAb,CAA8BH,IAA9B,EAAoC2D,MAApC,CAAP;AACD;;AACD,WAAOA,MAAP;AACD;;AACDmG,EAAAA,2BAA2B,CAAC9J,IAAD,EAAOkI,OAAP,EAAgB;AACzC,UAAMsC,KAAK,GAAG,EAAd;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGzK,IAAI,CAAC0K,QAAL,CAAcjH,MAAlC,EAA0CgH,CAAC,EAA3C,EAA+C;AAC7C,YAAME,OAAO,GAAG3K,IAAI,CAAC0K,QAAL,CAAcD,CAAd,CAAhB;;AACA,UAAIrI,EAAE,CAACwI,eAAH,CAAmBD,OAAnB,CAAJ,EAAiC;AAC/BH,QAAAA,KAAK,CAAC3G,IAAN,CAAW,GAAG,KAAKgH,kBAAL,CAAwBF,OAAxB,EAAiCzC,OAAjC,CAAd;AACD,OAFD,MAEO;AACLsC,QAAAA,KAAK,CAAC3G,IAAN,CAAW,KAAKsE,eAAL,CAAqBwC,OAArB,EAA8BzC,OAA9B,CAAX;AACD;AACF;;AACD,WAAOsC,KAAP;AACD;;AACDxB,EAAAA,4BAA4B,CAAChJ,IAAD,EAAOkI,OAAP,EAAgB;AAC1C,UAAMrF,GAAG,GAAG,IAAIC,GAAJ,EAAZ;;AACA,SAAK,IAAI2H,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGzK,IAAI,CAAC8K,UAAL,CAAgBrH,MAApC,EAA4CgH,CAAC,EAA7C,EAAiD;AAC/C,YAAMM,QAAQ,GAAG/K,IAAI,CAAC8K,UAAL,CAAgBL,CAAhB,CAAjB;;AACA,UAAIrI,EAAE,CAAC4I,oBAAH,CAAwBD,QAAxB,CAAJ,EAAuC;AACrC,cAAMtI,IAAI,GAAG,KAAKwI,0BAAL,CAAgCF,QAAQ,CAACtI,IAAzC,EAA+CyF,OAA/C,CAAb;;AACA,YAAIzF,IAAI,KAAK,KAAK,CAAlB,EAAqB;AACnB,iBAAO3C,YAAY,CAACK,gBAAb,CAA8BH,IAA9B,EAAoCF,YAAY,CAACO,iBAAb,CAA+B0K,QAAQ,CAACtI,IAAxC,CAApC,CAAP;AACD;;AACDI,QAAAA,GAAG,CAACI,GAAJ,CAAQR,IAAR,EAAc,KAAK0F,eAAL,CAAqB4C,QAAQ,CAACG,WAA9B,EAA2ChD,OAA3C,CAAd;AACD,OAND,MAMO,IAAI9F,EAAE,CAAC+I,6BAAH,CAAiCJ,QAAjC,CAAJ,EAAgD;AACrD,cAAMK,MAAM,GAAG,KAAKrD,OAAL,CAAasD,iCAAb,CAA+CN,QAA/C,CAAf;;AACA,YAAIK,MAAM,KAAK,KAAK,CAAhB,IAAqBA,MAAM,CAACE,gBAAP,KAA4B,KAAK,CAA1D,EAA6D;AAC3DzI,UAAAA,GAAG,CAACI,GAAJ,CAAQ8H,QAAQ,CAACtI,IAAT,CAAcgG,IAAtB,EAA4B3I,YAAY,CAACiB,WAAb,CAAyBgK,QAAzB,CAA5B;AACD,SAFD,MAEO;AACLlI,UAAAA,GAAG,CAACI,GAAJ,CAAQ8H,QAAQ,CAACtI,IAAT,CAAcgG,IAAtB,EAA4B,KAAK8B,gBAAL,CAAsBa,MAAM,CAACE,gBAA7B,EAA+CpD,OAA/C,CAA5B;AACD;AACF,OAPM,MAOA,IAAI9F,EAAE,CAACmJ,kBAAH,CAAsBR,QAAtB,CAAJ,EAAqC;AAC1C,cAAMS,MAAM,GAAG,KAAKrD,eAAL,CAAqB4C,QAAQ,CAACX,UAA9B,EAA0ClC,OAA1C,CAAf;;AACA,YAAIsD,MAAM,YAAY1L,YAAtB,EAAoC;AAClC,iBAAOA,YAAY,CAACK,gBAAb,CAA8BH,IAA9B,EAAoCwL,MAApC,CAAP;AACD,SAFD,MAEO,IAAIA,MAAM,YAAY1I,GAAtB,EAA2B;AAChC0I,UAAAA,MAAM,CAACzI,OAAP,CAAe,CAACpC,KAAD,EAAQ2D,GAAR,KAAgBzB,GAAG,CAACI,GAAJ,CAAQqB,GAAR,EAAa3D,KAAb,CAA/B;AACD,SAFM,MAEA,IAAI6K,MAAM,YAAYnJ,cAAtB,EAAsC;AAC3CmJ,UAAAA,MAAM,CAAC5I,UAAP,GAAoBG,OAApB,CAA4B,CAACpC,KAAD,EAAQ2D,GAAR,KAAgBzB,GAAG,CAACI,GAAJ,CAAQqB,GAAR,EAAa3D,KAAb,CAA5C;AACD,SAFM,MAEA;AACL,iBAAOb,YAAY,CAACK,gBAAb,CAA8BH,IAA9B,EAAoCF,YAAY,CAACY,yBAAb,CAAuCqK,QAAvC,EAAiDS,MAAjD,CAApC,CAAP;AACD;AACF,OAXM,MAWA;AACL,eAAO1L,YAAY,CAACiB,WAAb,CAAyBf,IAAzB,CAAP;AACD;AACF;;AACD,WAAO6C,GAAP;AACD;;AACD+F,EAAAA,uBAAuB,CAAC5I,IAAD,EAAOkI,OAAP,EAAgB;AACrC,UAAMuD,MAAM,GAAG,CAACzL,IAAI,CAAC0L,IAAL,CAAUjD,IAAX,CAAf;;AACA,SAAK,IAAIgC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGzK,IAAI,CAAC2L,aAAL,CAAmBlI,MAAvC,EAA+CgH,CAAC,EAAhD,EAAoD;AAClD,YAAMmB,IAAI,GAAG5L,IAAI,CAAC2L,aAAL,CAAmBlB,CAAnB,CAAb;AACA,YAAM9J,KAAK,GAAGiF,OAAO,CAAC,KAAKqC,KAAL,CAAW2D,IAAI,CAACxB,UAAhB,EAA4BlC,OAA5B,CAAD,EAAuC,MAAMpI,YAAY,CAACO,iBAAb,CAA+BuL,IAAI,CAACxB,UAApC,CAA7C,CAArB;;AACA,UAAIzJ,KAAK,YAAYb,YAArB,EAAmC;AACjC,eAAOA,YAAY,CAACK,gBAAb,CAA8BH,IAA9B,EAAoCW,KAApC,CAAP;AACD;;AACD8K,MAAAA,MAAM,CAAC5H,IAAP,CAAa,GAAElD,KAAM,EAArB,EAAwBiL,IAAI,CAAChG,OAAL,CAAa6C,IAArC;AACD;;AACD,WAAOgD,MAAM,CAACI,IAAP,CAAY,EAAZ,CAAP;AACD;;AACD3C,EAAAA,eAAe,CAAClJ,IAAD,EAAOkI,OAAP,EAAgB;AAC7B,UAAMlF,IAAI,GAAG,KAAK8E,IAAL,CAAUgE,0BAAV,CAAqC9L,IAArC,CAAb;;AACA,QAAIgD,IAAI,KAAK,IAAb,EAAmB;AACjB,UAAIhD,IAAI,CAAC+L,mBAAL,KAA6B3J,EAAE,CAAC2D,UAAH,CAAciG,gBAA/C,EAAiE;AAC/D,eAAO,KAAK,CAAZ;AACD,OAFD,MAEO;AACL,YAAI,KAAKhE,iBAAL,KAA2B,IAA3B,IAAmC,KAAKF,IAAL,CAAUmE,qBAAV,CAAgCjM,IAAhC,MAA0C,IAAjF,EAAuF;AACrF,eAAKgI,iBAAL,CAAuBkE,+BAAvB,CAAuDhE,OAAO,CAACiE,eAA/D;AACD;;AACD,eAAOrM,YAAY,CAACW,qBAAb,CAAmCT,IAAnC,CAAP;AACD;AACF;;AACD,QAAIgD,IAAI,CAACoJ,KAAL,KAAe,IAAnB,EAAyB;AACvB,aAAOlH,uBAAuB,CAAClC,IAAI,CAACoJ,KAAN,CAA9B;AACD,KAFD,MAEO,IAAI/N,qBAAqB,CAAC2E,IAAD,CAArB,IAA+BA,IAAI,CAACqJ,QAAL,KAAkB,IAAjD,IAAyDrJ,IAAI,CAACqJ,QAAL,CAAcjE,IAAd,KAAuB,CAApF,EAAuF;AAC5F,aAAO,KAAKkE,eAAL,CAAqBtJ,IAAI,CAAChD,IAA1B,EAAgCgD,IAAI,CAACqJ,QAAL,CAAcE,WAA9C,EAA2DrE,OAA3D,CAAP;AACD;;AACD,UAAMsE,WAAW,GAAG3M,cAAc,CAACA,cAAc,CAAC,EAAD,EAAKqI,OAAL,CAAf,EAA8BuE,iBAAiB,CAACvE,OAAD,EAAUlI,IAAV,EAAgBgD,IAAhB,CAA/C,CAAlC;;AACA,UAAMW,MAAM,GAAG,KAAK+I,yBAAL,CAA+B1J,IAA/B,EAAqCwJ,WAArC,CAAf;;AACA,QAAI7I,MAAM,YAAY/E,SAAtB,EAAiC;AAC/B,UAAI,CAAC+E,MAAM,CAACgJ,SAAZ,EAAuB;AACrBhJ,QAAAA,MAAM,CAACiJ,aAAP,CAAqB5M,IAArB;AACD;AACF,KAJD,MAIO,IAAI2D,MAAM,YAAY7D,YAAtB,EAAoC;AACzC,aAAOA,YAAY,CAACK,gBAAb,CAA8BH,IAA9B,EAAoC2D,MAApC,CAAP;AACD;;AACD,WAAOA,MAAP;AACD;;AACD4G,EAAAA,gBAAgB,CAACvK,IAAD,EAAOkI,OAAP,EAAgB;AAC9B,QAAI,KAAKF,iBAAL,KAA2B,IAA/B,EAAqC;AACnC,WAAKA,iBAAL,CAAuB6E,aAAvB,CAAqC3E,OAAO,CAACiE,eAA7C,EAA8DnM,IAAI,CAAChB,aAAL,EAA9D;AACD;;AACD,QAAI,KAAK8I,IAAL,CAAUwC,OAAV,CAAkBtK,IAAlB,CAAJ,EAA6B;AAC3B,aAAO,KAAK8M,YAAL,CAAkB9M,IAAlB,EAAwBkI,OAAxB,CAAP;AACD,KAFD,MAEO,IAAI9F,EAAE,CAAC2K,qBAAH,CAAyB/M,IAAzB,CAAJ,EAAoC;AACzC,aAAO,KAAKgN,wBAAL,CAA8BhN,IAA9B,EAAoCkI,OAApC,CAAP;AACD,KAFM,MAEA,IAAI9F,EAAE,CAAC6K,WAAH,CAAejN,IAAf,KAAwBkI,OAAO,CAACgF,KAAR,CAAcxK,GAAd,CAAkB1C,IAAlB,CAA5B,EAAqD;AAC1D,aAAOkI,OAAO,CAACgF,KAAR,CAAcvK,GAAd,CAAkB3C,IAAlB,CAAP;AACD,KAFM,MAEA,IAAIoC,EAAE,CAAC+K,kBAAH,CAAsBnN,IAAtB,CAAJ,EAAiC;AACtC,aAAO,KAAKmI,eAAL,CAAqBnI,IAAI,CAACoK,UAA1B,EAAsClC,OAAtC,CAAP;AACD,KAFM,MAEA,IAAI9F,EAAE,CAACgL,iBAAH,CAAqBpN,IAArB,CAAJ,EAAgC;AACrC,aAAO,KAAKqN,oBAAL,CAA0BrN,IAA1B,EAAgCkI,OAAhC,CAAP;AACD,KAFM,MAEA,IAAI9F,EAAE,CAACkL,YAAH,CAAgBtN,IAAhB,CAAJ,EAA2B;AAChC,aAAO,KAAKuN,eAAL,CAAqBvN,IAArB,EAA2BkI,OAA3B,CAAP;AACD,KAFM,MAEA,IAAI9F,EAAE,CAACoL,gBAAH,CAAoBxN,IAApB,CAAJ,EAA+B;AACpC,aAAO,KAAKyN,mBAAL,CAAyBzN,IAAzB,EAA+BkI,OAA/B,CAAP;AACD,KAFM,MAEA;AACL,aAAO,KAAK4E,YAAL,CAAkB9M,IAAlB,EAAwBkI,OAAxB,CAAP;AACD;AACF;;AACD8E,EAAAA,wBAAwB,CAAChN,IAAD,EAAOkI,OAAP,EAAgB;AACtC,UAAMvH,KAAK,GAAG,KAAKmH,IAAL,CAAU4F,gBAAV,CAA2B1N,IAA3B,CAAd;;AACA,QAAIW,KAAK,KAAK,IAAd,EAAoB;AAClB,aAAO,KAAKwH,eAAL,CAAqBxH,KAArB,EAA4BuH,OAA5B,CAAP;AACD,KAFD,MAEO,IAAIyF,6BAA6B,CAAC3N,IAAD,CAAjC,EAAyC;AAC9C,UAAIA,IAAI,CAAC4N,IAAL,KAAc,KAAK,CAAvB,EAA0B;AACxB,cAAMC,aAAa,GAAG,KAAKC,SAAL,CAAe9N,IAAI,CAAC4N,IAApB,EAA0B1F,OAA1B,CAAtB;;AACA,YAAI,EAAE2F,aAAa,YAAY/N,YAA3B,CAAJ,EAA8C;AAC5C,iBAAO+N,aAAP;AACD;AACF;;AACD,aAAO,KAAKf,YAAL,CAAkB9M,IAAlB,EAAwBkI,OAAxB,CAAP;AACD,KARM,MAQA;AACL,aAAO,KAAK,CAAZ;AACD;AACF;;AACDmF,EAAAA,oBAAoB,CAACrN,IAAD,EAAOkI,OAAP,EAAgB;AAClC,UAAM/E,OAAO,GAAG,KAAK2J,YAAL,CAAkB9M,IAAlB,EAAwBkI,OAAxB,CAAhB;AACA,UAAMrF,GAAG,GAAG,IAAIC,GAAJ,EAAZ;AACA9C,IAAAA,IAAI,CAAC+N,OAAL,CAAahL,OAAb,CAAsBiL,MAAD,IAAY;AAC/B,YAAMvL,IAAI,GAAG,KAAKwI,0BAAL,CAAgC+C,MAAM,CAACvL,IAAvC,EAA6CyF,OAA7C,CAAb;;AACA,UAAIzF,IAAI,KAAK,KAAK,CAAlB,EAAqB;AACnB,cAAMW,QAAQ,GAAG4K,MAAM,CAAC9C,WAAP,IAAsB,KAAKjD,KAAL,CAAW+F,MAAM,CAAC9C,WAAlB,EAA+BhD,OAA/B,CAAvC;AACArF,QAAAA,GAAG,CAACI,GAAJ,CAAQR,IAAR,EAAc,IAAIS,SAAJ,CAAcC,OAAd,EAAuBV,IAAvB,EAA6BW,QAA7B,CAAd;AACD;AACF,KAND;AAOA,WAAOP,GAAP;AACD;;AACDqH,EAAAA,4BAA4B,CAAClK,IAAD,EAAOkI,OAAP,EAAgB;AAC1C,UAAM3E,GAAG,GAAG,KAAK4E,eAAL,CAAqBnI,IAAI,CAACoK,UAA1B,EAAsClC,OAAtC,CAAZ;;AACA,QAAI3E,GAAG,YAAYzD,YAAnB,EAAiC;AAC/B,aAAOA,YAAY,CAACK,gBAAb,CAA8BH,IAA9B,EAAoCuD,GAApC,CAAP;AACD;;AACD,UAAM0K,GAAG,GAAG,KAAK9F,eAAL,CAAqBnI,IAAI,CAACkO,kBAA1B,EAA8ChG,OAA9C,CAAZ;;AACA,QAAI+F,GAAG,YAAYnO,YAAnB,EAAiC;AAC/B,aAAOA,YAAY,CAACK,gBAAb,CAA8BH,IAA9B,EAAoCiO,GAApC,CAAP;AACD;;AACD,QAAI,OAAOA,GAAP,KAAe,QAAf,IAA2B,OAAOA,GAAP,KAAe,QAA9C,EAAwD;AACtD,aAAOnO,YAAY,CAACY,yBAAb,CAAuCV,IAAvC,EAA6CiO,GAA7C,CAAP;AACD;;AACD,WAAO,KAAKE,YAAL,CAAkBnO,IAAlB,EAAwBuD,GAAxB,EAA6B0K,GAA7B,EAAkC/F,OAAlC,CAAP;AACD;;AACDkB,EAAAA,6BAA6B,CAACpJ,IAAD,EAAOkI,OAAP,EAAgB;AAC3C,UAAM3E,GAAG,GAAG,KAAK4E,eAAL,CAAqBnI,IAAI,CAACoK,UAA1B,EAAsClC,OAAtC,CAAZ;AACA,UAAM+F,GAAG,GAAGjO,IAAI,CAACyC,IAAL,CAAUgG,IAAtB;;AACA,QAAIlF,GAAG,YAAYzD,YAAnB,EAAiC;AAC/B,aAAOA,YAAY,CAACK,gBAAb,CAA8BH,IAA9B,EAAoCuD,GAApC,CAAP;AACD;;AACD,WAAO,KAAK4K,YAAL,CAAkBnO,IAAlB,EAAwBuD,GAAxB,EAA6B0K,GAA7B,EAAkC/F,OAAlC,CAAP;AACD;;AACDqF,EAAAA,eAAe,CAACvN,IAAD,EAAOkI,OAAP,EAAgB;AAC7B,UAAMkG,YAAY,GAAG,KAAKtG,IAAL,CAAUuG,kBAAV,CAA6BrO,IAA7B,CAArB;;AACA,QAAIoO,YAAY,KAAK,IAArB,EAA2B;AACzB,aAAOtO,YAAY,CAACiB,WAAb,CAAyBf,IAAzB,CAAP;AACD;;AACD,WAAO,IAAIqC,cAAJ,CAAmB+L,YAAnB,EAAkCpL,IAAD,IAAU;AAChD,UAAIA,IAAI,CAACoJ,KAAL,KAAe,IAAnB,EAAyB;AACvB,eAAOlH,uBAAuB,CAAClC,IAAI,CAACoJ,KAAN,CAA9B;AACD;;AACD,YAAMI,WAAW,GAAG3M,cAAc,CAACA,cAAc,CAAC,EAAD,EAAKqI,OAAL,CAAf,EAA8BuE,iBAAiB,CAACvE,OAAD,EAAUlI,IAAV,EAAgBgD,IAAhB,CAA/C,CAAlC;;AACA,aAAO,KAAK0J,yBAAL,CAA+B1J,IAA/B,EAAqCwJ,WAArC,CAAP;AACD,KANM,CAAP;AAOD;;AACDE,EAAAA,yBAAyB,CAAC1J,IAAD,EAAOwJ,WAAP,EAAoB;AAC3C,WAAOxJ,IAAI,CAACoF,IAAL,KAAc,CAAd,IAAmBpF,IAAI,CAACsL,cAAL,KAAwB,KAAK,CAAhD,IAAqD,CAACpP,aAAa,CAAC8D,IAAI,CAACsL,cAAN,CAAnE,GAA2F,KAAKnG,eAAL,CAAqBnF,IAAI,CAACsL,cAA1B,EAA0C9B,WAA1C,CAA3F,GAAoJ,KAAKjC,gBAAL,CAAsBvH,IAAI,CAAChD,IAA3B,EAAiCwM,WAAjC,CAA3J;AACD;;AACD2B,EAAAA,YAAY,CAACnO,IAAD,EAAOuD,GAAP,EAAY0K,GAAZ,EAAiB/F,OAAjB,EAA0B;AACpC,UAAMqG,QAAQ,GAAI,GAAEN,GAAI,EAAxB;;AACA,QAAI1K,GAAG,YAAYT,GAAnB,EAAwB;AACtB,UAAIS,GAAG,CAACb,GAAJ,CAAQ6L,QAAR,CAAJ,EAAuB;AACrB,eAAOhL,GAAG,CAACZ,GAAJ,CAAQ4L,QAAR,CAAP;AACD,OAFD,MAEO;AACL,eAAO,KAAK,CAAZ;AACD;AACF,KAND,MAMO,IAAIhL,GAAG,YAAYlB,cAAnB,EAAmC;AACxC,aAAOkB,GAAG,CAACf,SAAJ,CAAc+L,QAAd,CAAP;AACD,KAFM,MAEA,IAAIzK,KAAK,CAACC,OAAN,CAAcR,GAAd,CAAJ,EAAwB;AAC7B,UAAI0K,GAAG,KAAK,QAAZ,EAAsB;AACpB,eAAO1K,GAAG,CAACE,MAAX;AACD,OAFD,MAEO,IAAIwK,GAAG,KAAK,OAAZ,EAAqB;AAC1B,eAAO,IAAI3K,mBAAJ,CAAwBC,GAAxB,CAAP;AACD,OAFM,MAEA,IAAI0K,GAAG,KAAK,QAAZ,EAAsB;AAC3B,eAAO,IAAIvK,oBAAJ,CAAyBH,GAAzB,CAAP;AACD;;AACD,UAAI,OAAO0K,GAAP,KAAe,QAAf,IAA2B,CAACO,MAAM,CAACC,SAAP,CAAiBR,GAAjB,CAAhC,EAAuD;AACrD,eAAOnO,YAAY,CAACY,yBAAb,CAAuCV,IAAvC,EAA6CiO,GAA7C,CAAP;AACD;;AACD,aAAO1K,GAAG,CAAC0K,GAAD,CAAV;AACD,KAZM,MAYA,IAAI,OAAO1K,GAAP,KAAe,QAAf,IAA2B0K,GAAG,KAAK,QAAvC,EAAiD;AACtD,aAAO,IAAIjK,qBAAJ,CAA0BT,GAA1B,CAAP;AACD,KAFM,MAEA,IAAIA,GAAG,YAAY3E,SAAnB,EAA8B;AACnC,YAAM2B,GAAG,GAAGgD,GAAG,CAACvD,IAAhB;;AACA,UAAI,KAAK8H,IAAL,CAAUwC,OAAV,CAAkB/J,GAAlB,CAAJ,EAA4B;AAC1B,cAAMmO,MAAM,GAAGC,YAAY,CAACzG,OAAD,EAAU3E,GAAG,CAACqL,qBAAd,CAA3B;AACA,YAAIjO,KAAK,GAAG,KAAK,CAAjB;AACA,cAAMqN,MAAM,GAAG,KAAKlG,IAAL,CAAU+G,iBAAV,CAA4BtO,GAA5B,EAAiCuO,IAAjC,CAAuCC,OAAD,IAAaA,OAAO,CAACC,QAAR,IAAoBD,OAAO,CAACtM,IAAR,KAAiB8L,QAAxF,CAAf;;AACA,YAAIP,MAAM,KAAK,KAAK,CAApB,EAAuB;AACrB,cAAIA,MAAM,CAACrN,KAAP,KAAiB,IAArB,EAA2B;AACzBA,YAAAA,KAAK,GAAG,KAAKwH,eAAL,CAAqB6F,MAAM,CAACrN,KAA5B,EAAmCuH,OAAnC,CAAR;AACD,WAFD,MAEO,IAAI8F,MAAM,CAACM,cAAP,KAA0B,IAA9B,EAAoC;AACzC3N,YAAAA,KAAK,GAAG,IAAI/B,SAAJ,CAAcoP,MAAM,CAACM,cAArB,EAAqCI,MAArC,CAAR;AACD,WAFM,MAEA,IAAIV,MAAM,CAAChO,IAAX,EAAiB;AACtBW,YAAAA,KAAK,GAAG,IAAI/B,SAAJ,CAAcoP,MAAM,CAAChO,IAArB,EAA2B0O,MAA3B,CAAR;AACD;AACF;;AACD,eAAO/N,KAAP;AACD,OAdD,MAcO,IAAIzB,aAAa,CAACqB,GAAD,CAAjB,EAAwB;AAC7B,eAAOT,YAAY,CAACK,gBAAb,CAA8BH,IAA9B,EAAoCF,YAAY,CAACQ,qBAAb,CAAmCC,GAAnC,EAAwCgD,GAAxC,CAApC,CAAP;AACD;AACF,KAnBM,MAmBA,IAAIA,GAAG,YAAYzD,YAAnB,EAAiC;AACtC,aAAOA,YAAY,CAACK,gBAAb,CAA8BH,IAA9B,EAAoCuD,GAApC,CAAP;AACD;;AACD,WAAOzD,YAAY,CAACiB,WAAb,CAAyBf,IAAzB,CAAP;AACD;;AACDsJ,EAAAA,mBAAmB,CAACtJ,IAAD,EAAOkI,OAAP,EAAgB;AACjC,UAAM3E,GAAG,GAAG,KAAK4E,eAAL,CAAqBnI,IAAI,CAACoK,UAA1B,EAAsClC,OAAtC,CAAZ;;AACA,QAAI3E,GAAG,YAAYzD,YAAnB,EAAiC;AAC/B,aAAOA,YAAY,CAACK,gBAAb,CAA8BH,IAA9B,EAAoCuD,GAApC,CAAP;AACD;;AACD,QAAIA,GAAG,YAAYF,OAAnB,EAA4B;AAC1B,aAAOE,GAAG,CAAChB,QAAJ,CAAavC,IAAb,EAAmB,KAAKiP,yBAAL,CAA+BjP,IAA/B,EAAqCkI,OAArC,CAAnB,CAAP;AACD;;AACD,QAAI,EAAE3E,GAAG,YAAY3E,SAAjB,CAAJ,EAAiC;AAC/B,aAAOkB,YAAY,CAACY,yBAAb,CAAuCV,IAAI,CAACoK,UAA5C,EAAwD7G,GAAxD,CAAP;AACD;;AACD,UAAM1C,EAAE,GAAG,KAAKiH,IAAL,CAAUoH,uBAAV,CAAkC3L,GAAG,CAACvD,IAAtC,CAAX;;AACA,QAAIa,EAAE,KAAK,IAAX,EAAiB;AACf,aAAOf,YAAY,CAACY,yBAAb,CAAuCV,IAAI,CAACoK,UAA5C,EAAwD7G,GAAxD,CAAP;AACD;;AACD,QAAI,CAAC4L,2BAA2B,CAAC5L,GAAD,CAAhC,EAAuC;AACrC,aAAOzD,YAAY,CAACY,yBAAb,CAAuCV,IAAI,CAACoK,UAA5C,EAAwD7G,GAAxD,CAAP;AACD;;AACD,QAAI1C,EAAE,CAACuO,IAAH,KAAY,IAAhB,EAAsB;AACpB,UAAIC,IAAI,GAAG,IAAX;;AACA,UAAInH,OAAO,CAACoH,uBAAZ,EAAqC;AACnCD,QAAAA,IAAI,GAAGnH,OAAO,CAACoH,uBAAR,CAAgC/L,GAAhC,EAAqCvD,IAAI,CAACuP,SAA1C,CAAP;AACD;;AACD,UAAIF,IAAI,KAAK,IAAb,EAAmB;AACjB,eAAOvP,YAAY,CAACK,gBAAb,CAA8BH,IAA9B,EAAoCF,YAAY,CAACQ,qBAAb,CAAmCN,IAAI,CAACoK,UAAxC,EAAoD7G,GAApD,CAApC,CAAP;AACD;;AACD,UAAI8L,IAAI,CAACrQ,aAAL,OAAyBgB,IAAI,CAACoK,UAAL,CAAgBpL,aAAhB,EAAzB,IAA4DuE,GAAG,CAACqL,qBAAJ,KAA8B,IAA9F,EAAoG;AAClG1G,QAAAA,OAAO,GAAGtI,aAAa,CAACC,cAAc,CAAC,EAAD,EAAKqI,OAAL,CAAf,EAA8B;AACnDsH,UAAAA,kBAAkB,EAAEjM,GAAG,CAACqL,qBAAJ,CAA0Ba,SADK;AAEnDC,UAAAA,iBAAiB,EAAEnM,GAAG,CAACqL,qBAAJ,CAA0Bc;AAFM,SAA9B,CAAvB;AAID;;AACD,aAAO,KAAKC,kBAAL,CAAwBN,IAAxB,EAA8BnH,OAA9B,CAAP;AACD;;AACD,QAAI0H,GAAG,GAAG,KAAKC,iBAAL,CAAuB7P,IAAvB,EAA6Ba,EAA7B,EAAiCqH,OAAjC,CAAV;;AACA,QAAI0H,GAAG,YAAY9P,YAAf,IAA+BoI,OAAO,CAACoH,uBAAR,KAAoC,KAAK,CAA5E,EAA+E;AAC7E,YAAMQ,OAAO,GAAG5H,OAAO,CAACoH,uBAAR,CAAgC/L,GAAhC,EAAqCvD,IAAI,CAACuP,SAA1C,CAAhB;;AACA,UAAIO,OAAO,KAAK,IAAhB,EAAsB;AACpB,cAAMC,MAAM,GAAG,KAAKJ,kBAAL,CAAwBG,OAAxB,EAAiC5H,OAAjC,CAAf;;AACA,YAAI,EAAE6H,MAAM,YAAYjQ,YAApB,CAAJ,EAAuC;AACrC8P,UAAAA,GAAG,GAAGG,MAAN;AACD;AACF;AACF;;AACD,WAAOH,GAAP;AACD;;AACDD,EAAAA,kBAAkB,CAACN,IAAD,EAAOnH,OAAP,EAAgB;AAChC,UAAM0H,GAAG,GAAG,KAAKzH,eAAL,CAAqBkH,IAArB,EAA2BnH,OAA3B,CAAZ;;AACA,QAAI0H,GAAG,YAAYhR,SAAnB,EAA8B;AAC5BgR,MAAAA,GAAG,CAACjD,SAAJ,GAAgB,IAAhB;AACD;;AACD,WAAOiD,GAAP;AACD;;AACDC,EAAAA,iBAAiB,CAAC7P,IAAD,EAAOa,EAAP,EAAWqH,OAAX,EAAoB;AACnC,QAAIrH,EAAE,CAACuO,IAAH,KAAY,IAAhB,EAAsB;AACpB,aAAOtP,YAAY,CAACiB,WAAb,CAAyBf,IAAzB,CAAP;AACD,KAFD,MAEO,IAAIa,EAAE,CAACuO,IAAH,CAAQ3L,MAAR,KAAmB,CAAnB,IAAwB,CAACrB,EAAE,CAAC4N,iBAAH,CAAqBnP,EAAE,CAACuO,IAAH,CAAQ,CAAR,CAArB,CAA7B,EAA+D;AACpE,aAAOtP,YAAY,CAACc,uBAAb,CAAqCZ,IAArC,EAA2Ca,EAA3C,CAAP;AACD;;AACD,UAAMoP,GAAG,GAAGpP,EAAE,CAACuO,IAAH,CAAQ,CAAR,CAAZ;AACA,UAAM5L,IAAI,GAAG,KAAKyL,yBAAL,CAA+BjP,IAA/B,EAAqCkI,OAArC,CAAb;AACA,UAAMgI,QAAQ,GAAG,IAAIpN,GAAJ,EAAjB;;AACA,UAAMqN,aAAa,GAAGvQ,aAAa,CAACC,cAAc,CAAC,EAAD,EAAKqI,OAAL,CAAf,EAA8B;AAAEgF,MAAAA,KAAK,EAAEgD;AAAT,KAA9B,CAAnC;;AACArP,IAAAA,EAAE,CAACuP,UAAH,CAAcrN,OAAd,CAAsB,CAACsN,KAAD,EAAQC,KAAR,KAAkB;AACtC,UAAI1M,GAAG,GAAGJ,IAAI,CAAC8M,KAAD,CAAd;;AACA,UAAID,KAAK,CAACrQ,IAAN,CAAWuQ,cAAX,KAA8B,KAAK,CAAvC,EAA0C;AACxC3M,QAAAA,GAAG,GAAGJ,IAAI,CAACgN,KAAL,CAAWF,KAAX,CAAN;AACD;;AACD,UAAI1M,GAAG,KAAK,KAAK,CAAb,IAAkByM,KAAK,CAACnF,WAAN,KAAsB,IAA5C,EAAkD;AAChDtH,QAAAA,GAAG,GAAG,KAAKuE,eAAL,CAAqBkI,KAAK,CAACnF,WAA3B,EAAwCiF,aAAxC,CAAN;AACD;;AACDD,MAAAA,QAAQ,CAACjN,GAAT,CAAaoN,KAAK,CAACrQ,IAAnB,EAAyB4D,GAAzB;AACD,KATD;AAUA,WAAOqM,GAAG,CAAC7F,UAAJ,KAAmB,KAAK,CAAxB,GAA4B,KAAKjC,eAAL,CAAqB8H,GAAG,CAAC7F,UAAzB,EAAqC+F,aAArC,CAA5B,GAAkF,KAAK,CAA9F;AACD;;AACD3G,EAAAA,0BAA0B,CAACxJ,IAAD,EAAOkI,OAAP,EAAgB;AACxC,UAAMuI,SAAS,GAAG,KAAKtI,eAAL,CAAqBnI,IAAI,CAACyQ,SAA1B,EAAqCvI,OAArC,CAAlB;;AACA,QAAIuI,SAAS,YAAY3Q,YAAzB,EAAuC;AACrC,aAAOA,YAAY,CAACK,gBAAb,CAA8BH,IAA9B,EAAoCyQ,SAApC,CAAP;AACD;;AACD,QAAIA,SAAJ,EAAe;AACb,aAAO,KAAKtI,eAAL,CAAqBnI,IAAI,CAAC0Q,QAA1B,EAAoCxI,OAApC,CAAP;AACD,KAFD,MAEO;AACL,aAAO,KAAKC,eAAL,CAAqBnI,IAAI,CAAC2Q,SAA1B,EAAqCzI,OAArC,CAAP;AACD;AACF;;AACDwB,EAAAA,0BAA0B,CAAC1J,IAAD,EAAOkI,OAAP,EAAgB;AACxC,UAAM0I,YAAY,GAAG5Q,IAAI,CAAC6Q,QAA1B;;AACA,QAAI,CAACnJ,eAAe,CAAChF,GAAhB,CAAoBkO,YAApB,CAAL,EAAwC;AACtC,aAAO9Q,YAAY,CAACU,qBAAb,CAAmCR,IAAnC,CAAP;AACD;;AACD,UAAM2F,EAAE,GAAG+B,eAAe,CAAC/E,GAAhB,CAAoBiO,YAApB,CAAX;AACA,UAAMjQ,KAAK,GAAG,KAAKwH,eAAL,CAAqBnI,IAAI,CAAC8Q,OAA1B,EAAmC5I,OAAnC,CAAd;;AACA,QAAIvH,KAAK,YAAYb,YAArB,EAAmC;AACjC,aAAOA,YAAY,CAACK,gBAAb,CAA8BH,IAA9B,EAAoCW,KAApC,CAAP;AACD,KAFD,MAEO;AACL,aAAOgF,EAAE,CAAChF,KAAD,CAAT;AACD;AACF;;AACDiJ,EAAAA,qBAAqB,CAAC5J,IAAD,EAAOkI,OAAP,EAAgB;AACnC,UAAM6I,SAAS,GAAG/Q,IAAI,CAACgR,aAAL,CAAmB5I,IAArC;;AACA,QAAI,CAACtC,gBAAgB,CAACpD,GAAjB,CAAqBqO,SAArB,CAAL,EAAsC;AACpC,aAAOjR,YAAY,CAACU,qBAAb,CAAmCR,IAAnC,CAAP;AACD;;AACD,UAAMiR,QAAQ,GAAGnL,gBAAgB,CAACnD,GAAjB,CAAqBoO,SAArB,CAAjB;AACA,QAAIxN,GAAJ,EAAS0K,GAAT;;AACA,QAAIgD,QAAQ,CAACrL,OAAb,EAAsB;AACpBrC,MAAAA,GAAG,GAAGqC,OAAO,CAAC,KAAKuC,eAAL,CAAqBnI,IAAI,CAACkR,IAA1B,EAAgChJ,OAAhC,CAAD,EAA4CvH,KAAD,IAAWb,YAAY,CAACY,yBAAb,CAAuCV,IAAI,CAACkR,IAA5C,EAAkDvQ,KAAlD,CAAtD,CAAb;AACAsN,MAAAA,GAAG,GAAGrI,OAAO,CAAC,KAAKuC,eAAL,CAAqBnI,IAAI,CAACmR,KAA1B,EAAiCjJ,OAAjC,CAAD,EAA6CvH,KAAD,IAAWb,YAAY,CAACY,yBAAb,CAAuCV,IAAI,CAACmR,KAA5C,EAAmDxQ,KAAnD,CAAvD,CAAb;AACD,KAHD,MAGO;AACL4C,MAAAA,GAAG,GAAG,KAAK4E,eAAL,CAAqBnI,IAAI,CAACkR,IAA1B,EAAgChJ,OAAhC,CAAN;AACA+F,MAAAA,GAAG,GAAG,KAAK9F,eAAL,CAAqBnI,IAAI,CAACmR,KAA1B,EAAiCjJ,OAAjC,CAAN;AACD;;AACD,QAAI3E,GAAG,YAAYzD,YAAnB,EAAiC;AAC/B,aAAOA,YAAY,CAACK,gBAAb,CAA8BH,IAA9B,EAAoCuD,GAApC,CAAP;AACD,KAFD,MAEO,IAAI0K,GAAG,YAAYnO,YAAnB,EAAiC;AACtC,aAAOA,YAAY,CAACK,gBAAb,CAA8BH,IAA9B,EAAoCiO,GAApC,CAAP;AACD,KAFM,MAEA;AACL,aAAOgD,QAAQ,CAACtL,EAAT,CAAYpC,GAAZ,EAAiB0K,GAAjB,CAAP;AACD;AACF;;AACDjE,EAAAA,4BAA4B,CAAChK,IAAD,EAAOkI,OAAP,EAAgB;AAC1C,WAAO,KAAKC,eAAL,CAAqBnI,IAAI,CAACoK,UAA1B,EAAsClC,OAAtC,CAAP;AACD;;AACD+G,EAAAA,yBAAyB,CAACjP,IAAD,EAAOkI,OAAP,EAAgB;AACvC,UAAM1E,IAAI,GAAG,EAAb;;AACA,SAAK,MAAMI,GAAX,IAAkB5D,IAAI,CAACuP,SAAvB,EAAkC;AAChC,UAAInN,EAAE,CAACwI,eAAH,CAAmBhH,GAAnB,CAAJ,EAA6B;AAC3BJ,QAAAA,IAAI,CAACK,IAAL,CAAU,GAAG,KAAKgH,kBAAL,CAAwBjH,GAAxB,EAA6BsE,OAA7B,CAAb;AACD,OAFD,MAEO;AACL1E,QAAAA,IAAI,CAACK,IAAL,CAAU,KAAKsE,eAAL,CAAqBvE,GAArB,EAA0BsE,OAA1B,CAAV;AACD;AACF;;AACD,WAAO1E,IAAP;AACD;;AACDqH,EAAAA,kBAAkB,CAAC7K,IAAD,EAAOkI,OAAP,EAAgB;AAChC,UAAMsD,MAAM,GAAG,KAAKrD,eAAL,CAAqBnI,IAAI,CAACoK,UAA1B,EAAsClC,OAAtC,CAAf;;AACA,QAAIsD,MAAM,YAAY1L,YAAtB,EAAoC;AAClC,aAAO,CAACA,YAAY,CAACK,gBAAb,CAA8BH,IAA9B,EAAoCwL,MAApC,CAAD,CAAP;AACD,KAFD,MAEO,IAAI,CAAC1H,KAAK,CAACC,OAAN,CAAcyH,MAAd,CAAL,EAA4B;AACjC,aAAO,CAAC1L,YAAY,CAACY,yBAAb,CAAuCV,IAAvC,EAA6CwL,MAA7C,CAAD,CAAP;AACD,KAFM,MAEA;AACL,aAAOA,MAAP;AACD;AACF;;AACDiC,EAAAA,mBAAmB,CAACzN,IAAD,EAAOkI,OAAP,EAAgB;AACjC,UAAMkJ,IAAI,GAAG,EAAb;AACA,QAAIC,kBAAkB,GAAGrR,IAAzB;;AACA,WAAOoC,EAAE,CAACoL,gBAAH,CAAoB6D,kBAApB,KAA2CjP,EAAE,CAACkP,qBAAH,CAAyBD,kBAAzB,CAA3C,IAA2FjP,EAAE,CAACmP,sBAAH,CAA0BF,kBAA1B,CAAlG,EAAiJ;AAC/I,UAAIjP,EAAE,CAACoL,gBAAH,CAAoB6D,kBAApB,CAAJ,EAA6C;AAC3CD,QAAAA,IAAI,CAACI,OAAL,CAAaH,kBAAb;AACD;;AACDA,MAAAA,kBAAkB,GAAGA,kBAAkB,CAACI,MAAxC;AACD;;AACD,QAAI,CAACrP,EAAE,CAAC2K,qBAAH,CAAyBsE,kBAAzB,CAAD,IAAiDA,kBAAkB,CAACnG,WAAnB,KAAmC,KAAK,CAA7F,EAAgG;AAC9F,aAAOpL,YAAY,CAACiB,WAAb,CAAyBf,IAAzB,CAAP;AACD;;AACD,QAAIW,KAAK,GAAG,KAAKsH,KAAL,CAAWoJ,kBAAkB,CAACnG,WAA9B,EAA2ChD,OAA3C,CAAZ;;AACA,SAAK,MAAMyC,OAAX,IAAsByG,IAAtB,EAA4B;AAC1B,UAAI9M,GAAJ;;AACA,UAAIlC,EAAE,CAACkP,qBAAH,CAAyB3G,OAAO,CAAC8G,MAAjC,CAAJ,EAA8C;AAC5CnN,QAAAA,GAAG,GAAGqG,OAAO,CAAC8G,MAAR,CAAe/G,QAAf,CAAwBgH,OAAxB,CAAgC/G,OAAhC,CAAN;AACD,OAFD,MAEO;AACL,cAAMlI,IAAI,GAAGkI,OAAO,CAACgH,YAAR,IAAwBhH,OAAO,CAAClI,IAA7C;;AACA,YAAIL,EAAE,CAAC6G,YAAH,CAAgBxG,IAAhB,CAAJ,EAA2B;AACzB6B,UAAAA,GAAG,GAAG7B,IAAI,CAACgG,IAAX;AACD,SAFD,MAEO;AACL,iBAAO3I,YAAY,CAACiB,WAAb,CAAyB4J,OAAzB,CAAP;AACD;AACF;;AACDhK,MAAAA,KAAK,GAAG,KAAKwN,YAAL,CAAkBxD,OAAlB,EAA2BhK,KAA3B,EAAkC2D,GAAlC,EAAuC4D,OAAvC,CAAR;;AACA,UAAIvH,KAAK,YAAYb,YAArB,EAAmC;AACjC,eAAOa,KAAP;AACD;AACF;;AACD,WAAOA,KAAP;AACD;;AACDsK,EAAAA,0BAA0B,CAACjL,IAAD,EAAOkI,OAAP,EAAgB;AACxC,QAAI9F,EAAE,CAAC6G,YAAH,CAAgBjJ,IAAhB,KAAyBoC,EAAE,CAACoG,eAAH,CAAmBxI,IAAnB,CAAzB,IAAqDoC,EAAE,CAACyG,gBAAH,CAAoB7I,IAApB,CAAzD,EAAoF;AAClF,aAAOA,IAAI,CAACyI,IAAZ;AACD,KAFD,MAEO,IAAIrG,EAAE,CAACwP,sBAAH,CAA0B5R,IAA1B,CAAJ,EAAqC;AAC1C,YAAM6R,QAAQ,GAAG,KAAK1J,eAAL,CAAqBnI,IAAI,CAACoK,UAA1B,EAAsClC,OAAtC,CAAjB;AACA,aAAO,OAAO2J,QAAP,KAAoB,QAApB,GAA+BA,QAA/B,GAA0C,KAAK,CAAtD;AACD,KAHM,MAGA;AACL,aAAO,KAAK,CAAZ;AACD;AACF;;AACDvF,EAAAA,eAAe,CAACtM,IAAD,EAAOuM,WAAP,EAAoBrE,OAApB,EAA6B;AAC1C,UAAM/E,OAAO,GAAG,KAAK2J,YAAL,CAAkB9M,IAAlB,EAAwBkI,OAAxB,CAAhB;AACA,UAAMrF,GAAG,GAAG,IAAIC,GAAJ,EAAZ;AACAyJ,IAAAA,WAAW,CAACxJ,OAAZ,CAAqBiL,MAAD,IAAY;AAC9B,YAAMvL,IAAI,GAAG,KAAKwI,0BAAL,CAAgC+C,MAAM,CAACvL,IAAvC,EAA6CyF,OAA7C,CAAb;;AACA,UAAIzF,IAAI,KAAK,KAAK,CAAlB,EAAqB;AACnB,cAAMW,QAAQ,GAAG,KAAK6E,KAAL,CAAW+F,MAAM,CAAC9C,WAAlB,EAA+BhD,OAA/B,CAAjB;AACArF,QAAAA,GAAG,CAACI,GAAJ,CAAQR,IAAR,EAAc,IAAIS,SAAJ,CAAcC,OAAd,EAAuBV,IAAvB,EAA6BW,QAA7B,CAAd;AACD;AACF,KAND;AAOA,WAAOP,GAAP;AACD;;AACDiK,EAAAA,YAAY,CAAC9M,IAAD,EAAOkI,OAAP,EAAgB;AAC1B,WAAO,IAAItJ,SAAJ,CAAcoB,IAAd,EAAoB2O,YAAY,CAACzG,OAAD,CAAhC,CAAP;AACD;;AACD4F,EAAAA,SAAS,CAAC9N,IAAD,EAAOkI,OAAP,EAAgB;AACvB,QAAI9F,EAAE,CAAC0P,iBAAH,CAAqB9R,IAArB,CAAJ,EAAgC;AAC9B,aAAO,KAAKmI,eAAL,CAAqBnI,IAAI,CAAC4F,OAA1B,EAAmCsC,OAAnC,CAAP;AACD,KAFD,MAEO,IAAI9F,EAAE,CAAC2P,eAAH,CAAmB/R,IAAnB,CAAJ,EAA8B;AACnC,aAAO,KAAKgS,cAAL,CAAoBhS,IAApB,EAA0BkI,OAA1B,CAAP;AACD,KAFM,MAEA,IAAI9F,EAAE,CAAC6P,kBAAH,CAAsBjS,IAAtB,CAAJ,EAAiC;AACtC,aAAO,KAAK8N,SAAL,CAAe9N,IAAI,CAAC4N,IAApB,EAA0B1F,OAA1B,CAAP;AACD;;AACD,WAAOpI,YAAY,CAACgB,eAAb,CAA6Bd,IAA7B,CAAP;AACD;;AACDgS,EAAAA,cAAc,CAAChS,IAAD,EAAOkI,OAAP,EAAgB;AAC5B,UAAM0H,GAAG,GAAG,EAAZ;;AACA,SAAK,MAAMsC,IAAX,IAAmBlS,IAAI,CAAC0K,QAAxB,EAAkC;AAChCkF,MAAAA,GAAG,CAAC/L,IAAJ,CAAS,KAAKiK,SAAL,CAAeoE,IAAf,EAAqBhK,OAArB,CAAT;AACD;;AACD,WAAO0H,GAAP;AACD;;AAnf2B,CAA9B;;AAqfA,SAAST,2BAAT,CAAqC5O,GAArC,EAA0C;AACxC,SAAO6B,EAAE,CAAC+P,qBAAH,CAAyB5R,GAAG,CAACP,IAA7B,KAAsCoC,EAAE,CAACgQ,mBAAH,CAAuB7R,GAAG,CAACP,IAA3B,CAAtC,IAA0EoC,EAAE,CAACiQ,oBAAH,CAAwB9R,GAAG,CAACP,IAA5B,CAAjF;AACD;;AACD,SAAS4F,OAAT,CAAiBjF,KAAjB,EAAwB2R,MAAxB,EAAgC;AAC9B,MAAI3R,KAAK,YAAYuC,SAArB,EAAgC;AAC9BvC,IAAAA,KAAK,GAAGA,KAAK,CAACyC,QAAd;AACD;;AACD,MAAIzC,KAAK,YAAYb,YAAjB,IAAiCa,KAAK,KAAK,IAA3C,IAAmDA,KAAK,KAAK,KAAK,CAAlE,IAAuE,OAAOA,KAAP,KAAiB,QAAxF,IAAoG,OAAOA,KAAP,KAAiB,QAArH,IAAiI,OAAOA,KAAP,KAAiB,SAAtJ,EAAiK;AAC/J,WAAOA,KAAP;AACD;;AACD,SAAO2R,MAAM,CAAC3R,KAAD,CAAb;AACD;;AACD,SAASgN,6BAAT,CAAuC3N,IAAvC,EAA6C;AAC3C,MAAIA,IAAI,CAACyR,MAAL,KAAgB,KAAK,CAArB,IAA0B,CAACrP,EAAE,CAACmQ,yBAAH,CAA6BvS,IAAI,CAACyR,MAAlC,CAA/B,EAA0E;AACxE,WAAO,KAAP;AACD;;AACD,QAAMe,QAAQ,GAAGxS,IAAI,CAACyR,MAAtB;;AACA,MAAIe,QAAQ,CAACf,MAAT,KAAoB,KAAK,CAAzB,IAA8B,CAACrP,EAAE,CAACqQ,mBAAH,CAAuBD,QAAQ,CAACf,MAAhC,CAAnC,EAA4E;AAC1E,WAAO,KAAP;AACD;;AACD,QAAMiB,OAAO,GAAGF,QAAQ,CAACf,MAAzB;AACA,SAAOiB,OAAO,CAACC,SAAR,KAAsB,KAAK,CAA3B,IAAgCD,OAAO,CAACC,SAAR,CAAkBC,IAAlB,CAAwBC,GAAD,IAASA,GAAG,CAACzK,IAAJ,KAAahG,EAAE,CAAC2D,UAAH,CAAc+M,cAA3D,CAAvC;AACD;;AACD,IAAIC,KAAK,GAAG,EAAZ;;AACA,SAAStG,iBAAT,CAA2BuG,QAA3B,EAAqChT,IAArC,EAA2CgD,IAA3C,EAAiD;AAC/C,MAAIA,IAAI,CAACiQ,SAAL,KAAmB,IAAnB,IAA2BjQ,IAAI,CAACiQ,SAAL,KAAmBD,QAAQ,CAACxD,kBAA3D,EAA+E;AAC7E,WAAO;AACLA,MAAAA,kBAAkB,EAAExM,IAAI,CAACiQ,SADpB;AAELvD,MAAAA,iBAAiB,EAAE1P,IAAI,CAAChB,aAAL,GAAqBkU;AAFnC,KAAP;AAID,GALD,MAKO;AACL,WAAOH,KAAP;AACD;AACF;;AACD,SAASpE,YAAT,CAAsBzG,OAAtB,EAA+BiL,QAAQ,GAAG,IAA1C,EAAgD;AAC9C,MAAI1D,SAAS,GAAGvH,OAAO,CAACsH,kBAAxB;;AACA,MAAI2D,QAAQ,KAAK,IAAjB,EAAuB;AACrB1D,IAAAA,SAAS,GAAG0D,QAAQ,CAAC1D,SAArB;AACD;;AACD,MAAIA,SAAS,KAAK,IAAlB,EAAwB;AACtB,WAAO;AACLA,MAAAA,SADK;AAELC,MAAAA,iBAAiB,EAAExH,OAAO,CAACwH;AAFtB,KAAP;AAID,GALD,MAKO;AACL,WAAO,IAAP;AACD;AACF,C,CAED;;;AACA,IAAI0D,gBAAgB,GAAG,MAAM;AAC3BrT,EAAAA,WAAW,CAAC+H,IAAD,EAAOC,OAAP,EAAgBC,iBAAhB,EAAmC;AAC5C,SAAKF,IAAL,GAAYA,IAAZ;AACA,SAAKC,OAAL,GAAeA,OAAf;AACA,SAAKC,iBAAL,GAAyBA,iBAAzB;AACD;;AACDzF,EAAAA,QAAQ,CAAC8M,IAAD,EAAOC,uBAAP,EAAgC;AACtC,UAAM+D,WAAW,GAAG,IAAIxL,iBAAJ,CAAsB,KAAKC,IAA3B,EAAiC,KAAKC,OAAtC,EAA+C,KAAKC,iBAApD,CAApB;AACA,UAAMsL,UAAU,GAAGjE,IAAI,CAACrQ,aAAL,EAAnB;AACA,WAAOqU,WAAW,CAACpL,KAAZ,CAAkBoH,IAAlB,EAAwB;AAC7BlD,MAAAA,eAAe,EAAEmH,UADY;AAE7B9D,MAAAA,kBAAkB,EAAE,IAFS;AAG7BE,MAAAA,iBAAiB,EAAE4D,UAAU,CAACJ,QAHD;AAI7BhG,MAAAA,KAAK,EAAE,IAAIpK,GAAJ,EAJsB;AAK7BwM,MAAAA;AAL6B,KAAxB,CAAP;AAOD;;AAhB0B,CAA7B,C,CAmBA;;AACA,OAAOiE,GAAP,MAAgB,YAAhB,C,CAEA;;AACA,IAAIC,SAAJ;;AACA,CAAC,UAASC,UAAT,EAAqB;AACpBA,EAAAA,UAAU,CAACA,UAAU,CAAC,2BAAD,CAAV,GAA0C,IAA3C,CAAV,GAA6D,2BAA7D;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,uBAAD,CAAV,GAAsC,IAAvC,CAAV,GAAyD,uBAAzD;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,sBAAD,CAAV,GAAqC,IAAtC,CAAV,GAAwD,sBAAxD;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,8BAAD,CAAV,GAA6C,IAA9C,CAAV,GAAgE,8BAAhE;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,sBAAD,CAAV,GAAqC,IAAtC,CAAV,GAAwD,sBAAxD;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,qBAAD,CAAV,GAAoC,IAArC,CAAV,GAAuD,qBAAvD;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,sBAAD,CAAV,GAAqC,IAAtC,CAAV,GAAwD,sBAAxD;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,mBAAD,CAAV,GAAkC,IAAnC,CAAV,GAAqD,mBAArD;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,4BAAD,CAAV,GAA2C,IAA5C,CAAV,GAA8D,4BAA9D;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,mBAAD,CAAV,GAAkC,IAAnC,CAAV,GAAqD,mBAArD;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,qBAAD,CAAV,GAAoC,IAArC,CAAV,GAAuD,qBAAvD;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,4BAAD,CAAV,GAA2C,IAA5C,CAAV,GAA8D,4BAA9D;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,sBAAD,CAAV,GAAqC,IAAtC,CAAV,GAAwD,sBAAxD;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,qCAAD,CAAV,GAAoD,IAArD,CAAV,GAAuE,qCAAvE;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,0CAAD,CAAV,GAAyD,IAA1D,CAAV,GAA4E,0CAA5E;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,8BAAD,CAAV,GAA6C,IAA9C,CAAV,GAAgE,8BAAhE;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,uCAAD,CAAV,GAAsD,IAAvD,CAAV,GAAyE,uCAAzE;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,qBAAD,CAAV,GAAoC,IAArC,CAAV,GAAuD,qBAAvD;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,sCAAD,CAAV,GAAqD,IAAtD,CAAV,GAAwE,sCAAxE;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,uBAAD,CAAV,GAAsC,IAAvC,CAAV,GAAyD,uBAAzD;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,6BAAD,CAAV,GAA4C,IAA7C,CAAV,GAA+D,6BAA/D;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,yDAAD,CAAV,GAAwE,IAAzE,CAAV,GAA2F,yDAA3F;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,0BAAD,CAAV,GAAyC,IAA1C,CAAV,GAA4D,0BAA5D;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,sBAAD,CAAV,GAAqC,IAAtC,CAAV,GAAwD,sBAAxD;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,8BAAD,CAAV,GAA6C,IAA9C,CAAV,GAAgE,8BAAhE;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,yBAAD,CAAV,GAAwC,IAAzC,CAAV,GAA2D,yBAA3D;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,yBAAD,CAAV,GAAwC,IAAzC,CAAV,GAA2D,yBAA3D;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,2BAAD,CAAV,GAA0C,IAA3C,CAAV,GAA6D,2BAA7D;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,gDAAD,CAAV,GAA+D,IAAhE,CAAV,GAAkF,gDAAlF;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,kCAAD,CAAV,GAAiD,IAAlD,CAAV,GAAoE,kCAApE;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,iCAAD,CAAV,GAAgD,IAAjD,CAAV,GAAmE,iCAAnE;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,mCAAD,CAAV,GAAkD,IAAnD,CAAV,GAAqE,mCAArE;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,wBAAD,CAAV,GAAuC,IAAxC,CAAV,GAA0D,wBAA1D;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,0BAAD,CAAV,GAAyC,IAA1C,CAAV,GAA4D,0BAA5D;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,0BAAD,CAAV,GAAyC,IAA1C,CAAV,GAA4D,0BAA5D;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,cAAD,CAAV,GAA6B,IAA9B,CAAV,GAAgD,cAAhD;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,6BAAD,CAAV,GAA4C,IAA7C,CAAV,GAA+D,6BAA/D;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,gCAAD,CAAV,GAA+C,IAAhD,CAAV,GAAkE,gCAAlE;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,uBAAD,CAAV,GAAsC,IAAvC,CAAV,GAAyD,uBAAzD;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,uBAAD,CAAV,GAAsC,IAAvC,CAAV,GAAyD,uBAAzD;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,iCAAD,CAAV,GAAgD,IAAjD,CAAV,GAAmE,iCAAnE;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,qBAAD,CAAV,GAAoC,IAArC,CAAV,GAAuD,qBAAvD;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,2BAAD,CAAV,GAA0C,IAA3C,CAAV,GAA6D,2BAA7D;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,2BAAD,CAAV,GAA0C,IAA3C,CAAV,GAA6D,2BAA7D;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,0BAAD,CAAV,GAAyC,KAA1C,CAAV,GAA6D,0BAA7D;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,mCAAD,CAAV,GAAkD,KAAnD,CAAV,GAAsE,mCAAtE;AACD,CA/CD,EA+CGD,SAAS,KAAKA,SAAS,GAAG,EAAjB,CA/CZ,E,CAiDA;;;AACA,IAAIE,2BAA2B,GAAG,IAAIC,GAAJ,CAAQ,CACxCH,SAAS,CAACI,yBAD8B,EAExCJ,SAAS,CAACK,qBAF8B,EAGxCL,SAAS,CAACM,mBAH8B,EAIxCN,SAAS,CAACO,sBAJ8B,EAKxCP,SAAS,CAACQ,wBAL8B,EAMxCR,SAAS,CAACS,wBAN8B,EAOxCT,SAAS,CAACU,qCAP8B,CAAR,CAAlC,C,CAUA;;AACA,OAAOC,GAAP,MAAgB,YAAhB,C,CAEA;;AACA,IAAIC,kBAAkB,GAAG,4CAAzB;;AACA,SAASC,uBAAT,CAAiCC,MAAjC,EAAyC;AACvC,SAAOA,MAAM,CAACC,OAAP,CAAeH,kBAAf,EAAmC,QAAnC,CAAP;AACD;;AACD,SAASI,WAAT,CAAqBtU,IAArB,EAA2B;AACzB,SAAOuU,QAAQ,CAAC,QAAQvU,IAAT,CAAf;AACD,C,CAED;;;AACA,IAAIwU,oBAAoB,GAAG,MAAM;AAC/B3U,EAAAA,WAAW,CAACG,IAAD,EAAOF,IAAP,EAAa2U,OAAb,EAAsBC,kBAAtB,EAA0C;AACnD,SAAK1U,IAAL,GAAYA,IAAZ;AACA,SAAKF,IAAL,GAAYA,IAAZ;AACA,SAAK2U,OAAL,GAAeA,OAAf;AACA,SAAKC,kBAAL,GAA0BA,kBAA1B;AACA,SAAKC,uBAAL,GAA+B,IAA/B;AACD;;AACDC,EAAAA,YAAY,GAAG;AACb,WAAOC,cAAc,CAAC,KAAK7U,IAAN,EAAY,KAAKF,IAAjB,EAAuB,KAAK2U,OAA5B,EAAqC,KAAKC,kBAA1C,CAArB;AACD;;AAV8B,CAAjC;;AAYA,SAASG,cAAT,CAAwB7U,IAAxB,EAA8BF,IAA9B,EAAoCgV,WAApC,EAAiDJ,kBAAjD,EAAqE;AACnE5U,EAAAA,IAAI,GAAGmU,GAAG,CAACc,eAAJ,CAAoBjV,IAApB,CAAP;AACA,SAAO;AACLkV,IAAAA,QAAQ,EAAEf,GAAG,CAACgB,kBAAJ,CAAuB1P,KAD5B;AAELvF,IAAAA,IAAI,EAAEsU,WAAW,CAACtU,IAAD,CAFZ;AAGLkV,IAAAA,IAAI,EAAEjB,GAAG,CAACc,eAAJ,CAAoBjV,IAApB,EAA0BhB,aAA1B,EAHD;AAILqW,IAAAA,KAAK,EAAErV,IAAI,CAACsV,QAAL,CAAc,KAAK,CAAnB,EAAsB,KAAtB,CAJF;AAKL7R,IAAAA,MAAM,EAAEzD,IAAI,CAACuV,QAAL,EALH;AAMLP,IAAAA,WANK;AAOLJ,IAAAA;AAPK,GAAP;AASD;;AACD,SAASY,sBAAT,CAAgCxV,IAAhC,EAAsCgV,WAAtC,EAAmD;AACjDhV,EAAAA,IAAI,GAAGmU,GAAG,CAACc,eAAJ,CAAoBjV,IAApB,CAAP;AACA,SAAO;AACLkV,IAAAA,QAAQ,EAAEf,GAAG,CAACgB,kBAAJ,CAAuBM,OAD5B;AAELvV,IAAAA,IAAI,EAAE,CAFD;AAGLkV,IAAAA,IAAI,EAAEpV,IAAI,CAAChB,aAAL,EAHD;AAILqW,IAAAA,KAAK,EAAErV,IAAI,CAACsV,QAAL,EAJF;AAKL7R,IAAAA,MAAM,EAAEzD,IAAI,CAACuV,QAAL,EALH;AAMLP,IAAAA;AANK,GAAP;AAQD;;AACD,SAASU,sBAAT,CAAgCC,GAAhC,EAAqC;AACnC,SAAOA,GAAG,CAACd,uBAAJ,KAAgC,IAAvC;AACD,C,CAED;;;AACA,IAAIe,2BAA2B,GAAG,2BAAlC,C,CAEA;;AACA,SAASC,oBAAT,CAA8BlV,KAA9B,EAAqCmV,QAAQ,GAAG,CAAhD,EAAmD;AACjD,MAAIC,EAAJ,EAAQC,EAAR;;AACA,MAAIrV,KAAK,KAAK,IAAd,EAAoB;AAClB,WAAO,MAAP;AACD,GAFD,MAEO,IAAIA,KAAK,KAAK,KAAK,CAAnB,EAAsB;AAC3B,WAAO,WAAP;AACD,GAFM,MAEA,IAAI,OAAOA,KAAP,KAAiB,QAAjB,IAA6B,OAAOA,KAAP,KAAiB,SAA9C,IAA2D,OAAOA,KAAP,KAAiB,QAAhF,EAA0F;AAC/F,WAAO,OAAOA,KAAd;AACD,GAFM,MAEA,IAAIA,KAAK,YAAYmC,GAArB,EAA0B;AAC/B,QAAIgT,QAAQ,KAAK,CAAjB,EAAoB;AAClB,aAAO,QAAP;AACD;;AACD,UAAMG,OAAO,GAAGnS,KAAK,CAACa,IAAN,CAAWhE,KAAK,CAACsV,OAAN,EAAX,EAA4BpT,GAA5B,CAAgC,CAAC,CAACyB,GAAD,EAAM4R,CAAN,CAAD,KAAc;AAC5D,aAAQ,GAAEC,QAAQ,CAAC7R,GAAD,CAAM,KAAIuR,oBAAoB,CAACK,CAAD,EAAIJ,QAAQ,GAAG,CAAf,CAAkB,EAAlE;AACD,KAFe,CAAhB;AAGA,WAAOG,OAAO,CAACxS,MAAR,GAAiB,CAAjB,GAAsB,KAAIwS,OAAO,CAACpK,IAAR,CAAa,IAAb,CAAmB,IAA7C,GAAmD,IAA1D;AACD,GARM,MAQA,IAAIlL,KAAK,YAAY0B,cAArB,EAAqC;AAC1C,WAAO,UAAP;AACD,GAFM,MAEA,IAAI1B,KAAK,YAAYuC,SAArB,EAAgC;AACrC,WAAO,CAAC6S,EAAE,GAAGpV,KAAK,CAACwC,OAAN,CAAciT,SAApB,KAAkC,IAAlC,GAAyCL,EAAzC,GAA8C,aAArD;AACD,GAFM,MAEA,IAAIpV,KAAK,YAAY/B,SAArB,EAAgC;AACrC,WAAO,CAACoX,EAAE,GAAGrV,KAAK,CAACyV,SAAZ,KAA0B,IAA1B,GAAiCJ,EAAjC,GAAsC,aAA7C;AACD,GAFM,MAEA,IAAIlS,KAAK,CAACC,OAAN,CAAcpD,KAAd,CAAJ,EAA0B;AAC/B,QAAImV,QAAQ,KAAK,CAAjB,EAAoB;AAClB,aAAO,OAAP;AACD;;AACD,WAAQ,IAAGnV,KAAK,CAACkC,GAAN,CAAWqT,CAAD,IAAOL,oBAAoB,CAACK,CAAD,EAAIJ,QAAQ,GAAG,CAAf,CAArC,EAAwDjK,IAAxD,CAA6D,IAA7D,CAAmE,GAA9E;AACD,GALM,MAKA,IAAIlL,KAAK,YAAYb,YAArB,EAAmC;AACxC,WAAO,6BAAP;AACD,GAFM,MAEA,IAAIa,KAAK,YAAY0C,OAArB,EAA8B;AACnC,WAAO,UAAP;AACD,GAFM,MAEA;AACL,WAAO,SAAP;AACD;AACF;;AACD,SAAS8S,QAAT,CAAkB7R,GAAlB,EAAuB;AACrB,MAAI,gBAAgB+R,IAAhB,CAAqB/R,GAArB,CAAJ,EAA+B;AAC7B,WAAOA,GAAP;AACD,GAFD,MAEO;AACL,WAAQ,IAAGA,GAAG,CAACiQ,OAAJ,CAAY,IAAZ,EAAkB,KAAlB,CAAyB,GAApC;AACD;AACF;;AACD,SAAS+B,iBAAT,CAA2BtW,IAA3B,EAAiCW,KAAjC,EAAwC;AACtC,SAAOA,KAAK,CAACc,MAAN,CAAa,IAAI8U,wBAAJ,CAA6BvW,IAA7B,CAAb,CAAP;AACD;;AACD,IAAIuW,wBAAwB,GAAG,MAAM;AACnCxW,EAAAA,WAAW,CAACC,IAAD,EAAO;AAChB,SAAKA,IAAL,GAAYA,IAAZ;AACA,SAAKwW,oBAAL,GAA4B,IAA5B;AACD;;AACD7U,EAAAA,iBAAiB,CAAChB,KAAD,EAAQ;AACvB,UAAM8V,KAAK,GAAG9V,KAAK,CAACV,MAAN,CAAawB,MAAb,CAAoB,IAApB,CAAd;;AACA,QAAI,KAAKiV,WAAL,CAAiB/V,KAAK,CAACX,IAAvB,CAAJ,EAAkC;AAChC,YAAM2W,IAAI,GAAGnB,sBAAsB,CAAC7U,KAAK,CAACX,IAAP,EAAa,gDAAb,CAAnC;AACAyW,MAAAA,KAAK,CAACjF,OAAN,CAAcmF,IAAd;AACD;;AACD,WAAOF,KAAP;AACD;;AACD7U,EAAAA,kBAAkB,CAACjB,KAAD,EAAQ;AACxB,WAAO,CAAC6U,sBAAsB,CAAC7U,KAAK,CAACX,IAAP,EAAa,oDAAb,CAAvB,CAAP;AACD;;AACD6B,EAAAA,sBAAsB,CAAClB,KAAD,EAAQ;AAC5B,UAAM8B,IAAI,GAAG9B,KAAK,CAACV,MAAN,CAAamW,SAA1B;AACA,UAAMQ,WAAW,GAAGnU,IAAI,KAAK,IAAT,GAAiB,IAAGA,IAAK,GAAzB,GAA8B,0BAAlD;AACA,WAAO,CAAC+S,sBAAsB,CAAC7U,KAAK,CAACX,IAAP,EAAc,eAAc4W,WAAY,qEAAxC,CAAvB,CAAP;AACD;;AACD3U,EAAAA,wBAAwB,CAACtB,KAAD,EAAQ;AAC9B,WAAO,CACL6U,sBAAsB,CAAC7U,KAAK,CAACX,IAAP,EAAa,0GAAb,CADjB,EAELwV,sBAAsB,CAAC7U,KAAK,CAACV,MAAN,CAAaD,IAAd,EAAoB,4BAApB,CAFjB,CAAP;AAID;;AACDgC,EAAAA,0BAA0B,CAACrB,KAAD,EAAQ;AAChC,WAAO,CAAC6U,sBAAsB,CAAC7U,KAAK,CAACX,IAAP,EAAa,2CAAb,CAAvB,CAAP;AACD;;AACDmC,EAAAA,YAAY,CAACxB,KAAD,EAAQ;AAClB,WAAO,CAAC6U,sBAAsB,CAAC7U,KAAK,CAACX,IAAP,EAAa,gCAAb,CAAvB,CAAP;AACD;;AACD+B,EAAAA,sBAAsB,CAACpB,KAAD,EAAQ;AAC5B,WAAO,CAAC6U,sBAAsB,CAAC7U,KAAK,CAACX,IAAP,EAAa,oBAAb,CAAvB,CAAP;AACD;;AACDkC,EAAAA,gBAAgB,CAACvB,KAAD,EAAQ;AACtB,WAAO,CAAC6U,sBAAsB,CAAC7U,KAAK,CAACX,IAAP,EAAa,eAAb,CAAvB,CAAP;AACD;;AACD8B,EAAAA,sBAAsB,CAACnB,KAAD,EAAQ;AAC5B,WAAO,CAAC6U,sBAAsB,CAAC7U,KAAK,CAACX,IAAP,EAAa,+BAAb,CAAvB,CAAP;AACD;;AACD0W,EAAAA,WAAW,CAAC1W,IAAD,EAAO;AAChB,QAAIA,IAAI,KAAK,KAAKA,IAAlB,EAAwB;AACtB,aAAO,KAAP;AACD;;AACD,UAAM6W,SAAS,GAAGC,gBAAgB,CAAC9W,IAAD,CAAlC;;AACA,QAAI6W,SAAS,KAAK,KAAKL,oBAAvB,EAA6C;AAC3C,aAAO,KAAP;AACD;;AACD,SAAKA,oBAAL,GAA4BK,SAA5B;AACA,WAAO,IAAP;AACD;;AApDkC,CAArC;;AAsDA,SAASC,gBAAT,CAA0B9W,IAA1B,EAAgC;AAC9B,MAAI+W,WAAW,GAAG/W,IAAlB;;AACA,SAAO+W,WAAW,KAAK,KAAK,CAA5B,EAA+B;AAC7B,YAAQA,WAAW,CAAC3O,IAApB;AACE,WAAKmL,GAAG,CAACxN,UAAJ,CAAeiR,mBAApB;AACA,WAAKzD,GAAG,CAACxN,UAAJ,CAAekR,iBAApB;AACA,WAAK1D,GAAG,CAACxN,UAAJ,CAAemR,eAApB;AACA,WAAK3D,GAAG,CAACxN,UAAJ,CAAeoR,WAApB;AACA,WAAK5D,GAAG,CAACxN,UAAJ,CAAeqR,eAApB;AACA,WAAK7D,GAAG,CAACxN,UAAJ,CAAesR,WAApB;AACA,WAAK9D,GAAG,CAACxN,UAAJ,CAAeuR,cAApB;AACA,WAAK/D,GAAG,CAACxN,UAAJ,CAAewR,YAApB;AACA,WAAKhE,GAAG,CAACxN,UAAJ,CAAeyR,cAApB;AACA,WAAKjE,GAAG,CAACxN,UAAJ,CAAe0R,cAApB;AACA,WAAKlE,GAAG,CAACxN,UAAJ,CAAe2R,iBAApB;AACA,WAAKnE,GAAG,CAACxN,UAAJ,CAAe4R,cAApB;AACA,WAAKpE,GAAG,CAACxN,UAAJ,CAAe6R,cAApB;AACA,WAAKrE,GAAG,CAACxN,UAAJ,CAAe8R,oBAApB;AACA,WAAKtE,GAAG,CAACxN,UAAJ,CAAe+R,mBAApB;AACE,eAAOf,WAAP;AAhBJ;;AAkBAA,IAAAA,WAAW,GAAGA,WAAW,CAACtF,MAA1B;AACD;;AACD,SAAOzR,IAAI,CAAChB,aAAL,EAAP;AACD,C,CAED;;;AACA,SAAS+Y,YAAT,EAAuBC,WAAvB,EAAoCC,aAApC,EAAmDC,eAAnD,EAAoEC,eAApE,EAAqFC,YAArF,EAAmGC,eAAnG,QAA0H,mBAA1H;AACA,OAAOC,GAAP,MAAgB,YAAhB;;AACA,SAASC,0BAAT,CAAoCC,KAApC,EAA2CC,SAA3C,EAAsDC,MAAtD,EAA8D;AAC5D,QAAMC,IAAI,GAAG,EAAb;AACA,QAAMrE,MAAM,GAAG,EAAf;AACA,MAAIsE,UAAU,GAAGH,SAAS,CAACI,wBAAV,CAAmCL,KAAnC,CAAjB;;AACA,MAAII,UAAU,KAAK,IAAnB,EAAyB;AACvB,QAAIH,SAAS,CAACK,YAAV,CAAuBN,KAAvB,CAAJ,EAAmC;AACjC,aAAO,IAAP;AACD,KAFD,MAEO;AACLI,MAAAA,UAAU,GAAG,EAAb;AACD;AACF;;AACDA,EAAAA,UAAU,CAAC7V,OAAX,CAAmB,CAACsN,KAAD,EAAQ0I,GAAR,KAAgB;AACjC,QAAIC,KAAK,GAAGC,0BAA0B,CAAC5I,KAAK,CAAC6I,kBAAP,CAAtC;AACA,QAAIC,iBAAiB,GAAG,IAAxB;AACA,QAAIC,QAAQ,GAAG,KAAf;AAAA,QAAsBC,IAAI,GAAG,KAA7B;AAAA,QAAoCC,QAAQ,GAAG,KAA/C;AAAA,QAAsDxR,IAAI,GAAG,KAA7D;AACA,KAACuI,KAAK,CAACkJ,UAAN,IAAoB,EAArB,EAAyBC,MAAzB,CAAiCC,GAAD,IAASf,MAAM,IAAIgB,aAAa,CAACD,GAAD,CAAhE,EAAuE1W,OAAvE,CAAgF0W,GAAD,IAAS;AACtF,YAAMhX,IAAI,GAAGiW,MAAM,IAAIe,GAAG,CAAC5b,MAAJ,KAAe,IAAzB,GAAgC4b,GAAG,CAAChX,IAApC,GAA2CgX,GAAG,CAAC5b,MAAJ,CAAW4E,IAAnE;;AACA,UAAIA,IAAI,KAAK,QAAb,EAAuB;AACrB,YAAIgX,GAAG,CAACjW,IAAJ,KAAa,IAAb,IAAqBiW,GAAG,CAACjW,IAAJ,CAASC,MAAT,KAAoB,CAA7C,EAAgD;AAC9C,gBAAM,IAAIiR,oBAAJ,CAAyBlB,SAAS,CAACmG,qBAAnC,EAA0Dzb,SAAS,CAAC0b,YAAV,CAAuBH,GAAvB,CAA1D,EAAwF,8CAAxF,CAAN;AACD;;AACDT,QAAAA,KAAK,GAAG,IAAIX,eAAJ,CAAoBoB,GAAG,CAACjW,IAAJ,CAAS,CAAT,CAApB,CAAR;AACD,OALD,MAKO,IAAIf,IAAI,KAAK,UAAb,EAAyB;AAC9B2W,QAAAA,QAAQ,GAAG,IAAX;AACD,OAFM,MAEA,IAAI3W,IAAI,KAAK,UAAb,EAAyB;AAC9B6W,QAAAA,QAAQ,GAAG,IAAX;AACD,OAFM,MAEA,IAAI7W,IAAI,KAAK,MAAb,EAAqB;AAC1B4W,QAAAA,IAAI,GAAG,IAAP;AACD,OAFM,MAEA,IAAI5W,IAAI,KAAK,MAAb,EAAqB;AAC1BqF,QAAAA,IAAI,GAAG,IAAP;AACD,OAFM,MAEA,IAAIrF,IAAI,KAAK,WAAb,EAA0B;AAC/B,YAAIgX,GAAG,CAACjW,IAAJ,KAAa,IAAb,IAAqBiW,GAAG,CAACjW,IAAJ,CAASC,MAAT,KAAoB,CAA7C,EAAgD;AAC9C,gBAAM,IAAIiR,oBAAJ,CAAyBlB,SAAS,CAACmG,qBAAnC,EAA0Dzb,SAAS,CAAC0b,YAAV,CAAuBH,GAAvB,CAA1D,EAAwF,iDAAxF,CAAN;AACD;;AACD,cAAMI,aAAa,GAAGJ,GAAG,CAACjW,IAAJ,CAAS,CAAT,CAAtB;AACAwV,QAAAA,KAAK,GAAG,IAAIX,eAAJ,CAAoBwB,aAApB,CAAR;;AACA,YAAIvB,GAAG,CAACwB,mBAAJ,CAAwBD,aAAxB,CAAJ,EAA4C;AAC1CV,UAAAA,iBAAiB,GAAG,IAAInB,WAAJ,CAAgB6B,aAAa,CAACpR,IAA9B,CAApB;AACD,SAFD,MAEO;AACL0Q,UAAAA,iBAAiB,GAAG,IAAId,eAAJ,CAAoBC,GAAG,CAACyB,qBAAJ,CAA0BzB,GAAG,CAACvS,UAAJ,CAAeiU,cAAzC,CAApB,CAApB;AACD;AACF,OAXM,MAWA;AACL,cAAM,IAAItF,oBAAJ,CAAyBlB,SAAS,CAACyG,oBAAnC,EAAyD/b,SAAS,CAAC0b,YAAV,CAAuBH,GAAvB,CAAzD,EAAuF,wBAAuBhX,IAAK,gBAAnH,CAAN;AACD;AACF,KA7BD;;AA8BA,QAAIuW,KAAK,KAAK,IAAd,EAAoB;AAClB,UAAI3I,KAAK,CAAC6I,kBAAN,CAAyB9Q,IAAzB,KAAkC,CAAtC,EAAyC;AACvC,cAAM,IAAI3C,KAAJ,CAAU,kFAAV,CAAN;AACD;;AACD6O,MAAAA,MAAM,CAACzQ,IAAP,CAAY;AACVyM,QAAAA,KAAK,EAAEyI,GADG;AAEV1I,QAAAA,KAFU;AAGVpQ,QAAAA,MAAM,EAAEoQ,KAAK,CAAC6I,kBAAN,CAAyBjZ;AAHvB,OAAZ;AAKD,KATD,MASO;AACL0Y,MAAAA,IAAI,CAAC9U,IAAL,CAAU;AAAEmV,QAAAA,KAAF;AAASG,QAAAA,iBAAT;AAA4BC,QAAAA,QAA5B;AAAsCC,QAAAA,IAAtC;AAA4CC,QAAAA,QAA5C;AAAsDxR,QAAAA;AAAtD,OAAV;AACD;AACF,GA9CD;;AA+CA,MAAIwM,MAAM,CAAC7Q,MAAP,KAAkB,CAAtB,EAAyB;AACvB,WAAO;AAAEkV,MAAAA;AAAF,KAAP;AACD,GAFD,MAEO;AACL,WAAO;AAAEA,MAAAA,IAAI,EAAE,IAAR;AAAcrE,MAAAA;AAAd,KAAP;AACD;AACF;;AACD,SAAS2E,0BAAT,CAAoCiB,QAApC,EAA8C;AAC5C,MAAIA,QAAQ,CAAC9R,IAAT,KAAkB,CAAtB,EAAyB;AACvB,WAAO,IAAP;AACD,GAFD,MAEO,IAAI8R,QAAQ,CAAC9R,IAAT,KAAkB,CAAtB,EAAyB;AAC9B,UAAMiH,IAAI,GAAG,IAAIgJ,eAAJ,CAAoB6B,QAAQ,CAAC9P,UAA7B,CAAb;;AACA,QAAI8P,QAAQ,CAACC,sBAAT,KAAoC,IAAxC,EAA8C;AAC5Ctb,MAAAA,8BAA8B,CAACwQ,IAAD,EAAO6K,QAAQ,CAACC,sBAAhB,CAA9B;AACD;;AACD,WAAO9K,IAAP;AACD,GANM,MAMA;AACL,QAAI+K,UAAU,GAAG,IAAIrC,YAAJ,CAAiB;AAAEsC,MAAAA,UAAU,EAAEH,QAAQ,CAACG,UAAvB;AAAmC5X,MAAAA,IAAI,EAAEyX,QAAQ,CAACI;AAAlD,KAAjB,CAAjB;;AACA,QAAIJ,QAAQ,CAACK,UAAT,KAAwB,IAA5B,EAAkC;AAChC,WAAK,MAAMxP,QAAX,IAAuBmP,QAAQ,CAACK,UAAhC,EAA4C;AAC1CH,QAAAA,UAAU,GAAG,IAAIhC,YAAJ,CAAiBgC,UAAjB,EAA6BrP,QAA7B,CAAb;AACD;AACF;;AACD,WAAOqP,UAAP;AACD;AACF;;AACD,SAASI,6BAAT,CAAuC7B,IAAvC,EAA6C;AAC3C,MAAIA,IAAI,KAAK,IAAb,EAAmB;AACjB,WAAO,IAAP;AACD,GAFD,MAEO,IAAIA,IAAI,CAACA,IAAL,KAAc,IAAlB,EAAwB;AAC7B,WAAOA,IAAI,CAACA,IAAZ;AACD,GAFM,MAEA;AACL,WAAO,SAAP;AACD;AACF;;AACD,SAAS8B,+BAAT,CAAyCjC,KAAzC,EAAgDC,SAAhD,EAA2DC,MAA3D,EAAmE;AACjE,SAAOgC,+BAA+B,CAAClC,KAAD,EAAQD,0BAA0B,CAACC,KAAD,EAAQC,SAAR,EAAmBC,MAAnB,CAAlC,CAAtC;AACD;;AACD,SAASgC,+BAAT,CAAyClC,KAAzC,EAAgDG,IAAhD,EAAsD;AACpD,MAAIA,IAAI,KAAK,IAAb,EAAmB;AACjB,WAAO,IAAP;AACD,GAFD,MAEO,IAAIA,IAAI,CAACA,IAAL,KAAc,IAAlB,EAAwB;AAC7B,WAAOA,IAAI,CAACA,IAAZ;AACD,GAFM,MAEA;AACL,UAAMgC,KAAK,GAAGhC,IAAI,CAACrE,MAAL,CAAY,CAAZ,CAAd;AACA,UAAMsG,mCAAmC,CAACpC,KAAD,EAAQmC,KAAR,CAAzC;AACD;AACF;;AACD,SAASC,mCAAT,CAA6CpC,KAA7C,EAAoDmC,KAApD,EAA2D;AACzD,QAAM;AAAEtK,IAAAA,KAAF;AAASC,IAAAA,KAAT;AAAgBrQ,IAAAA;AAAhB,MAA2B0a,KAAjC;AACA,MAAIE,YAAY,GAAG,KAAK,CAAxB;AACA,MAAIC,KAAK,GAAG,KAAK,CAAjB;;AACA,UAAQ7a,MAAM,CAACmI,IAAf;AACE,SAAK,CAAL;AACEyS,MAAAA,YAAY,GAAG,qEAAf;AACAC,MAAAA,KAAK,GAAG,CACNtF,sBAAsB,CAACvV,MAAM,CAAC8a,QAAR,EAAkB,gDAAlB,CADhB,CAAR;AAGA;;AACF,SAAK,CAAL;AACEF,MAAAA,YAAY,GAAG,qEAAf;AACAC,MAAAA,KAAK,GAAG,CACNtF,sBAAsB,CAACvV,MAAM,CAAC8a,QAAR,EAAkB,2EAAlB,CADhB,CAAR;;AAGA,UAAI9a,MAAM,CAAC+C,IAAP,KAAgB,IAApB,EAA0B;AACxB8X,QAAAA,KAAK,CAACjX,IAAN,CAAW2R,sBAAsB,CAACvV,MAAM,CAAC+C,IAAR,EAAc,4BAAd,CAAjC;AACD;;AACD;;AACF,SAAK,CAAL;AACE6X,MAAAA,YAAY,GAAG,yHAAf;AACAC,MAAAA,KAAK,GAAG,CACNtF,sBAAsB,CAACvV,MAAM,CAAC8a,QAAR,EAAkB,4GAAlB,CADhB,EAENvF,sBAAsB,CAACvV,MAAM,CAACD,IAAR,EAAc,mCAAd,CAFhB,CAAR;AAIA;;AACF,SAAK,CAAL;AACE6a,MAAAA,YAAY,GAAG,qEAAf;AACAC,MAAAA,KAAK,GAAG,CACNtF,sBAAsB,CAACvV,MAAM,CAAC8a,QAAR,EAAkB,kFAAlB,CADhB,EAENvF,sBAAsB,CAACvV,MAAM,CAAC+a,YAAR,EAAsB,mCAAtB,CAFhB,CAAR;AAIA;;AACF,SAAK,CAAL;AACEH,MAAAA,YAAY,GAAG,gDAAf;AACAC,MAAAA,KAAK,GAAG,CAACtF,sBAAsB,CAACvV,MAAM,CAAC8a,QAAR,EAAkB,kCAAlB,CAAvB,CAAR;AACA;;AACF,SAAK,CAAL;AACEF,MAAAA,YAAY,GAAG,qGAAf;AACA;AApCJ;;AAsCA,QAAMI,KAAK,GAAG;AACZjG,IAAAA,WAAW,EAAG,8CAA6C3E,KAAK,CAAC5N,IAAN,IAAc6N,KAAM,eAAckI,KAAK,CAAC/V,IAAN,CAAWgG,IAAK,IADjG;AAEZyM,IAAAA,QAAQ,EAAEoD,GAAG,CAACnD,kBAAJ,CAAuB1P,KAFrB;AAGZvF,IAAAA,IAAI,EAAE,CAHM;AAIZgb,IAAAA,IAAI,EAAE,CAAC;AACLlG,MAAAA,WAAW,EAAE6F,YADR;AAEL3F,MAAAA,QAAQ,EAAEoD,GAAG,CAACnD,kBAAJ,CAAuBM,OAF5B;AAGLvV,MAAAA,IAAI,EAAE;AAHD,KAAD;AAJM,GAAd;AAUA,SAAO,IAAIwU,oBAAJ,CAAyBlB,SAAS,CAACM,mBAAnC,EAAwDzD,KAAK,CAAC8K,QAA9D,EAAwEF,KAAxE,EAA+EH,KAA/E,CAAP;AACD;;AACD,SAASM,aAAT,CAAuBlB,QAAvB,EAAiCmB,OAAjC,EAA0CC,YAA1C,EAAwDC,WAAxD,EAAqEC,UAArE,EAAiF;AAC/E,SAAO;AACL7a,IAAAA,KAAK,EAAE6a,UAAU,CAACC,IAAX,CAAgBvB,QAAhB,EAA0BoB,YAA1B,EAAwClR,UAD1C;AAELwD,IAAAA,IAAI,EAAE4N,UAAU,CAACC,IAAX,CAAgBJ,OAAhB,EAAyBE,WAAzB,EAAsC7c,WAAW,CAACgd,cAAZ,GAA6Bhd,WAAW,CAACid,gBAA/E,EAAiGvR;AAFlG,GAAP;AAID;;AACD,SAASsP,aAAT,CAAuBkC,SAAvB,EAAkC;AAChC,SAAOA,SAAS,CAAC/d,MAAV,KAAqB,IAArB,IAA6B+d,SAAS,CAAC/d,MAAV,CAAiB8G,IAAjB,KAA0B,eAA9D;AACD;;AACD,SAASkX,sBAAT,CAAgCC,SAAhC,EAA2CC,UAA3C,EAAuD;AACrD,SAAOD,SAAS,CAACE,kBAAV,KAAiC,eAAjC,IAAoDF,SAAS,CAAC1F,SAAV,KAAwB2F,UAAnF;AACD;;AACD,SAASE,oBAAT,CAA8B1C,UAA9B,EAA0C9W,IAA1C,EAAgDiW,MAAhD,EAAwD;AACtD,SAAOa,UAAU,CAACzK,IAAX,CAAiB8M,SAAD,IAAeM,kBAAkB,CAACN,SAAD,EAAYnZ,IAAZ,EAAkBiW,MAAlB,CAAjD,CAAP;AACD;;AACD,SAASwD,kBAAT,CAA4BN,SAA5B,EAAuCnZ,IAAvC,EAA6CiW,MAA7C,EAAqD;AACnD,MAAIA,MAAJ,EAAY;AACV,WAAOkD,SAAS,CAACnZ,IAAV,KAAmBA,IAA1B;AACD,GAFD,MAEO,IAAIiX,aAAa,CAACkC,SAAD,CAAjB,EAA8B;AACnC,WAAOA,SAAS,CAAC/d,MAAV,CAAiB4E,IAAjB,KAA0BA,IAAjC;AACD;;AACD,SAAO,KAAP;AACD;;AACD,SAAS0Z,gBAAT,CAA0Bnc,IAA1B,EAAgC;AAC9B,SAAOsY,GAAG,CAACnO,cAAJ,CAAmBnK,IAAnB,KAA4BsY,GAAG,CAACvO,yBAAJ,CAA8B/J,IAA9B,CAAnC,EAAwE;AACtEA,IAAAA,IAAI,GAAGA,IAAI,CAACoK,UAAZ;AACD;;AACD,SAAOpK,IAAP;AACD;;AACD,SAASoc,gBAAT,CAA0BxY,GAA1B,EAA+B;AAC7BA,EAAAA,GAAG,GAAGuY,gBAAgB,CAACvY,GAAD,CAAtB;;AACA,MAAI,CAAC0U,GAAG,CAAC+D,eAAJ,CAAoBzY,GAApB,CAAD,IAA6B,CAAC0U,GAAG,CAACjG,oBAAJ,CAAyBzO,GAAzB,CAAlC,EAAiE;AAC/D,WAAO,IAAP;AACD;;AACD,QAAMwL,IAAI,GAAGxL,GAAG,CAACwL,IAAjB;;AACA,MAAIkJ,GAAG,CAACgE,OAAJ,CAAYlN,IAAZ,CAAJ,EAAuB;AACrB,QAAIA,IAAI,CAACmN,UAAL,CAAgB9Y,MAAhB,KAA2B,CAA/B,EAAkC;AAChC,aAAO,IAAP;AACD;;AACD,UAAM+Y,IAAI,GAAGpN,IAAI,CAACmN,UAAL,CAAgB,CAAhB,CAAb;;AACA,QAAI,CAACjE,GAAG,CAACtI,iBAAJ,CAAsBwM,IAAtB,CAAD,IAAgCA,IAAI,CAACpS,UAAL,KAAoB,KAAK,CAA7D,EAAgE;AAC9D,aAAO,IAAP;AACD;;AACD,WAAOoS,IAAI,CAACpS,UAAZ;AACD,GATD,MASO;AACL,WAAOgF,IAAP;AACD;AACF;;AACD,SAASqN,mBAAT,CAA6Bzc,IAA7B,EAAmCyY,SAAnC,EAA8C;AAC5CzY,EAAAA,IAAI,GAAGmc,gBAAgB,CAACnc,IAAD,CAAvB;;AACA,MAAI,CAACsY,GAAG,CAACjP,gBAAJ,CAAqBrJ,IAArB,CAAD,IAA+BA,IAAI,CAACuP,SAAL,CAAe9L,MAAf,KAA0B,CAA7D,EAAgE;AAC9D,WAAO,IAAP;AACD;;AACD,QAAM5C,EAAE,GAAGyX,GAAG,CAACnP,0BAAJ,CAA+BnJ,IAAI,CAACoK,UAApC,IAAkDpK,IAAI,CAACoK,UAAL,CAAgB3H,IAAlE,GAAyEzC,IAAI,CAACoK,UAAzF;;AACA,MAAI,CAACkO,GAAG,CAACrP,YAAJ,CAAiBpI,EAAjB,CAAL,EAA2B;AACzB,WAAO,IAAP;AACD;;AACD,QAAMwO,IAAI,GAAG+M,gBAAgB,CAACpc,IAAI,CAACuP,SAAL,CAAe,CAAf,CAAD,CAA7B;;AACA,MAAIF,IAAI,KAAK,IAAb,EAAmB;AACjB,WAAO,IAAP;AACD;;AACD,QAAMqN,GAAG,GAAGjE,SAAS,CAACxM,qBAAV,CAAgCpL,EAAhC,CAAZ;;AACA,MAAI6b,GAAG,KAAK,IAAR,IAAgBA,GAAG,CAAC/X,IAAJ,KAAa,eAA7B,IAAgD+X,GAAG,CAACja,IAAJ,KAAa,YAAjE,EAA+E;AAC7E,WAAO,IAAP;AACD;;AACD,SAAO4M,IAAP;AACD;;AACD,SAASsN,kBAAT,CAA4Bpc,GAA5B,EAAiCiD,IAAjC,EAAuC;AACrC,MAAI,CAACqY,sBAAsB,CAACtb,GAAD,EAAM,YAAN,CAAvB,IAA8CiD,IAAI,CAACC,MAAL,KAAgB,CAAlE,EAAqE;AACnE,WAAO,IAAP;AACD;;AACD,SAAO2Y,gBAAgB,CAAC5Y,IAAI,CAAC,CAAD,CAAL,CAAvB;AACD;;AACD,SAASoZ,gBAAT,CAA0BC,SAA1B,EAAqC;AACnC,SAAO,CAACtc,GAAD,EAAMiD,IAAN,KAAe;AACpB,SAAK,MAAMsZ,QAAX,IAAuBD,SAAvB,EAAkC;AAChC,YAAMzZ,QAAQ,GAAG0Z,QAAQ,CAACvc,GAAD,EAAMiD,IAAN,CAAzB;;AACA,UAAIJ,QAAQ,KAAK,IAAjB,EAAuB;AACrB,eAAOA,QAAP;AACD;AACF;;AACD,WAAO,IAAP;AACD,GARD;AASD;;AACD,SAAS2Z,4BAAT,CAAsC1N,IAAtC,EAA4CnH,OAA5C,EAAqD8U,aAArD,EAAoE;AAClE,MAAIC,mBAAmB,CAAC5N,IAAD,CAAvB,EAA+B;AAC7B,UAAMrP,IAAI,GAAGsY,GAAG,CAACrD,eAAJ,CAAoB5F,IAAI,CAACrP,IAAzB,CAAb;AACA,WAAOA,IAAI,CAAChB,aAAL,OAAyBge,aAAzB,IAA0C9U,OAAO,CAACgV,GAAR,GAAcld,IAAI,CAACkd,GAApE;AACD,GAHD,MAGO;AACL,WAAO,KAAP;AACD;AACF;;AACD,SAASD,mBAAT,CAA6B5N,IAA7B,EAAmC;AACjC,SAAOA,IAAI,YAAYgJ,eAAvB;AACD;;AACD,SAAS8E,aAAT,CAAuBnd,IAAvB,EAA6ByY,SAA7B,EAAwC2E,SAAxC,EAAmD;AACjD,QAAMC,cAAc,GAAG5E,SAAS,CAAC6E,sBAAV,CAAiCtd,IAAjC,CAAvB;;AACA,MAAIqd,cAAc,KAAK,IAAvB,EAA6B;AAC3B,UAAME,SAAS,GAAGH,SAAS,CAAC7a,QAAV,CAAmB8a,cAAnB,CAAlB;;AACA,QAAIE,SAAS,YAAY3e,SAArB,IAAkC6Z,SAAS,CAACnO,OAAV,CAAkBiT,SAAS,CAACvd,IAA5B,CAAtC,EAAyE;AACvE,aAAOud,SAAP;AACD,KAFD,MAEO;AACL,aAAO,SAAP;AACD;AACF;;AACD,SAAO,IAAP;AACD;;AACD,IAAIC,+BAA+B,GAAItV,OAAD,IAAa;AACjD,QAAMxG,OAAO,GAAI1B,IAAD,IAAU;AACxB,UAAMyd,OAAO,GAAGnF,GAAG,CAACoF,cAAJ,CAAmB1d,IAAnB,EAAyB0B,OAAzB,EAAkCwG,OAAlC,CAAhB;;AACA,QAAIoQ,GAAG,CAAC+D,eAAJ,CAAoBoB,OAApB,KAAgCnF,GAAG,CAACjG,oBAAJ,CAAyBoL,OAAzB,CAApC,EAAuE;AACrE,aAAOnF,GAAG,CAACqF,WAAJ,CAAgBF,OAAhB,CAAP;AACD;;AACD,WAAOA,OAAP;AACD,GAND;;AAOA,SAAQzd,IAAD,IAAUsY,GAAG,CAACoF,cAAJ,CAAmB1d,IAAnB,EAAyB0B,OAAzB,EAAkCwG,OAAlC,CAAjB;AACD,CATD;;AAUA,SAAS0V,+BAAT,CAAyCxT,UAAzC,EAAqD;AACnD,SAAOkO,GAAG,CAACuF,SAAJ,CAAczT,UAAd,EAA0B,CAACoT,+BAAD,CAA1B,EAA6DM,WAA7D,CAAyE,CAAzE,CAAP;AACD;;AACD,SAASC,6BAAT,CAAuC/d,IAAvC,EAA6Cge,IAA7C,EAAmD5V,IAAnD,EAAyD;AACvD,QAAMF,OAAO,GAAG,EAAhB;;AACA,OAAK,MAAMlF,IAAX,IAAmBgb,IAAnB,EAAyB;AACvB,QAAIhb,IAAI,CAACib,eAAL,KAAyB,IAA7B,EAAmC;AACjC;AACD;;AACD,UAAMC,WAAW,GAAGlb,IAAI,CAACzC,GAAL,CAAS4d,uBAAT,CAAiCnb,IAAI,CAACib,eAAtC,EAAuDjb,IAAI,CAACob,QAAL,CAAc3b,IAArE,CAApB;AACAyF,IAAAA,OAAO,CAACrE,IAAR,CAAa2R,sBAAsB,CAAC0I,WAAD,EAAe,IAAGle,IAAI,CAACyC,IAAL,CAAUgG,IAAK,oDAAmDzF,IAAI,CAACob,QAAL,CAAc3b,IAAd,CAAmBgG,IAAK,IAA5G,CAAnC;AACD;;AACD,SAAOsM,cAAc,CAACvB,SAAS,CAAC6K,+BAAX,EAA4Cre,IAAI,CAACyC,IAAjD,EAAwD,OAAM2F,IAAK,KAAIpI,IAAI,CAACyC,IAAL,CAAUgG,IAAK,0CAAtF,EAAiIP,OAAjI,CAArB;AACD;;AACD,SAASoW,gCAAT,CAA0CC,YAA1C,EAAwD9F,SAAxD,EAAmE2E,SAAnE,EAA8E;AAC5E,QAAMoB,SAAS,GAAG,IAAI7K,GAAJ,EAAlB;AACA,QAAM8K,iBAAiB,GAAGrB,SAAS,CAAC7a,QAAV,CAAmBgc,YAAnB,CAA1B;;AACA,MAAI,CAACza,KAAK,CAACC,OAAN,CAAc0a,iBAAd,CAAL,EAAuC;AACrC,WAAOD,SAAP;AACD;;AACDC,EAAAA,iBAAiB,CAAC1b,OAAlB,CAA0B,SAAS2b,gBAAT,CAA0BC,QAA1B,EAAoC;AAC5D,QAAIC,UAAU,GAAG,IAAjB;;AACA,QAAI9a,KAAK,CAACC,OAAN,CAAc4a,QAAd,CAAJ,EAA6B;AAC3BA,MAAAA,QAAQ,CAAC5b,OAAT,CAAiB2b,gBAAjB;AACD,KAFD,MAEO,IAAIC,QAAQ,YAAY/f,SAAxB,EAAmC;AACxCggB,MAAAA,UAAU,GAAGD,QAAb;AACD,KAFM,MAEA,IAAIA,QAAQ,YAAY7b,GAApB,IAA2B6b,QAAQ,CAACjc,GAAT,CAAa,UAAb,CAA3B,IAAuD,CAACic,QAAQ,CAACjc,GAAT,CAAa,MAAb,CAA5D,EAAkF;AACvF,YAAMmc,WAAW,GAAGF,QAAQ,CAAChc,GAAT,CAAa,UAAb,CAApB;;AACA,UAAIkc,WAAW,YAAYjgB,SAA3B,EAAsC;AACpCggB,QAAAA,UAAU,GAAGC,WAAb;AACD;AACF;;AACD,QAAID,UAAU,KAAK,IAAf,IAAuB,CAACA,UAAU,CAAC5e,IAAX,CAAgBhB,aAAhB,GAAgC8f,iBAAxD,IAA6ErG,SAAS,CAACnO,OAAV,CAAkBsU,UAAU,CAAC5e,IAA7B,CAAjF,EAAqH;AACnH,YAAM+e,qBAAqB,GAAGtG,SAAS,CAACI,wBAAV,CAAmC+F,UAAU,CAAC5e,IAA9C,CAA9B;;AACA,UAAI+e,qBAAqB,KAAK,IAA1B,IAAkCA,qBAAqB,CAACtb,MAAtB,GAA+B,CAArE,EAAwE;AACtE+a,QAAAA,SAAS,CAACQ,GAAV,CAAcJ,UAAd;AACD;AACF;AACF,GAlBD;AAmBA,SAAOJ,SAAP;AACD;;AACD,SAASS,iBAAT,CAA2BxG,SAA3B,EAAsCD,KAAtC,EAA6C;AAC3C,QAAM0G,QAAQ,GAAGzG,SAAS,CAAC0G,iBAAV,CAA4B3G,KAA5B,CAAjB;AACA,QAAM7X,KAAK,GAAG,IAAI0X,eAAJ,CAAoBG,KAAK,CAAC/V,IAA1B,CAAd;AACA,QAAMmL,IAAI,GAAGsR,QAAQ,KAAK,IAAb,IAAqB5gB,uBAAuB,CAAC4gB,QAAD,CAA5C,GAAyD,IAAI7G,eAAJ,CAAoB6G,QAAQ,CAACzc,IAA7B,CAAzD,GAA8F9B,KAA3G;AACA,SAAO;AAAEA,IAAAA,KAAF;AAASiN,IAAAA;AAAT,GAAP;AACD;;AACD,SAASwR,gBAAT,CAA0Bpf,IAA1B,EAAgC;AAC9B,QAAMqf,EAAE,GAAGrf,IAAI,CAAChB,aAAL,EAAX;AACA,QAAM,CAACsgB,WAAD,EAAcC,SAAd,IAA2B,CAACvf,IAAI,CAACsV,QAAL,EAAD,EAAkBtV,IAAI,CAACwf,MAAL,EAAlB,CAAjC;AACA,QAAM;AAAEC,IAAAA,IAAI,EAAEC,SAAR;AAAmBC,IAAAA,SAAS,EAAEC;AAA9B,MAA2CP,EAAE,CAACQ,6BAAH,CAAiCP,WAAjC,CAAjD;AACA,QAAM;AAAEG,IAAAA,IAAI,EAAEK,OAAR;AAAiBH,IAAAA,SAAS,EAAEI;AAA5B,MAAuCV,EAAE,CAACQ,6BAAH,CAAiCN,SAAjC,CAA7C;AACA,QAAMS,OAAO,GAAG,IAAI9H,eAAJ,CAAoBmH,EAAE,CAACY,WAAH,EAApB,EAAsCZ,EAAE,CAACnM,QAAzC,CAAhB;AACA,SAAO,IAAIiF,eAAJ,CAAoB,IAAIF,aAAJ,CAAkB+H,OAAlB,EAA2BV,WAA3B,EAAwCI,SAAS,GAAG,CAApD,EAAuDE,QAAQ,GAAG,CAAlE,CAApB,EAA0F,IAAI3H,aAAJ,CAAkB+H,OAAlB,EAA2BT,SAA3B,EAAsCO,OAAO,GAAG,CAAhD,EAAmDC,MAAM,GAAG,CAA5D,CAA1F,CAAP;AACD;;AACD,SAASG,cAAT,CAAwBC,GAAxB,EAA6BC,GAA7B,EAAkCC,YAAlC,EAAgDC,QAAhD,EAA0D;AACxD,QAAM/D,UAAU,GAAG6D,GAAG,CAAC7D,UAAvB;;AACA,MAAI8D,YAAY,KAAK,IAArB,EAA2B;AACzB9D,IAAAA,UAAU,CAAC1Y,IAAX,CAAgBwc,YAAhB;AACD;;AACD,SAAO,CACLF,GADK,EAEL;AACE1d,IAAAA,IAAI,EAAE6d,QADR;AAEEpV,IAAAA,WAAW,EAAEkV,GAAG,CAAChW,UAFnB;AAGEmS,IAAAA,UAAU,EAAE6D,GAAG,CAAC7D,UAHlB;AAIE3O,IAAAA,IAAI,EAAEwS,GAAG,CAACxS;AAJZ,GAFK,CAAP;AASD;;AACD,SAAS2S,iBAAT,CAA2BziB,IAA3B,EAAiCqG,MAAjC,EAAyC;AACvC,SAAO;AACL1B,IAAAA,IAAI,EAAE3E,IAAI,CAAC2E,IADN;AAELmL,IAAAA,IAAI,EAAE9P,IAAI,CAAC8P,IAFN;AAGL4S,IAAAA,YAAY,EAAE1iB,IAAI,CAAC0iB,YAHd;AAILC,IAAAA,iBAAiB,EAAE3iB,IAAI,CAAC2iB,iBAJnB;AAKL9H,IAAAA,IAAI,EAAE7a,IAAI,CAAC6a,IALN;AAMLxU,IAAAA;AANK,GAAP;AAQD,C,CAED;;;AACA,SAASuc,oBAAoB,IAAIC,qBAAjC,EAAwDC,4BAAxD,EAAsFC,2BAA2B,IAAIC,4BAArH,EAAmJC,mCAAnJ,EAAwLC,WAAxL,EAAqMC,4BAArM,EAAmOC,wBAAnO,EAA6PnJ,YAAY,IAAIoJ,aAA7Q,EAA4RC,aAAa,IAAIC,cAA7S,EAA6TC,mBAA7T,EAAkVC,iBAAiB,IAAIC,kBAAvW,EAA2XtJ,eAAe,IAAIuJ,gBAA9Y,EAAgaC,aAAha,EAA+aC,cAA/a,EAA+bC,eAA/b,EAAgdC,iBAAhd,EAAmexJ,eAAe,IAAIyJ,gBAAtf,QAA8gB,mBAA9gB;AACA,OAAOC,IAAP,MAAiB,YAAjB,C,CAEA;;AACA,OAAOC,GAAP,MAAgB,YAAhB;AACA,IAAIC,cAAc,GAAG,MAAM;AACzBliB,EAAAA,WAAW,CAACiD,IAAD,EAAO;AAChB,SAAKA,IAAL,GAAYA,IAAZ;AACA,SAAKoO,IAAL,GAAY5R,sBAAsB,CAACwD,IAAI,CAAChE,aAAL,EAAD,CAAlC;AACA,SAAKkjB,UAAL,GAAkBC,mBAAmB,CAACnf,IAAD,CAArC;AACD;;AALwB,CAA3B;;AAOA,SAASmf,mBAAT,CAA6Bnf,IAA7B,EAAmC;AACjC,MAAI,CAACgf,GAAG,CAAC1U,YAAJ,CAAiBtK,IAAI,CAACyO,MAAtB,CAAL,EAAoC;AAClC,WAAO,IAAP;AACD;;AACD,SAAOzO,IAAI,CAACP,IAAL,CAAUgG,IAAjB;AACD,C,CAED;;;AACA,SAASsP,YAAY,IAAIqK,aAAzB,QAA8C,mBAA9C;AACA,IAAIC,YAAY,GAAG,cAAcJ,cAAd,CAA6B;AAC9CK,EAAAA,mBAAmB,GAAG;AACpB,WAAO,KAAP;AACD;;AACDC,EAAAA,sBAAsB,GAAG;AACvB,WAAO,KAAP;AACD;;AAN6C,CAAhD;AAQA,IAAIC,gBAAgB,GAAG,MAAM;AAC3BziB,EAAAA,WAAW,GAAG;AACZ,SAAK0iB,KAAL,GAAa,IAAI3f,GAAJ,EAAb;AACA,SAAK4f,YAAL,GAAoB,IAAI5f,GAAJ,EAApB;AACD;;AACD6f,EAAAA,cAAc,CAACvX,MAAD,EAAS;AACrB,SAAKsX,YAAL,CAAkBzf,GAAlB,CAAsBmI,MAAM,CAACpI,IAA7B,EAAmCoI,MAAnC;;AACA,QAAIA,MAAM,CAAC8W,UAAP,KAAsB,IAA1B,EAAgC;AAC9B,UAAI,CAAC,KAAKO,KAAL,CAAW/f,GAAX,CAAe0I,MAAM,CAACgG,IAAtB,CAAL,EAAkC;AAChC,aAAKqR,KAAL,CAAWxf,GAAX,CAAemI,MAAM,CAACgG,IAAtB,EAA4B,IAAItO,GAAJ,EAA5B;AACD;;AACD,WAAK2f,KAAL,CAAW9f,GAAX,CAAeyI,MAAM,CAACgG,IAAtB,EAA4BnO,GAA5B,CAAgCmI,MAAM,CAAC8W,UAAvC,EAAmD9W,MAAnD;AACD;AACF;;AACDwX,EAAAA,mBAAmB,CAACxX,MAAD,EAAS;AAC1B,QAAIyX,cAAc,GAAG,KAAKC,eAAL,CAAqB1X,MAAM,CAACpI,IAA5B,CAArB;;AACA,QAAI6f,cAAc,KAAK,IAAnB,IAA2BzX,MAAM,CAAC8W,UAAP,KAAsB,IAArD,EAA2D;AACzDW,MAAAA,cAAc,GAAG,KAAKE,eAAL,CAAqB3X,MAAM,CAACgG,IAA5B,EAAkChG,MAAM,CAAC8W,UAAzC,CAAjB;AACD;;AACD,WAAOW,cAAP;AACD;;AACDE,EAAAA,eAAe,CAAC3R,IAAD,EAAO8Q,UAAP,EAAmB;AAChC,QAAI,CAAC,KAAKO,KAAL,CAAW/f,GAAX,CAAe0O,IAAf,CAAL,EAA2B;AACzB,aAAO,IAAP;AACD;;AACD,UAAMgE,IAAI,GAAG,KAAKqN,KAAL,CAAW9f,GAAX,CAAeyO,IAAf,CAAb;;AACA,QAAI,CAACgE,IAAI,CAAC1S,GAAL,CAASwf,UAAT,CAAL,EAA2B;AACzB,aAAO,IAAP;AACD;;AACD,WAAO9M,IAAI,CAACzS,GAAL,CAASuf,UAAT,CAAP;AACD;;AACDY,EAAAA,eAAe,CAAC9f,IAAD,EAAO;AACpB,QAAI,CAAC,KAAK0f,YAAL,CAAkBhgB,GAAlB,CAAsBM,IAAtB,CAAL,EAAkC;AAChC,aAAO,IAAP;AACD;;AACD,WAAO,KAAK0f,YAAL,CAAkB/f,GAAlB,CAAsBK,IAAtB,CAAP;AACD;;AApC0B,CAA7B;AAsCA,IAAIggB,uBAAuB,GAAG,MAAM;AAClCjjB,EAAAA,WAAW,CAACkjB,UAAD,EAAa;AACtB,SAAKA,UAAL,GAAkBA,UAAlB;AACA,SAAKC,QAAL,GAAgB,IAAIV,gBAAJ,EAAhB;AACA,SAAKW,aAAL,GAAqB,IAAIrgB,GAAJ,EAArB;AACD;;AACD6f,EAAAA,cAAc,CAACvX,MAAD,EAAS;AACrB,SAAK8X,QAAL,CAAcP,cAAd,CAA6BvX,MAA7B;AACD;;AACDgY,EAAAA,QAAQ,GAAG;AACT,QAAI,KAAKH,UAAL,KAAoB,IAAxB,EAA8B;AAC5B,aAAO;AACLI,QAAAA,SAAS,EAAE,IAAI1P,GAAJ,EADN;AAEL2P,QAAAA,kBAAkB,EAAE,IAAI3P,GAAJ,EAFf;AAGLuP,QAAAA,QAAQ,EAAE,KAAKA;AAHV,OAAP;AAKD;;AACD,UAAMG,SAAS,GAAG,KAAKE,yBAAL,CAA+B,KAAKN,UAApC,CAAlB;AACA,UAAMK,kBAAkB,GAAG,KAAKE,kCAAL,CAAwC,KAAKP,UAA7C,CAA3B;AACA,WAAO;AACLI,MAAAA,SADK;AAELC,MAAAA,kBAFK;AAGLJ,MAAAA,QAAQ,EAAE,KAAKA;AAHV,KAAP;AAKD;;AACDK,EAAAA,yBAAyB,CAACN,UAAD,EAAa;AACpC,UAAMX,mBAAmB,GAAG,IAAI3O,GAAJ,EAA5B;;AACA,SAAK,MAAMvI,MAAX,IAAqB,KAAK8X,QAAL,CAAcR,YAAd,CAA2Be,MAA3B,EAArB,EAA0D;AACxD,YAAMZ,cAAc,GAAGI,UAAU,CAACL,mBAAX,CAA+BxX,MAA/B,CAAvB;;AACA,UAAIyX,cAAc,KAAK,IAAnB,IAA2BzX,MAAM,CAACkX,mBAAP,CAA2BO,cAA3B,CAA/B,EAA2E;AACzEP,QAAAA,mBAAmB,CAACtD,GAApB,CAAwB5T,MAAxB;AACD;AACF;;AACD,UAAMiY,SAAS,GAAG,IAAI1P,GAAJ,EAAlB;;AACA,SAAK,MAAMvI,MAAX,IAAqB,KAAK8X,QAAL,CAAcR,YAAd,CAA2Be,MAA3B,EAArB,EAA0D;AACxD,UAAIrY,MAAM,CAACsY,cAAP,KAA0B,KAAK,CAAnC,EAAsC;AACpC;AACD;;AACD,YAAMb,cAAc,GAAGI,UAAU,CAACL,mBAAX,CAA+BxX,MAA/B,CAAvB;;AACA,UAAIyX,cAAc,KAAK,IAAnB,IAA2BzX,MAAM,CAACsY,cAAP,CAAsBb,cAAtB,EAAsCP,mBAAtC,CAA/B,EAA2F;AACzFe,QAAAA,SAAS,CAACrE,GAAV,CAAc5T,MAAM,CAACgG,IAArB;AACD;AACF;;AACD,WAAOiS,SAAP;AACD;;AACDG,EAAAA,kCAAkC,CAACP,UAAD,EAAa;AAC7C,UAAMV,sBAAsB,GAAG,IAAI5O,GAAJ,EAA/B;;AACA,SAAK,MAAMvI,MAAX,IAAqB,KAAK8X,QAAL,CAAcR,YAAd,CAA2Be,MAA3B,EAArB,EAA0D;AACxD,YAAMZ,cAAc,GAAGI,UAAU,CAACL,mBAAX,CAA+BxX,MAA/B,CAAvB;;AACA,UAAIyX,cAAc,KAAK,IAAnB,IAA2BzX,MAAM,CAACmX,sBAAP,CAA8BM,cAA9B,CAA/B,EAA8E;AAC5EN,QAAAA,sBAAsB,CAACvD,GAAvB,CAA2B5T,MAA3B;AACD;AACF;;AACD,UAAMkY,kBAAkB,GAAG,IAAI3P,GAAJ,EAA3B;;AACA,SAAK,MAAMvI,MAAX,IAAqB,KAAK8X,QAAL,CAAcR,YAAd,CAA2Be,MAA3B,EAArB,EAA0D;AACxD,UAAIrY,MAAM,CAACuY,wBAAP,KAAoC,KAAK,CAA7C,EAAgD;AAC9C;AACD;;AACD,YAAMd,cAAc,GAAGI,UAAU,CAACL,mBAAX,CAA+BxX,MAA/B,CAAvB;;AACA,UAAIyX,cAAc,KAAK,IAAnB,IAA2BzX,MAAM,CAACuY,wBAAP,CAAgCd,cAAhC,EAAgDN,sBAAhD,CAA/B,EAAwG;AACtGe,QAAAA,kBAAkB,CAACtE,GAAnB,CAAuB5T,MAAM,CAACgG,IAA9B;AACD;AACF;;AACD,WAAOkS,kBAAP;AACD;;AACDM,EAAAA,oBAAoB,CAAC5gB,IAAD,EAAOqM,IAAP,EAAa;AAC/B,WAAO;AACLjE,MAAAA,MAAM,EAAE,KAAKyY,SAAL,CAAe7gB,IAAf,CADH;AAEL8gB,MAAAA,UAAU,EAAEC,aAAa,CAAC1U,IAAD;AAFpB,KAAP;AAID;;AACDwU,EAAAA,SAAS,CAAC7gB,IAAD,EAAO;AACd,UAAMoI,MAAM,GAAG,KAAK8X,QAAL,CAAcJ,eAAd,CAA8B9f,IAA9B,CAAf;;AACA,QAAIoI,MAAM,KAAK,IAAf,EAAqB;AACnB,aAAO,KAAK4Y,eAAL,CAAqBhhB,IAArB,CAAP;AACD;;AACD,WAAOoI,MAAP;AACD;;AACD4Y,EAAAA,eAAe,CAAChhB,IAAD,EAAO;AACpB,QAAI,KAAKmgB,aAAL,CAAmBzgB,GAAnB,CAAuBM,IAAvB,CAAJ,EAAkC;AAChC,aAAO,KAAKmgB,aAAL,CAAmBxgB,GAAnB,CAAuBK,IAAvB,CAAP;AACD;;AACD,UAAMoI,MAAM,GAAG,IAAIiX,YAAJ,CAAiBrf,IAAjB,CAAf;AACA,SAAKmgB,aAAL,CAAmBlgB,GAAnB,CAAuBD,IAAvB,EAA6BoI,MAA7B;AACA,WAAOA,MAAP;AACD;;AArFiC,CAApC;;AAuFA,SAAS2Y,aAAT,CAAuB1U,IAAvB,EAA6B;AAC3B,MAAIA,IAAI,YAAY+S,aAApB,EAAmC;AACjC,WAAQ,GAAE/S,IAAI,CAAC1O,KAAL,CAAW0Z,UAAW,IAAGhL,IAAI,CAAC1O,KAAL,CAAW8B,IAAK,EAAnD;AACD,GAFD,MAEO;AACL,WAAO,IAAP;AACD;AACF,C,CAED;;;AACA,OAAOwhB,GAAP,MAAgB,YAAhB,C,CAEA;;AACA,SAASC,aAAT,CAAuBje,CAAvB,EAA0BC,CAA1B,EAA6B;AAC3B,MAAID,CAAC,CAACjD,IAAF,KAAWkD,CAAC,CAAClD,IAAjB,EAAuB;AACrB,WAAO,IAAP;AACD;;AACD,MAAIiD,CAAC,CAACic,UAAF,KAAiB,IAAjB,IAAyBhc,CAAC,CAACgc,UAAF,KAAiB,IAA9C,EAAoD;AAClD,WAAO,KAAP;AACD;;AACD,SAAOjc,CAAC,CAACmL,IAAF,KAAWlL,CAAC,CAACkL,IAAb,IAAqBnL,CAAC,CAACic,UAAF,KAAiBhc,CAAC,CAACgc,UAA/C;AACD;;AACD,SAASiC,gBAAT,CAA0Ble,CAA1B,EAA6BC,CAA7B,EAAgC;AAC9B,MAAI,CAACge,aAAa,CAACje,CAAC,CAACmF,MAAH,EAAWlF,CAAC,CAACkF,MAAb,CAAlB,EAAwC;AACtC,WAAO,KAAP;AACD;;AACD,SAAOnF,CAAC,CAAC6d,UAAF,KAAiB5d,CAAC,CAAC4d,UAA1B;AACD;;AACD,SAASM,iBAAT,CAA2Bne,CAA3B,EAA8BC,CAA9B,EAAiC;AAC/B,SAAOD,CAAC,KAAKC,CAAb;AACD;;AACD,SAASme,YAAT,CAAsBpe,CAAtB,EAAyBC,CAAzB,EAA4Boe,cAAc,GAAGF,iBAA7C,EAAgE;AAC9D,MAAIne,CAAC,KAAK,IAAN,IAAcC,CAAC,KAAK,IAAxB,EAA8B;AAC5B,WAAOD,CAAC,KAAKC,CAAb;AACD;;AACD,MAAID,CAAC,CAACxC,MAAF,KAAayC,CAAC,CAACzC,MAAnB,EAA2B;AACzB,WAAO,KAAP;AACD;;AACD,SAAO,CAACwC,CAAC,CAAC2M,IAAF,CAAO,CAAC2R,IAAD,EAAOjU,KAAP,KAAiB,CAACgU,cAAc,CAACC,IAAD,EAAOre,CAAC,CAACoK,KAAD,CAAR,CAAvC,CAAR;AACD;;AACD,SAASkU,UAAT,CAAoBve,CAApB,EAAuBC,CAAvB,EAA0Boe,cAAc,GAAGF,iBAA3C,EAA8D;AAC5D,MAAIne,CAAC,KAAK,IAAN,IAAcC,CAAC,KAAK,IAAxB,EAA8B;AAC5B,WAAOD,CAAC,KAAKC,CAAb;AACD;;AACD,MAAID,CAAC,CAACwe,IAAF,KAAWve,CAAC,CAACue,IAAjB,EAAuB;AACrB,WAAO,KAAP;AACD;;AACD,OAAK,MAAMC,KAAX,IAAoBze,CAApB,EAAuB;AACrB,QAAI0e,KAAK,GAAG,KAAZ;;AACA,SAAK,MAAMC,KAAX,IAAoB1e,CAApB,EAAuB;AACrB,UAAIoe,cAAc,CAACI,KAAD,EAAQE,KAAR,CAAlB,EAAkC;AAChCD,QAAAA,KAAK,GAAG,IAAR;AACA;AACD;AACF;;AACD,QAAI,CAACA,KAAL,EAAY;AACV,aAAO,KAAP;AACD;AACF;;AACD,SAAO,IAAP;AACD,C,CAED;;;AACA,SAASE,6BAAT,CAAuC7kB,IAAvC,EAA6C;AAC3C,MAAI,CAACikB,GAAG,CAACa,kBAAJ,CAAuB9kB,IAAvB,CAAD,IAAiCA,IAAI,CAAC+kB,cAAL,KAAwB,KAAK,CAAlE,EAAqE;AACnE,WAAO,IAAP;AACD;;AACD,SAAO/kB,IAAI,CAAC+kB,cAAL,CAAoBliB,GAApB,CAAyBmiB,SAAD,KAAgB;AAAEC,IAAAA,mBAAmB,EAAED,SAAS,CAACE,UAAV,KAAyB,KAAK;AAArD,GAAhB,CAAxB,CAAP;AACD;;AACD,SAASC,sBAAT,CAAgCC,OAAhC,EAAyCC,QAAzC,EAAmD;AACjD,MAAI,CAAChB,YAAY,CAACe,OAAD,EAAUC,QAAV,EAAoBC,oBAApB,CAAjB,EAA4D;AAC1D,WAAO,KAAP;AACD;;AACD,MAAIF,OAAO,KAAK,IAAZ,IAAoBA,OAAO,CAACxS,IAAR,CAAcoS,SAAD,IAAeA,SAAS,CAACC,mBAAtC,CAAxB,EAAoF;AAClF,WAAO,KAAP;AACD;;AACD,SAAO,IAAP;AACD;;AACD,SAASK,oBAAT,CAA8Brf,CAA9B,EAAiCC,CAAjC,EAAoC;AAClC,SAAOD,CAAC,CAACgf,mBAAF,KAA0B/e,CAAC,CAAC+e,mBAAnC;AACD,C,CAED;;;AACA,IAAIM,QAAJ;;AACA,CAAC,UAASC,SAAT,EAAoB;AACnBA,EAAAA,SAAS,CAACA,SAAS,CAAC,MAAD,CAAT,GAAoB,CAArB,CAAT,GAAmC,MAAnC;AACAA,EAAAA,SAAS,CAACA,SAAS,CAAC,WAAD,CAAT,GAAyB,CAA1B,CAAT,GAAwC,WAAxC;AACD,CAHD,EAGGD,QAAQ,KAAKA,QAAQ,GAAG,EAAhB,CAHX,E,CAKA;;;AACA,OAAOE,GAAP,MAAgB,YAAhB,C,CAEA;;AACA,IAAIC,oBAAoB,GAAG,MAAM;AAC/B3lB,EAAAA,WAAW,CAAC4lB,UAAD,EAAa;AACtB,SAAKA,UAAL,GAAkBA,UAAlB;AACA,SAAKC,UAAL,GAAkBC,wBAAwB,CAACF,UAAD,CAA1C;AACD;;AACW,SAALG,KAAK,GAAG;AACb,WAAO,IAAIJ,oBAAJ,CAAyB,IAAI5iB,GAAJ,EAAzB,CAAP;AACD;;AACsB,SAAhBijB,gBAAgB,CAACC,GAAD,EAAM;AAC3B,UAAML,UAAU,GAAG,IAAI7iB,GAAJ,EAAnB;;AACA,SAAK,MAAMmjB,iBAAX,IAAgCC,MAAM,CAACC,IAAP,CAAYH,GAAZ,CAAhC,EAAkD;AAChD,YAAMrlB,KAAK,GAAGqlB,GAAG,CAACC,iBAAD,CAAjB;AACA,YAAMG,mBAAmB,GAAGtiB,KAAK,CAACC,OAAN,CAAcpD,KAAd,IAAuBA,KAAK,CAAC,CAAD,CAA5B,GAAkCA,KAA9D;AACA,YAAM0lB,aAAa,GAAG;AAAEJ,QAAAA,iBAAF;AAAqBG,QAAAA;AAArB,OAAtB;AACAT,MAAAA,UAAU,CAAC1iB,GAAX,CAAegjB,iBAAf,EAAkCI,aAAlC;AACD;;AACD,WAAO,IAAIX,oBAAJ,CAAyBC,UAAzB,CAAP;AACD;;AACW,SAALW,KAAK,CAACrgB,CAAD,EAAIC,CAAJ,EAAO;AACjB,UAAMyf,UAAU,GAAG,IAAI7iB,GAAJ,CAAQmD,CAAC,CAAC0f,UAAF,CAAa1P,OAAb,EAAR,CAAnB;;AACA,SAAK,MAAM,CAACgQ,iBAAD,EAAoBI,aAApB,CAAX,IAAiDngB,CAAC,CAACyf,UAAnD,EAA+D;AAC7DA,MAAAA,UAAU,CAAC1iB,GAAX,CAAegjB,iBAAf,EAAkCI,aAAlC;AACD;;AACD,WAAO,IAAIX,oBAAJ,CAAyBC,UAAzB,CAAP;AACD;;AACqB,MAAlBY,kBAAkB,GAAG;AACvB,WAAOziB,KAAK,CAACa,IAAN,CAAW,KAAKghB,UAAL,CAAgBQ,IAAhB,EAAX,CAAP;AACD;;AACgB,MAAbK,aAAa,GAAG;AAClB,WAAO1iB,KAAK,CAACa,IAAN,CAAW,KAAKihB,UAAL,CAAgBO,IAAhB,EAAX,CAAP;AACD;;AACDM,EAAAA,sBAAsB,CAAC9U,YAAD,EAAe;AACnC,WAAO,KAAKiU,UAAL,CAAgBljB,GAAhB,CAAoBiP,YAApB,CAAP;AACD;;AACD+U,EAAAA,wBAAwB,CAAC/U,YAAD,EAAe;AACrC,WAAO,KAAKiU,UAAL,CAAgBljB,GAAhB,CAAoBiP,YAApB,IAAoC,KAAKiU,UAAL,CAAgBjjB,GAAhB,CAAoBgP,YAApB,CAApC,GAAwE,IAA/E;AACD;;AACDgV,EAAAA,sBAAsB,CAACV,iBAAD,EAAoB;AACxC,WAAO,KAAKN,UAAL,CAAgBjjB,GAAhB,CAAoBujB,iBAApB,IAAyC,KAAKN,UAAL,CAAgBhjB,GAAhB,CAAoBsjB,iBAApB,CAAzC,GAAkF,IAAzF;AACD;;AACDW,EAAAA,oBAAoB,GAAG;AACrB,UAAMZ,GAAG,GAAG,EAAZ;;AACA,SAAK,MAAM,CAACC,iBAAD,EAAoBI,aAApB,CAAX,IAAiD,KAAKV,UAAtD,EAAkE;AAChEK,MAAAA,GAAG,CAACC,iBAAD,CAAH,GAAyBI,aAAa,CAACD,mBAAvC;AACD;;AACD,WAAOJ,GAAP;AACD;;AACDa,EAAAA,mBAAmB,GAAG;AACpB,UAAMb,GAAG,GAAG,EAAZ;;AACA,SAAK,MAAM,CAACC,iBAAD,EAAoBI,aAApB,CAAX,IAAiD,KAAKV,UAAtD,EAAkE;AAChE,UAAIU,aAAa,CAACD,mBAAd,KAAsCH,iBAA1C,EAA6D;AAC3DD,QAAAA,GAAG,CAACC,iBAAD,CAAH,GAAyBI,aAAa,CAACD,mBAAvC;AACD,OAFD,MAEO;AACLJ,QAAAA,GAAG,CAACC,iBAAD,CAAH,GAAyB,CAACI,aAAa,CAACD,mBAAf,EAAoCH,iBAApC,CAAzB;AACD;AACF;;AACD,WAAOD,GAAP;AACD;;AACgB,IAAfc,MAAM,CAACC,QAAQ,IAAI;AACnB,SAAK,MAAM,CAACd,iBAAD,EAAoBI,aAApB,CAAX,IAAiD,KAAKV,UAAL,CAAgB1P,OAAhB,EAAjD,EAA4E;AAC1E,YAAM,CAACgQ,iBAAD,EAAoBI,aAAa,CAACD,mBAAlC,CAAN;AACD;AACF;;AA9D8B,CAAjC;;AAgEA,SAASP,wBAAT,CAAkCF,UAAlC,EAA8C;AAC5C,QAAMC,UAAU,GAAG,IAAI9iB,GAAJ,EAAnB;;AACA,OAAK,MAAM,CAACkkB,CAAD,EAAIX,aAAJ,CAAX,IAAiCV,UAAjC,EAA6C;AAC3C,QAAI,CAACC,UAAU,CAACljB,GAAX,CAAe2jB,aAAa,CAACD,mBAA7B,CAAL,EAAwD;AACtDR,MAAAA,UAAU,CAAC3iB,GAAX,CAAeojB,aAAa,CAACD,mBAA7B,EAAkD,EAAlD;AACD;;AACDR,IAAAA,UAAU,CAACjjB,GAAX,CAAe0jB,aAAa,CAACD,mBAA7B,EAAkDviB,IAAlD,CAAuDwiB,aAAvD;AACD;;AACD,SAAOT,UAAP;AACD,C,CAED;;;AACA,OAAOqB,GAAP,MAAgB,YAAhB;;AACA,SAASC,yBAAT,CAAmCnf,OAAnC,EAA4CqY,GAA5C,EAAiDxR,qBAAjD,EAAwE;AACtE,MAAI,CAACqY,GAAG,CAAClV,eAAJ,CAAoBqO,GAApB,CAAL,EAA+B;AAC7B,WAAO,EAAP;AACD;;AACD,SAAOA,GAAG,CAAC1V,QAAJ,CAAa7H,GAAb,CAAkB8H,OAAD,IAAa;AACnC,QAAI,CAACsc,GAAG,CAACE,eAAJ,CAAoBxc,OAApB,CAAL,EAAmC;AACjC,YAAM,IAAIlF,KAAJ,CAAW,2BAA0BtG,aAAa,CAACwL,OAAD,CAAU,EAA5D,CAAN;AACD;;AACD,UAAMiD,IAAI,GAAGjD,OAAO,CAACyc,QAArB;AACA,UAAM;AAAEpnB,MAAAA,IAAF;AAAQ2E,MAAAA;AAAR,QAAiBnG,8BAA8B,CAACoP,IAAD,EAAO7F,OAAP,CAArD;;AACA,QAAI,CAACzJ,uBAAuB,CAAC0B,IAAD,CAA5B,EAAoC;AAClC,YAAM,IAAIyF,KAAJ,CAAW,oCAAmCtG,aAAa,CAACa,IAAD,CAAO,EAAlE,CAAN;AACD;;AACD,QAAI2E,IAAI,KAAK,IAAT,IAAiB,CAACA,IAAI,CAAC0iB,UAAL,CAAgB,GAAhB,CAAtB,EAA4C;AAC1C,aAAO,IAAIzoB,SAAJ,CAAcoB,IAAd,EAAoB;AAAEyP,QAAAA,SAAS,EAAE9K,IAAb;AAAmB+K,QAAAA,iBAAiB,EAAE0Q,GAAG,CAACphB,aAAJ,GAAoBkU;AAA1D,OAApB,CAAP;AACD,KAFD,MAEO;AACL,aAAO,IAAItU,SAAJ,CAAcoB,IAAd,EAAoB4O,qBAApB,CAAP;AACD;AACF,GAdM,CAAP;AAeD;;AACD,SAAS0Y,cAAT,CAAwB1Z,IAAxB,EAA8B;AAC5B,MAAI,CAACqZ,GAAG,CAACnV,iBAAJ,CAAsBlE,IAAtB,CAAD,IAAgC,CAACqZ,GAAG,CAACze,eAAJ,CAAoBoF,IAAI,CAAChI,OAAzB,CAArC,EAAwE;AACtE,WAAO,IAAP;AACD;;AACD,SAAOgI,IAAI,CAAChI,OAAL,CAAa6C,IAApB;AACD;;AACD,SAAS8e,iBAAT,CAA2B3Z,IAA3B,EAAiC;AAC/B,MAAI,CAACqZ,GAAG,CAACO,iBAAJ,CAAsB5Z,IAAtB,CAAL,EAAkC;AAChC,WAAO,EAAP;AACD;;AACD,QAAMoY,GAAG,GAAG,EAAZ;AACApY,EAAAA,IAAI,CAACG,OAAL,CAAahL,OAAb,CAAsBiL,MAAD,IAAY;AAC/B,QAAI,CAACiZ,GAAG,CAACQ,mBAAJ,CAAwBzZ,MAAxB,CAAD,IAAoCA,MAAM,CAACJ,IAAP,KAAgB,KAAK,CAAzD,IAA8DI,MAAM,CAACvL,IAAP,KAAgB,KAAK,CAAnF,IAAwF,CAACwkB,GAAG,CAACze,eAAJ,CAAoBwF,MAAM,CAACvL,IAA3B,CAA7F,EAA+H;AAC7H;AACD;;AACD,UAAM9B,KAAK,GAAG2mB,cAAc,CAACtZ,MAAM,CAACJ,IAAR,CAA5B;;AACA,QAAIjN,KAAK,KAAK,IAAd,EAAoB;AAClB,aAAO,IAAP;AACD;;AACDqlB,IAAAA,GAAG,CAAChY,MAAM,CAACvL,IAAP,CAAYgG,IAAb,CAAH,GAAwB9H,KAAxB;AACD,GATD;AAUA,SAAOqlB,GAAP;AACD;;AACD,SAAS0B,mBAAT,CAA6B9Z,IAA7B,EAAmC;AACjC,MAAI,CAACqZ,GAAG,CAAClV,eAAJ,CAAoBnE,IAApB,CAAL,EAAgC;AAC9B,WAAO,EAAP;AACD;;AACD,QAAMgC,GAAG,GAAG,EAAZ;AACAhC,EAAAA,IAAI,CAAClD,QAAL,CAAc3H,OAAd,CAAuB4kB,EAAD,IAAQ;AAC5B,QAAI,CAACV,GAAG,CAACnV,iBAAJ,CAAsB6V,EAAtB,CAAD,IAA8B,CAACV,GAAG,CAACze,eAAJ,CAAoBmf,EAAE,CAAC/hB,OAAvB,CAAnC,EAAoE;AAClE;AACD;;AACDgK,IAAAA,GAAG,CAAC/L,IAAJ,CAAS8jB,EAAE,CAAC/hB,OAAH,CAAW6C,IAApB;AACD,GALD;AAMA,SAAOmH,GAAP;AACD;;AACD,SAASgY,6BAAT,CAAuC5nB,IAAvC,EAA6C6nB,MAA7C,EAAqDpP,SAArD,EAAgE;AAC9D,QAAM1K,OAAO,GAAG0K,SAAS,CAAC5J,iBAAV,CAA4B7O,IAA5B,CAAhB;AACA,QAAM8nB,aAAa,GAAG/Z,OAAO,CAACyL,MAAR,CAAgBxL,MAAD,IAAYA,MAAM,CAACgB,QAAlC,CAAtB;AACA,QAAM+Y,gBAAgB,GAAGD,aAAa,CAACjlB,GAAd,CAAkBmlB,oBAAlB,EAAwCxO,MAAxC,CAAgDyO,KAAD,IAAWA,KAAK,KAAK,IAApE,CAAzB;AACA,QAAMC,yBAAyB,GAAGJ,aAAa,CAAClV,IAAd,CAAoB5E,MAAD,IAAYA,MAAM,CAAC5F,IAAP,KAAgBnK,eAAe,CAACkqB,MAAhC,IAA0Cna,MAAM,CAACvL,IAAP,KAAgB,wBAAzF,CAAlC;AACA,QAAM2lB,kBAAkB,GAAG,IAAIzU,GAAJ,CAAQmU,aAAa,CAACjlB,GAAd,CAAkBwlB,mBAAlB,EAAuC7O,MAAvC,CAA+C8O,SAAD,IAAeA,SAAS,KAAK,IAA3E,CAAR,CAA3B;AACA,QAAMC,qBAAqB,GAAG,IAAI5U,GAAJ,EAA9B;AACA,QAAM6U,wBAAwB,GAAG,IAAI7U,GAAJ,EAAjC;AACA,QAAM8U,qBAAqB,GAAG,IAAI9U,GAAJ,EAA9B;;AACA,OAAK,MAAMsS,iBAAX,IAAgC4B,MAAM,CAACtB,kBAAvC,EAA2D;AACzD,UAAMmC,KAAK,GAAG3a,OAAO,CAACe,IAAR,CAAcd,MAAD,IAAYA,MAAM,CAACvL,IAAP,KAAgBwjB,iBAAzC,CAAd;;AACA,QAAIyC,KAAK,KAAK,KAAK,CAAf,IAAoBA,KAAK,CAAC1oB,IAAN,KAAe,IAAvC,EAA6C;AAC3CyoB,MAAAA,qBAAqB,CAACzJ,GAAtB,CAA0BiH,iBAA1B;AACA;AACD;;AACD,QAAI0C,YAAY,CAACD,KAAK,CAAC1oB,IAAP,CAAhB,EAA8B;AAC5BuoB,MAAAA,qBAAqB,CAACvJ,GAAtB,CAA0BiH,iBAA1B;AACD;;AACD,QAAIyC,KAAK,CAACvN,QAAN,KAAmB,IAAnB,IAA2B8L,GAAG,CAACze,eAAJ,CAAoBkgB,KAAK,CAACvN,QAA1B,CAA/B,EAAoE;AAClEqN,MAAAA,wBAAwB,CAACxJ,GAAzB,CAA6BiH,iBAA7B;AACD;AACF;;AACD,QAAM2C,KAAK,GAAGnQ,SAAS,CAACoQ,sBAAV,CAAiC7oB,IAAjC,CAAd;AACA,SAAO;AACLkoB,IAAAA,yBADK;AAELH,IAAAA,gBAFK;AAGLK,IAAAA,kBAHK;AAILG,IAAAA,qBAJK;AAKLC,IAAAA,wBALK;AAMLC,IAAAA,qBANK;AAOLK,IAAAA,SAAS,EAAEF,KAAK,KAAK,IAAV,IAAkBA,KAAK,GAAG;AAPhC,GAAP;AASD;;AACD,SAASD,YAAT,CAAsB3oB,IAAtB,EAA4B;AAC1B,MAAIA,IAAI,CAAC2S,SAAL,KAAmB,KAAK,CAA5B,EAA+B;AAC7B,WAAO,KAAP;AACD;;AACD,SAAO3S,IAAI,CAAC2S,SAAL,CAAeC,IAAf,CAAqBmW,QAAD,IAAcA,QAAQ,CAAC3gB,IAAT,KAAkB6e,GAAG,CAAClhB,UAAJ,CAAeijB,cAAjC,IAAmDD,QAAQ,CAAC3gB,IAAT,KAAkB6e,GAAG,CAAClhB,UAAJ,CAAekjB,gBAApF,IAAwGF,QAAQ,CAAC3gB,IAAT,KAAkB6e,GAAG,CAAClhB,UAAJ,CAAemjB,eAA3K,CAAP;AACD;;AACD,SAASlB,oBAAT,CAA8Bha,MAA9B,EAAsC;AACpC,MAAI,CAACA,MAAM,CAACvL,IAAP,CAAY4kB,UAAZ,CAAuB,kBAAvB,CAAL,EAAiD;AAC/C,WAAO,IAAP;AACD;;AACD,QAAMiB,SAAS,GAAGa,eAAe,CAACnb,MAAM,CAACvL,IAAR,CAAjC;;AACA,MAAIuL,MAAM,CAAC5F,IAAP,KAAgBnK,eAAe,CAACmrB,QAApC,EAA8C;AAC5C,QAAIxb,IAAI,GAAG,IAAX;;AACA,QAAII,MAAM,CAACJ,IAAP,KAAgB,IAAhB,IAAwBqZ,GAAG,CAACnV,iBAAJ,CAAsB9D,MAAM,CAACJ,IAA7B,CAAxB,IAA8DqZ,GAAG,CAACze,eAAJ,CAAoBwF,MAAM,CAACJ,IAAP,CAAYhI,OAAhC,CAAlE,EAA4G;AAC1GgI,MAAAA,IAAI,GAAGI,MAAM,CAACJ,IAAP,CAAYhI,OAAZ,CAAoB6C,IAA3B;AACD;;AACD,QAAImF,IAAI,KAAK,SAAb,EAAwB;AACtB,aAAO,IAAP;AACD;;AACD,WAAO;AAAE0a,MAAAA,SAAF;AAAa1a,MAAAA;AAAb,KAAP;AACD,GATD,MASO,IAAII,MAAM,CAAC5F,IAAP,KAAgBnK,eAAe,CAACkqB,MAApC,EAA4C;AACjD,WAAO;AAAEG,MAAAA,SAAF;AAAa1a,MAAAA,IAAI,EAAE;AAAnB,KAAP;AACD,GAFM,MAEA;AACL,WAAO,IAAP;AACD;AACF;;AACD,SAASya,mBAAT,CAA6Bra,MAA7B,EAAqC;AACnC,MAAIA,MAAM,CAAC5F,IAAP,KAAgBnK,eAAe,CAACmrB,QAAhC,IAA4C,CAACpb,MAAM,CAACvL,IAAP,CAAY4kB,UAAZ,CAAuB,oBAAvB,CAAjD,EAA+F;AAC7F,WAAO,IAAP;AACD;;AACD,SAAO8B,eAAe,CAACnb,MAAM,CAACvL,IAAR,CAAtB;AACD;;AACD,IAAI4mB,sBAAsB,GAAG,MAAM;AACjCtpB,EAAAA,WAAW,CAACupB,OAAD,EAAU;AACnB,SAAKA,OAAL,GAAeA,OAAf;AACD;;AACDC,EAAAA,oBAAoB,CAACvpB,IAAD,EAAO;AACzB,SAAK,MAAMwpB,MAAX,IAAqB,KAAKF,OAA1B,EAAmC;AACjC,YAAMxrB,IAAI,GAAG0rB,MAAM,CAACD,oBAAP,CAA4BvpB,IAA5B,CAAb;;AACA,UAAIlC,IAAI,KAAK,IAAb,EAAmB;AACjB,eAAOA,IAAP;AACD;AACF;;AACD,WAAO,IAAP;AACD;;AACD2rB,EAAAA,mBAAmB,CAACzpB,IAAD,EAAO;AACxB,SAAK,MAAMwpB,MAAX,IAAqB,KAAKF,OAA1B,EAAmC;AACjC,YAAMxrB,IAAI,GAAG0rB,MAAM,CAACC,mBAAP,CAA2BzpB,IAA3B,CAAb;;AACA,UAAIlC,IAAI,KAAK,IAAb,EAAmB;AACjB,eAAOA,IAAP;AACD;AACF;;AACD,WAAO,IAAP;AACD;;AACD4rB,EAAAA,eAAe,CAAC1pB,IAAD,EAAO;AACpB,SAAK,MAAMwpB,MAAX,IAAqB,KAAKF,OAA1B,EAAmC;AACjC,YAAMxrB,IAAI,GAAG0rB,MAAM,CAACE,eAAP,CAAuB1pB,IAAvB,CAAb;;AACA,UAAIlC,IAAI,KAAK,IAAb,EAAmB;AACjB,eAAOA,IAAP;AACD;AACF;;AACD,WAAO,IAAP;AACD;;AA9BgC,CAAnC;;AAgCA,SAASqrB,eAAT,CAAyBQ,GAAzB,EAA8B;AAC5B,QAAMzM,GAAG,GAAGyM,GAAG,CAACjY,OAAJ,CAAY,GAAZ,CAAZ;;AACA,MAAIwL,GAAG,KAAK,CAAC,CAAb,EAAgB;AACd,UAAM,IAAIzX,KAAJ,CAAW,aAAYkkB,GAAI,kBAA3B,CAAN;AACD;;AACD,SAAOA,GAAG,CAACC,MAAJ,CAAW1M,GAAG,GAAG,CAAjB,CAAP;AACD;;AACD,SAAS2M,mBAAT,CAA6BrR,KAA7B,EAAoC1Q,IAApC,EAA0C;AACxC,QAAMiG,OAAO,GAAGjG,IAAI,CAAC+G,iBAAL,CAAuB2J,KAAvB,CAAhB;AACA,SAAOzK,OAAO,CAAC6E,IAAR,CAAa,CAAC;AAAE5D,IAAAA,QAAF;AAAYvM,IAAAA;AAAZ,GAAD,KAAwBuM,QAAQ,KAAKvM,IAAI,KAAK,YAAT,IAAyBA,IAAI,KAAK,WAAvC,CAA7C,CAAP;AACD,C,CAED;;;AACA,IAAIqnB,iBAAiB,GAAG,MAAM;AAC5B/pB,EAAAA,WAAW,CAACgI,OAAD,EAAU0Q,SAAV,EAAqB;AAC9B,SAAK1Q,OAAL,GAAeA,OAAf;AACA,SAAK0Q,SAAL,GAAiBA,SAAjB;AACD;;AACDgR,EAAAA,mBAAmB,CAAClpB,GAAD,EAAM;AACvB,UAAMiY,KAAK,GAAGjY,GAAG,CAACP,IAAlB;AACA,UAAM+pB,WAAW,GAAG,KAAKtR,SAAL,CAAe5J,iBAAf,CAAiC2J,KAAjC,EAAwC1J,IAAxC,CAA8Cd,MAAD,IAAYA,MAAM,CAACvL,IAAP,KAAgB,WAAhB,IAA+BuL,MAAM,CAACgB,QAA/F,CAApB;;AACA,QAAI+a,WAAW,KAAK,KAAK,CAAzB,EAA4B;AAC1B,aAAO,IAAP;AACD,KAFD,MAEO,IAAIA,WAAW,CAACnc,IAAZ,KAAqB,IAArB,IAA6B,CAAC6X,GAAG,CAACuE,mBAAJ,CAAwBD,WAAW,CAACnc,IAApC,CAA9B,IAA2Emc,WAAW,CAACnc,IAAZ,CAAiBqc,aAAjB,KAAmC,KAAK,CAAnH,IAAwHF,WAAW,CAACnc,IAAZ,CAAiBqc,aAAjB,CAA+BxmB,MAA/B,KAA0C,CAAtK,EAAyK;AAC9K,aAAO,IAAP;AACD;;AACD,UAAM,CAACujB,CAAD,EAAIkD,mBAAJ,EAAyBC,cAAzB,EAAyCC,cAAzC,IAA2DL,WAAW,CAACnc,IAAZ,CAAiBqc,aAAlF;AACA,WAAO;AACL1pB,MAAAA,GADK;AAEL6N,MAAAA,YAAY,EAAE8Y,yBAAyB,CAAC,KAAKnf,OAAN,EAAemiB,mBAAf,EAAoC3pB,GAAG,CAACqO,qBAAxC,CAFlC;AAGLtM,MAAAA,OAAO,EAAE4kB,yBAAyB,CAAC,KAAKnf,OAAN,EAAeqiB,cAAf,EAA+B7pB,GAAG,CAACqO,qBAAnC,CAH7B;AAILyb,MAAAA,OAAO,EAAEnD,yBAAyB,CAAC,KAAKnf,OAAN,EAAeoiB,cAAf,EAA+B5pB,GAAG,CAACqO,qBAAnC,CAJ7B;AAKL0b,MAAAA,OAAO,EAAE,EALJ;AAMLrM,MAAAA,eAAe,EAAE;AANZ,KAAP;AAQD;;AACDsL,EAAAA,oBAAoB,CAAChpB,GAAD,EAAM;AACxB,UAAMiY,KAAK,GAAGjY,GAAG,CAACP,IAAlB;AACA,UAAMogB,GAAG,GAAG,KAAK3H,SAAL,CAAe5J,iBAAf,CAAiC2J,KAAjC,EAAwC1J,IAAxC,CAA8C4Z,KAAD,IAAWA,KAAK,CAAC1Z,QAAN,KAAmB0Z,KAAK,CAACjmB,IAAN,KAAe,WAAf,IAA8BimB,KAAK,CAACjmB,IAAN,KAAe,WAAhE,CAAxD,CAAZ;;AACA,QAAI2d,GAAG,KAAK,KAAK,CAAjB,EAAoB;AAClB,aAAO,IAAP;AACD,KAFD,MAEO,IAAIA,GAAG,CAACxS,IAAJ,KAAa,IAAb,IAAqB,CAAC6X,GAAG,CAACuE,mBAAJ,CAAwB5J,GAAG,CAACxS,IAA5B,CAAtB,IAA2DwS,GAAG,CAACxS,IAAJ,CAASqc,aAAT,KAA2B,KAAK,CAA3F,IAAgG7J,GAAG,CAACxS,IAAJ,CAASqc,aAAT,CAAuBxmB,MAAvB,GAAgC,CAApI,EAAuI;AAC5I,aAAO,IAAP;AACD;;AACD,UAAM8mB,WAAW,GAAGnK,GAAG,CAAC3d,IAAJ,KAAa,WAAjC;AACA,UAAMmW,UAAU,GAAG,KAAKH,SAAL,CAAeI,wBAAf,CAAwCL,KAAxC,CAAnB;AACA,UAAMgS,YAAY,GAAG,CAACD,WAAD,IAAgB3R,UAAU,KAAK,IAA/B,IAAuCA,UAAU,CAAChG,IAAX,CAAiBvC,KAAD,IAAW;AACrF,aAAOA,KAAK,CAAC6I,kBAAN,CAAyB9Q,IAAzB,KAAkC,CAAlC,IAAuCiI,KAAK,CAAC6I,kBAAN,CAAyBmB,UAAzB,KAAwC,eAA/E,IAAkGhK,KAAK,CAAC6I,kBAAN,CAAyBoB,YAAzB,KAA0C,aAAnJ;AACD,KAF2D,CAA5D;AAGA,UAAMuN,MAAM,GAAGnC,oBAAoB,CAACK,gBAArB,CAAsCwB,iBAAiB,CAACnH,GAAG,CAACxS,IAAJ,CAASqc,aAAT,CAAuB,CAAvB,CAAD,CAAvD,CAAf;AACA,UAAMQ,OAAO,GAAG/E,oBAAoB,CAACK,gBAArB,CAAsCwB,iBAAiB,CAACnH,GAAG,CAACxS,IAAJ,CAASqc,aAAT,CAAuB,CAAvB,CAAD,CAAvD,CAAhB;AACA,WAAOrqB,aAAa,CAACC,cAAc,CAAC;AAClC+N,MAAAA,IAAI,EAAE2X,QAAQ,CAACmF,SADmB;AAElCnqB,MAAAA,GAFkC;AAGlCkC,MAAAA,IAAI,EAAE+V,KAAK,CAAC/V,IAAN,CAAWgG,IAHiB;AAIlC8hB,MAAAA,WAJkC;AAKlCI,MAAAA,QAAQ,EAAErD,cAAc,CAAClH,GAAG,CAACxS,IAAJ,CAASqc,aAAT,CAAuB,CAAvB,CAAD,CALU;AAMlCW,MAAAA,QAAQ,EAAElD,mBAAmB,CAACtH,GAAG,CAACxS,IAAJ,CAASqc,aAAT,CAAuB,CAAvB,CAAD,CANK;AAOlCpC,MAAAA,MAPkC;AAQlC4C,MAAAA,OARkC;AASlCI,MAAAA,OAAO,EAAEnD,mBAAmB,CAACtH,GAAG,CAACxS,IAAJ,CAASqc,aAAT,CAAuB,CAAvB,CAAD;AATM,KAAD,EAUhCrC,6BAA6B,CAACpP,KAAD,EAAQqP,MAAR,EAAgB,KAAKpP,SAArB,CAVG,CAAf,EAU8C;AAChE8E,MAAAA,SAAS,EAAEuN,cAAc,CAACtS,KAAD,EAAQ,KAAKzQ,OAAb,EAAsB,KAAK0Q,SAA3B,CADuC;AAEhEsS,MAAAA,UAAU,EAAE,KAFoD;AAGhEP,MAAAA;AAHgE,KAV9C,CAApB;AAeD;;AACDd,EAAAA,eAAe,CAACnpB,GAAD,EAAM;AACnB,UAAM6f,GAAG,GAAG,KAAK3H,SAAL,CAAe5J,iBAAf,CAAiCtO,GAAG,CAACP,IAArC,EAA2C8O,IAA3C,CAAiD4Z,KAAD,IAAWA,KAAK,CAAC1Z,QAAN,IAAkB0Z,KAAK,CAACjmB,IAAN,KAAe,YAA5F,CAAZ;;AACA,QAAI2d,GAAG,KAAK,KAAK,CAAjB,EAAoB;AAClB,aAAO,IAAP;AACD,KAFD,MAEO,IAAIA,GAAG,CAACxS,IAAJ,KAAa,IAAb,IAAqB,CAAC6X,GAAG,CAACuE,mBAAJ,CAAwB5J,GAAG,CAACxS,IAA5B,CAAtB,IAA2DwS,GAAG,CAACxS,IAAJ,CAASqc,aAAT,KAA2B,KAAK,CAA3F,IAAgG7J,GAAG,CAACxS,IAAJ,CAASqc,aAAT,CAAuBxmB,MAAvB,GAAgC,CAApI,EAAuI;AAC5I,aAAO,IAAP;AACD;;AACD,UAAMmK,IAAI,GAAGwS,GAAG,CAACxS,IAAJ,CAASqc,aAAT,CAAuB,CAAvB,CAAb;;AACA,QAAI,CAACxE,GAAG,CAAC3T,iBAAJ,CAAsBlE,IAAtB,CAAD,IAAgC,CAAC6X,GAAG,CAACjd,eAAJ,CAAoBoF,IAAI,CAAChI,OAAzB,CAArC,EAAwE;AACtE,aAAO,IAAP;AACD;;AACD,UAAMnD,IAAI,GAAGmL,IAAI,CAAChI,OAAL,CAAa6C,IAA1B;AACA,WAAO;AACLmF,MAAAA,IAAI,EAAE2X,QAAQ,CAACyF,IADV;AAELzqB,MAAAA,GAFK;AAGLkC,MAAAA,IAHK;AAILwoB,MAAAA,QAAQ,EAAE;AAJL,KAAP;AAMD;;AAxE2B,CAA9B;;AA0EA,SAASH,cAAT,CAAwBtS,KAAxB,EAA+BzQ,OAA/B,EAAwC0Q,SAAxC,EAAmD;AACjD,MAAI,CAACna,uBAAuB,CAACka,KAAD,CAA5B,EAAqC;AACnC,WAAOC,SAAS,CAACK,YAAV,CAAuBN,KAAvB,IAAgC,SAAhC,GAA4C,IAAnD;AACD;;AACD,MAAIA,KAAK,CAAC0S,eAAN,KAA0B,KAAK,CAAnC,EAAsC;AACpC,SAAK,MAAMC,MAAX,IAAqB3S,KAAK,CAAC0S,eAA3B,EAA4C;AAC1C,UAAIC,MAAM,CAACnS,KAAP,KAAiByM,GAAG,CAAC1f,UAAJ,CAAeqlB,cAApC,EAAoD;AAClD,cAAMC,QAAQ,GAAGF,MAAM,CAACG,KAAP,CAAa,CAAb,EAAgBlhB,UAAjC;AACA,YAAIgB,MAAM,GAAGrD,OAAO,CAACwjB,mBAAR,CAA4BF,QAA5B,CAAb;;AACA,YAAIjgB,MAAM,KAAK,KAAK,CAApB,EAAuB;AACrB,iBAAO,SAAP;AACD,SAFD,MAEO,IAAIA,MAAM,CAACogB,KAAP,GAAe/F,GAAG,CAACgG,WAAJ,CAAgBC,KAAnC,EAA0C;AAC/CtgB,UAAAA,MAAM,GAAGrD,OAAO,CAAC4jB,gBAAR,CAAyBvgB,MAAzB,CAAT;AACD;;AACD,YAAIA,MAAM,CAACE,gBAAP,KAA4B,KAAK,CAAjC,IAAsChN,uBAAuB,CAAC8M,MAAM,CAACE,gBAAR,CAAjE,EAA4F;AAC1F,iBAAO,IAAI1M,SAAJ,CAAcwM,MAAM,CAACE,gBAArB,CAAP;AACD,SAFD,MAEO;AACL,iBAAO,SAAP;AACD;AACF;AACF;AACF;;AACD,SAAO,IAAP;AACD,C,CAED;;;AACA,SAASsgB,iCAAT,CAA2CpC,MAA3C,EAAmDqC,GAAnD,EAAwD;AACtD,QAAMC,OAAO,GAAGtC,MAAM,CAACD,oBAAP,CAA4BsC,GAA5B,CAAhB;;AACA,MAAIC,OAAO,KAAK,IAAhB,EAAsB;AACpB,UAAM,IAAIrmB,KAAJ,CAAW,qCAAoComB,GAAG,CAACzV,SAAU,EAA7D,CAAN;AACD;;AACD,MAAI0V,OAAO,CAACvO,SAAR,KAAsB,IAA1B,EAAgC;AAC9B,WAAOuO,OAAP;AACD;;AACD,QAAM1D,kBAAkB,GAAG,IAAIzU,GAAJ,EAA3B;AACA,QAAM8U,qBAAqB,GAAG,IAAI9U,GAAJ,EAA9B;AACA,QAAM4U,qBAAqB,GAAG,IAAI5U,GAAJ,EAA9B;AACA,QAAM6U,wBAAwB,GAAG,IAAI7U,GAAJ,EAAjC;AACA,MAAIoY,SAAS,GAAG,KAAhB;AACA,MAAIlE,MAAM,GAAGnC,oBAAoB,CAACI,KAArB,EAAb;AACA,MAAI2E,OAAO,GAAG/E,oBAAoB,CAACI,KAArB,EAAd;AACA,MAAI0E,YAAY,GAAG,KAAnB;;AACA,QAAMwB,WAAW,GAAIluB,IAAD,IAAU;AAC5B,QAAIA,IAAI,CAACyf,SAAL,KAAmB,SAAvB,EAAkC;AAChCwO,MAAAA,SAAS,GAAG,IAAZ;AACD,KAFD,MAEO,IAAIjuB,IAAI,CAACyf,SAAL,KAAmB,IAAvB,EAA6B;AAClC,YAAM0O,QAAQ,GAAGzC,MAAM,CAACD,oBAAP,CAA4BzrB,IAAI,CAACyf,SAAjC,CAAjB;;AACA,UAAI0O,QAAQ,KAAK,IAAjB,EAAuB;AACrBD,QAAAA,WAAW,CAACC,QAAD,CAAX;AACD,OAFD,MAEO;AACLF,QAAAA,SAAS,GAAG,IAAZ;AACD;AACF;;AACDvB,IAAAA,YAAY,GAAGA,YAAY,IAAI1sB,IAAI,CAAC0sB,YAApC;AACA3C,IAAAA,MAAM,GAAGnC,oBAAoB,CAACY,KAArB,CAA2BuB,MAA3B,EAAmC/pB,IAAI,CAAC+pB,MAAxC,CAAT;AACA4C,IAAAA,OAAO,GAAG/E,oBAAoB,CAACY,KAArB,CAA2BmE,OAA3B,EAAoC3sB,IAAI,CAAC2sB,OAAzC,CAAV;;AACA,SAAK,MAAMyB,iBAAX,IAAgCpuB,IAAI,CAACsqB,kBAArC,EAAyD;AACvDA,MAAAA,kBAAkB,CAACpJ,GAAnB,CAAuBkN,iBAAvB;AACD;;AACD,SAAK,MAAMC,oBAAX,IAAmCruB,IAAI,CAAC2qB,qBAAxC,EAA+D;AAC7DA,MAAAA,qBAAqB,CAACzJ,GAAtB,CAA0BmN,oBAA1B;AACD;;AACD,SAAK,MAAMC,oBAAX,IAAmCtuB,IAAI,CAACyqB,qBAAxC,EAA+D;AAC7DA,MAAAA,qBAAqB,CAACvJ,GAAtB,CAA0BoN,oBAA1B;AACD;;AACD,SAAK,MAAM1D,KAAX,IAAoB5qB,IAAI,CAAC0qB,wBAAzB,EAAmD;AACjDA,MAAAA,wBAAwB,CAACxJ,GAAzB,CAA6B0J,KAA7B;AACD;AACF,GA1BD;;AA2BAsD,EAAAA,WAAW,CAACF,OAAD,CAAX;AACA,SAAOlsB,aAAa,CAACC,cAAc,CAAC,EAAD,EAAKisB,OAAL,CAAf,EAA8B;AAChDjE,IAAAA,MADgD;AAEhD4C,IAAAA,OAFgD;AAGhDrC,IAAAA,kBAHgD;AAIhDK,IAAAA,qBAJgD;AAKhDF,IAAAA,qBALgD;AAMhDC,IAAAA,wBANgD;AAOhDjL,IAAAA,SAAS,EAAEwO,SAAS,GAAG,SAAH,GAAe,IAPa;AAQhDvB,IAAAA;AARgD,GAA9B,CAApB;AAUD,C,CAED;;;AACA,IAAI6B,qBAAqB,GAAG,MAAM;AAChCtsB,EAAAA,WAAW,GAAG;AACZ,SAAKusB,UAAL,GAAkB,IAAIxpB,GAAJ,EAAlB;AACA,SAAKypB,SAAL,GAAiB,IAAIzpB,GAAJ,EAAjB;AACA,SAAK0pB,KAAL,GAAa,IAAI1pB,GAAJ,EAAb;AACD;;AACDymB,EAAAA,oBAAoB,CAAChpB,GAAD,EAAM;AACxB,WAAO,KAAK+rB,UAAL,CAAgB5pB,GAAhB,CAAoBnC,GAAG,CAACP,IAAxB,IAAgC,KAAKssB,UAAL,CAAgB3pB,GAAhB,CAAoBpC,GAAG,CAACP,IAAxB,CAAhC,GAAgE,IAAvE;AACD;;AACDypB,EAAAA,mBAAmB,CAAClpB,GAAD,EAAM;AACvB,WAAO,KAAKgsB,SAAL,CAAe7pB,GAAf,CAAmBnC,GAAG,CAACP,IAAvB,IAA+B,KAAKusB,SAAL,CAAe5pB,GAAf,CAAmBpC,GAAG,CAACP,IAAvB,CAA/B,GAA8D,IAArE;AACD;;AACD0pB,EAAAA,eAAe,CAACnpB,GAAD,EAAM;AACnB,WAAO,KAAKisB,KAAL,CAAW9pB,GAAX,CAAenC,GAAG,CAACP,IAAnB,IAA2B,KAAKwsB,KAAL,CAAW7pB,GAAX,CAAepC,GAAG,CAACP,IAAnB,CAA3B,GAAsD,IAA7D;AACD;;AACDysB,EAAAA,yBAAyB,CAAC3uB,IAAD,EAAO;AAC9B,SAAKwuB,UAAL,CAAgBrpB,GAAhB,CAAoBnF,IAAI,CAACyC,GAAL,CAASP,IAA7B,EAAmClC,IAAnC;AACD;;AACD4uB,EAAAA,wBAAwB,CAAC5uB,IAAD,EAAO;AAC7B,SAAKyuB,SAAL,CAAetpB,GAAf,CAAmBnF,IAAI,CAACyC,GAAL,CAASP,IAA5B,EAAkClC,IAAlC;AACD;;AACD6uB,EAAAA,oBAAoB,CAAC7uB,IAAD,EAAO;AACzB,SAAK0uB,KAAL,CAAWvpB,GAAX,CAAenF,IAAI,CAACyC,GAAL,CAASP,IAAxB,EAA8BlC,IAA9B;AACD;;AAvB+B,CAAlC;AAyBA,IAAI8uB,wBAAwB,GAAG,MAAM;AACnC7sB,EAAAA,WAAW,CAAC8sB,UAAD,EAAa;AACtB,SAAKA,UAAL,GAAkBA,UAAlB;AACD;;AACDJ,EAAAA,yBAAyB,CAAC3uB,IAAD,EAAO;AAC9B,SAAK,MAAMgvB,QAAX,IAAuB,KAAKD,UAA5B,EAAwC;AACtCC,MAAAA,QAAQ,CAACL,yBAAT,CAAmC3uB,IAAnC;AACD;AACF;;AACD4uB,EAAAA,wBAAwB,CAAC5uB,IAAD,EAAO;AAC7B,SAAK,MAAMgvB,QAAX,IAAuB,KAAKD,UAA5B,EAAwC;AACtCC,MAAAA,QAAQ,CAACJ,wBAAT,CAAkC5uB,IAAlC;AACD;AACF;;AACD6uB,EAAAA,oBAAoB,CAAC7uB,IAAD,EAAO;AACzB,SAAK,MAAMgvB,QAAX,IAAuB,KAAKD,UAA5B,EAAwC;AACtCC,MAAAA,QAAQ,CAACH,oBAAT,CAA8B7uB,IAA9B;AACD;AACF;;AAlBkC,CAArC;AAoBA,IAAIivB,uBAAuB,GAAG,MAAM;AAClChtB,EAAAA,WAAW,CAAC+H,IAAD,EAAO;AAChB,SAAKA,IAAL,GAAYA,IAAZ;AACA,SAAKklB,OAAL,GAAe,IAAIrZ,GAAJ,EAAf;AACD;;AACDsZ,EAAAA,kBAAkB,CAACC,WAAD,EAAc;AAC9B,SAAKF,OAAL,CAAahO,GAAb,CAAiBkO,WAAjB;AACD;;AACDC,EAAAA,YAAY,CAACD,WAAD,EAAc;AACxB,WAAO,KAAKF,OAAL,CAAatqB,GAAb,CAAiBwqB,WAAjB,KAAiCrD,mBAAmB,CAACqD,WAAD,EAAc,KAAKplB,IAAnB,CAA3D;AACD;;AAViC,CAApC,C,CAaA;;AACA,IAAIslB,gBAAgB,GAAG,MAAM;AAC3BrtB,EAAAA,WAAW,GAAG;AACZ,SAAKstB,+BAAL,GAAuC,IAAIvqB,GAAJ,EAAvC;AACA,SAAKwqB,sBAAL,GAA8B,IAAIxqB,GAAJ,EAA9B;AACA,SAAKyqB,oBAAL,GAA4B,IAAIzqB,GAAJ,EAA5B;AACA,SAAK0qB,4BAAL,GAAoC,IAAI1qB,GAAJ,EAApC;AACD;;AACD2qB,EAAAA,yBAAyB,CAACC,QAAD,EAAW;AAClC,QAAI,CAAC,KAAKL,+BAAL,CAAqC3qB,GAArC,CAAyCgrB,QAAzC,CAAL,EAAyD;AACvD,aAAO,IAAI/Z,GAAJ,EAAP;AACD;;AACD,WAAO,KAAK0Z,+BAAL,CAAqC1qB,GAArC,CAAyC+qB,QAAzC,CAAP;AACD;;AACDC,EAAAA,iBAAiB,CAACC,SAAD,EAAYC,SAAZ,EAAuB;AACtC,QAAID,SAAS,CAACF,QAAV,KAAuB,IAA3B,EAAiC;AAC/B,WAAKI,gBAAL,CAAsBF,SAAS,CAACF,QAAhC,EAA0CG,SAA1C;AACD;;AACD,SAAK,MAAME,KAAX,IAAoBH,SAAS,CAACI,MAA9B,EAAsC;AACpC,WAAKC,aAAL,CAAmBF,KAAnB,EAA0BF,SAA1B;AACD;AACF;;AACDC,EAAAA,gBAAgB,CAACI,gBAAD,EAAmBL,SAAnB,EAA8B;AAC5C,UAAM;AAAEzc,MAAAA;AAAF,QAAW8c,gBAAjB;;AACA,QAAI9c,IAAI,KAAK,IAAb,EAAmB;AACjB,UAAI,CAAC,KAAKic,+BAAL,CAAqC3qB,GAArC,CAAyC0O,IAAzC,CAAL,EAAqD;AACnD,aAAKic,+BAAL,CAAqCpqB,GAArC,CAAyCmO,IAAzC,EAA+C,IAAIuC,GAAJ,EAA/C;AACD;;AACD,WAAK0Z,+BAAL,CAAqC1qB,GAArC,CAAyCyO,IAAzC,EAA+C4N,GAA/C,CAAmD6O,SAAnD;AACD;;AACD,SAAKP,sBAAL,CAA4BrqB,GAA5B,CAAgC4qB,SAAhC,EAA2CK,gBAA3C;AACD;;AACDC,EAAAA,WAAW,CAACN,SAAD,EAAY;AACrB,QAAI,CAAC,KAAKP,sBAAL,CAA4B5qB,GAA5B,CAAgCmrB,SAAhC,CAAL,EAAiD;AAC/C,aAAO,IAAP;AACD;;AACD,WAAO,KAAKP,sBAAL,CAA4B3qB,GAA5B,CAAgCkrB,SAAhC,CAAP;AACD;;AACDI,EAAAA,aAAa,CAACG,aAAD,EAAgBP,SAAhB,EAA2B;AACtC,UAAM;AAAEzc,MAAAA;AAAF,QAAWgd,aAAjB;;AACA,QAAI,CAAC,KAAKb,oBAAL,CAA0B7qB,GAA1B,CAA8BmrB,SAA9B,CAAL,EAA+C;AAC7C,WAAKN,oBAAL,CAA0BtqB,GAA1B,CAA8B4qB,SAA9B,EAAyC,IAAIla,GAAJ,EAAzC;AACD;;AACD,QAAIvC,IAAI,KAAK,IAAb,EAAmB;AACjB,UAAI,CAAC,KAAKoc,4BAAL,CAAkC9qB,GAAlC,CAAsC0O,IAAtC,CAAL,EAAkD;AAChD,aAAKoc,4BAAL,CAAkCvqB,GAAlC,CAAsCmO,IAAtC,EAA4C,IAAIuC,GAAJ,EAA5C;AACD;;AACD,WAAK6Z,4BAAL,CAAkC7qB,GAAlC,CAAsCyO,IAAtC,EAA4C4N,GAA5C,CAAgD6O,SAAhD;AACD;;AACD,SAAKN,oBAAL,CAA0B5qB,GAA1B,CAA8BkrB,SAA9B,EAAyC7O,GAAzC,CAA6CoP,aAA7C;AACD;;AACDC,EAAAA,SAAS,CAACR,SAAD,EAAY;AACnB,QAAI,CAAC,KAAKN,oBAAL,CAA0B7qB,GAA1B,CAA8BmrB,SAA9B,CAAL,EAA+C;AAC7C,aAAO,IAAIla,GAAJ,EAAP;AACD;;AACD,WAAO,KAAK4Z,oBAAL,CAA0B5qB,GAA1B,CAA8BkrB,SAA9B,CAAP;AACD;;AACDS,EAAAA,sBAAsB,CAACC,QAAD,EAAW;AAC/B,QAAI,CAAC,KAAKf,4BAAL,CAAkC9qB,GAAlC,CAAsC6rB,QAAtC,CAAL,EAAsD;AACpD,aAAO,IAAI5a,GAAJ,EAAP;AACD;;AACD,WAAO,KAAK6Z,4BAAL,CAAkC7qB,GAAlC,CAAsC4rB,QAAtC,CAAP;AACD;;AA7D0B,CAA7B,C,CAgEA;;AACA,IAAIC,eAAJ;;AACA,CAAC,UAASC,gBAAT,EAA2B;AAC1BA,EAAAA,gBAAgB,CAACA,gBAAgB,CAAC,MAAD,CAAhB,GAA2B,CAA5B,CAAhB,GAAiD,MAAjD;AACAA,EAAAA,gBAAgB,CAACA,gBAAgB,CAAC,SAAD,CAAhB,GAA8B,CAA/B,CAAhB,GAAoD,SAApD;AACD,CAHD,EAGGD,eAAe,KAAKA,eAAe,GAAG,EAAvB,CAHlB;;AAIA,IAAIE,iBAAJ;;AACA,CAAC,UAASC,kBAAT,EAA6B;AAC5BA,EAAAA,kBAAkB,CAACA,kBAAkB,CAAC,SAAD,CAAlB,GAAgC,CAAjC,CAAlB,GAAwD,SAAxD;AACAA,EAAAA,kBAAkB,CAACA,kBAAkB,CAAC,QAAD,CAAlB,GAA+B,CAAhC,CAAlB,GAAuD,QAAvD;AACAA,EAAAA,kBAAkB,CAACA,kBAAkB,CAAC,MAAD,CAAlB,GAA6B,CAA9B,CAAlB,GAAqD,MAArD;AACD,CAJD,EAIGD,iBAAiB,KAAKA,iBAAiB,GAAG,EAAzB,CAJpB;;AAKA,IAAIE,YAAJ;;AACA,CAAC,UAASC,aAAT,EAAwB;AACvBA,EAAAA,aAAa,CAACA,aAAa,CAAC,MAAD,CAAb,GAAwB,CAAzB,CAAb,GAA2C,MAA3C;AACAA,EAAAA,aAAa,CAACA,aAAa,CAAC,kBAAD,CAAb,GAAoC,CAArC,CAAb,GAAuD,kBAAvD;AACD,CAHD,EAGGD,YAAY,KAAKA,YAAY,GAAG,EAApB,CAHf,E,CAKA;;;AACA,OAAOE,GAAP,MAAgB,YAAhB;;AACA,SAASC,qBAAT,CAA+BC,gBAA/B,EAAiD;AAC/C,SAAQ9mB,OAAD,IAAa;AAClB,WAAQkN,IAAD,IAAU;AACf,UAAI0Z,GAAG,CAACG,QAAJ,CAAa7Z,IAAb,KAAsB,CAAC4Z,gBAAgB,CAACtsB,GAAjB,CAAqB0S,IAAI,CAAClC,QAA1B,CAA3B,EAAgE;AAC9D,eAAOkC,IAAP;AACD;;AACD,YAAMmH,UAAU,GAAG,CAAC,GAAGnH,IAAI,CAACmH,UAAT,CAAnB;AACAyS,MAAAA,gBAAgB,CAACrsB,GAAjB,CAAqByS,IAAI,CAAClC,QAA1B,EAAoCnQ,OAApC,CAA4C,CAAC,CAACsX,UAAD,EAAa0B,UAAb,CAAD,EAA2BmT,SAA3B,KAAyC;AACnF,cAAM1S,IAAI,GAAGsS,GAAG,CAACK,uBAAJ,CAA4B,KAAK,CAAjC,EAAoC,KAAK,CAAzC,EAA4CL,GAAG,CAACM,kBAAJ,CAAuB,CAACtwB,qBAAqB,CAACid,UAAD,EAAamT,SAAb,CAAtB,CAAvB,CAA5C,EAAoHJ,GAAG,CAACO,mBAAJ,CAAwBhV,UAAxB,CAApH,CAAb;AACAkC,QAAAA,UAAU,CAAC1Y,IAAX,CAAgB2Y,IAAhB;AACD,OAHD;AAIA,aAAOsS,GAAG,CAACQ,oBAAJ,CAAyBla,IAAzB,EAA+BmH,UAA/B,CAAP;AACD,KAVD;AAWD,GAZD;AAaD,C,CAED;;;AACA,OAAOgT,IAAP,MAAiB,YAAjB,C,CAEA;;AACA,IAAIC,UAAJ;;AACA,CAAC,UAASC,WAAT,EAAsB;AACrBA,EAAAA,WAAW,CAACA,WAAW,CAAC,SAAD,CAAX,GAAyB,CAA1B,CAAX,GAA0C,SAA1C;AACAA,EAAAA,WAAW,CAACA,WAAW,CAAC,UAAD,CAAX,GAA0B,CAA3B,CAAX,GAA2C,UAA3C;AACAA,EAAAA,WAAW,CAACA,WAAW,CAAC,UAAD,CAAX,GAA0B,CAA3B,CAAX,GAA2C,UAA3C;AACAA,EAAAA,WAAW,CAACA,WAAW,CAAC,SAAD,CAAX,GAAyB,CAA1B,CAAX,GAA0C,SAA1C;AACD,CALD,EAKGD,UAAU,KAAKA,UAAU,GAAG,EAAlB,CALb;;AAMA,IAAIE,KAAK,GAAG;AACVC,EAAAA,OAAO,EAAE,CAACC,OAAD,EAAUC,QAAV,KAAuBC,SAAS,CAACH,OAAV,CAAkBC,OAAlB,EAA2BC,QAA3B;AADtB,CAAZ;AAGA,IAAIC,SAAS,GAAG,MAAM;AACpB/vB,EAAAA,WAAW,CAAC6vB,OAAD,EAAUC,QAAV,EAAoB;AAC7B,SAAKE,KAAL,GAAaP,UAAU,CAACQ,OAAxB;AACA,SAAKC,QAAL,GAAgB,IAAhB;AACA,SAAK7kB,MAAL,GAAc,IAAd;AACA,SAAK8kB,UAAL,GAAkB,IAAlB;AACA,SAAKC,mBAAL,GAA2B,IAA3B;AACA,SAAKC,kBAAL,GAA0B,IAA1B;AACA,SAAKR,OAAL,GAAeA,OAAf;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACD;;AACDQ,EAAAA,UAAU,CAACJ,QAAD,EAAWK,WAAX,EAAwBllB,MAAxB,EAAgC;AACxC,SAAKmlB,qBAAL,CAA2Bf,UAAU,CAACQ,OAAtC,EAA+CR,UAAU,CAACgB,QAA1D;AACA,SAAKP,QAAL,GAAgBA,QAAhB;AACA,SAAKE,mBAAL,GAA2BG,WAA3B;AACA,SAAKllB,MAAL,GAAcA,MAAd;AACA,SAAK2kB,KAAL,GAAaP,UAAU,CAACgB,QAAxB;AACA,WAAO,IAAP;AACD;;AACDC,EAAAA,UAAU,CAACP,UAAD,EAAaI,WAAb,EAA0B;AAClC,SAAKC,qBAAL,CAA2Bf,UAAU,CAACgB,QAAtC,EAAgDhB,UAAU,CAACkB,QAA3D;;AACA,QAAI,KAAKT,QAAL,KAAkB,IAAtB,EAA4B;AAC1B,YAAM,IAAIxqB,KAAJ,CAAW,sEAAX,CAAN;AACD;;AACD,SAAKyqB,UAAL,GAAkBA,UAAlB;AACA,SAAKH,KAAL,GAAaP,UAAU,CAACkB,QAAxB;AACA,SAAKN,kBAAL,GAA0BE,WAA1B;AACA,WAAO,IAAP;AACD;;AACDK,EAAAA,SAAS,GAAG;AACV,SAAKJ,qBAAL,CAA2Bf,UAAU,CAACQ,OAAtC,EAA+CR,UAAU,CAACoB,OAA1D;AACA,SAAKb,KAAL,GAAaP,UAAU,CAACoB,OAAxB;AACA,WAAO,IAAP;AACD;;AACDL,EAAAA,qBAAqB,CAACM,YAAD,EAAeC,YAAf,EAA6B;AAChD,QAAI,EAAE,KAAKf,KAAL,KAAec,YAAjB,CAAJ,EAAoC;AAClC,YAAM,IAAIprB,KAAJ,CAAW,6CAA4C+pB,UAAU,CAAC,KAAKO,KAAN,CAAa,OAAMP,UAAU,CAACsB,YAAD,CAAe,GAA7G,CAAN;AACD;AACF;;AACa,SAAPnB,OAAO,CAACC,OAAD,EAAUC,QAAV,EAAoB;AAChC,WAAO,IAAIC,SAAJ,CAAcF,OAAd,EAAuBC,QAAvB,CAAP;AACD;;AAzCmB,CAAtB,C,CA4CA;;AACA,IAAIkB,aAAa,GAAG,MAAM;AACxBhxB,EAAAA,WAAW,CAACixB,QAAD,EAAWvY,SAAX,EAAsBwY,IAAtB,EAA4BC,gBAA5B,EAA8CC,yBAA9C,EAAyEC,eAAzE,EAA0FC,aAA1F,EAAyGC,uBAAzG,EAAkI;AAC3I,SAAKN,QAAL,GAAgBA,QAAhB;AACA,SAAKvY,SAAL,GAAiBA,SAAjB;AACA,SAAKwY,IAAL,GAAYA,IAAZ;AACA,SAAKC,gBAAL,GAAwBA,gBAAxB;AACA,SAAKC,yBAAL,GAAiCA,yBAAjC;AACA,SAAKC,eAAL,GAAuBA,eAAvB;AACA,SAAKC,aAAL,GAAqBA,aAArB;AACA,SAAKC,uBAAL,GAA+BA,uBAA/B;AACA,SAAKtE,OAAL,GAAe,IAAIlqB,GAAJ,EAAf;AACA,SAAKyuB,aAAL,GAAqB,IAAIzuB,GAAJ,EAArB;AACA,SAAK0uB,kBAAL,GAA0B,IAAI7d,GAAJ,EAA1B;AACA,SAAK8d,WAAL,GAAmB,IAAI3uB,GAAJ,EAAnB;AACA,SAAK4uB,cAAL,GAAsB,IAAI5uB,GAAJ,EAAtB;;AACA,SAAK,MAAM8sB,OAAX,IAAsBoB,QAAtB,EAAgC;AAC9B,WAAKU,cAAL,CAAoBzuB,GAApB,CAAwB2sB,OAAO,CAACntB,IAAhC,EAAsCmtB,OAAtC;AACD;AACF;;AACD+B,EAAAA,WAAW,CAACtS,EAAD,EAAK;AACd,SAAKuS,OAAL,CAAavS,EAAb,EAAiB,KAAjB;AACD;;AACDwS,EAAAA,YAAY,CAACxS,EAAD,EAAK;AACf,WAAO,KAAKuS,OAAL,CAAavS,EAAb,EAAiB,IAAjB,CAAP;AACD;;AACDuS,EAAAA,OAAO,CAACvS,EAAD,EAAKyS,UAAL,EAAiB;AACtB,QAAIzS,EAAE,CAACP,iBAAP,EAA0B;AACxB,aAAO,KAAK,CAAZ;AACD;;AACD,UAAMiT,QAAQ,GAAG,EAAjB;AACA,UAAMC,SAAS,GAAG,KAAKd,gBAAL,CAAsBe,gBAAtB,CAAuC5S,EAAvC,CAAlB;;AACA,QAAI2S,SAAS,KAAK,IAAlB,EAAwB;AACtB,WAAKf,IAAL,CAAUiB,UAAV,CAAqBxyB,SAAS,CAACyyB,uBAA/B;;AACA,UAAIH,SAAS,CAACvuB,MAAV,GAAmB,CAAvB,EAA0B;AACxB,aAAK,MAAM2uB,WAAX,IAA0BJ,SAA1B,EAAqC;AACnC,eAAKK,KAAL,CAAWD,WAAX;AACD;;AACD,aAAKnB,IAAL,CAAUiB,UAAV,CAAqBxyB,SAAS,CAAC4yB,kBAA/B,EAAmDN,SAAS,CAACvuB,MAA7D;AACD,OALD,MAKO;AACL,aAAK+tB,kBAAL,CAAwBxS,GAAxB,CAA4BK,EAA5B;AACD;;AACD;AACD;;AACD,UAAMkT,MAAM,GAAIvyB,IAAD,IAAU;AACvB,UAAI,KAAKyY,SAAL,CAAenO,OAAf,CAAuBtK,IAAvB,CAAJ,EAAkC;AAChC,aAAKwyB,YAAL,CAAkBxyB,IAAlB,EAAwB8xB,UAAU,GAAGC,QAAH,GAAc,IAAhD;AACD;;AACDxC,MAAAA,IAAI,CAACkD,YAAL,CAAkBzyB,IAAlB,EAAwBuyB,MAAxB;AACD,KALD;;AAMAA,IAAAA,MAAM,CAAClT,EAAD,CAAN;;AACA,QAAIyS,UAAU,IAAIC,QAAQ,CAACtuB,MAAT,GAAkB,CAApC,EAAuC;AACrC,aAAOivB,OAAO,CAACC,GAAR,CAAYZ,QAAZ,EAAsBa,IAAtB,CAA2B,MAAM,KAAK,CAAtC,CAAP;AACD,KAFD,MAEO;AACL,aAAO,KAAK,CAAZ;AACD;AACF;;AACDC,EAAAA,SAAS,CAACra,KAAD,EAAQ;AACf,QAAI,KAAKwU,OAAL,CAAatqB,GAAb,CAAiB8V,KAAjB,CAAJ,EAA6B;AAC3B,aAAO,KAAKwU,OAAL,CAAarqB,GAAb,CAAiB6V,KAAjB,CAAP;AACD,KAFD,MAEO;AACL,aAAO,IAAP;AACD;AACF;;AACDsa,EAAAA,UAAU,CAACzT,EAAD,EAAK;AACb,QAAI,CAAC,KAAKkS,aAAL,CAAmB7uB,GAAnB,CAAuB2c,EAAvB,CAAL,EAAiC;AAC/B,aAAO,IAAP;AACD;;AACD,UAAM0T,OAAO,GAAG,EAAhB;;AACA,SAAK,MAAMva,KAAX,IAAoB,KAAK+Y,aAAL,CAAmB5uB,GAAnB,CAAuB0c,EAAvB,CAApB,EAAgD;AAC9C0T,MAAAA,OAAO,CAAClvB,IAAR,CAAa,KAAKmpB,OAAL,CAAarqB,GAAb,CAAiB6V,KAAjB,CAAb;AACD;;AACD,WAAOua,OAAP;AACD;;AACDC,EAAAA,kBAAkB,GAAG;AACnB,UAAMrvB,MAAM,GAAG,IAAIb,GAAJ,EAAf;;AACA,SAAK,MAAM,CAACuc,EAAD,EAAK2N,OAAL,CAAX,IAA4B,KAAKuE,aAAjC,EAAgD;AAC9C,YAAMwB,OAAO,GAAG,EAAhB;;AACA,WAAK,MAAMva,KAAX,IAAoBwU,OAApB,EAA6B;AAC3B+F,QAAAA,OAAO,CAAClvB,IAAR,CAAa,KAAKmpB,OAAL,CAAarqB,GAAb,CAAiB6V,KAAjB,CAAb;AACD;;AACD7U,MAAAA,MAAM,CAACV,GAAP,CAAWoc,EAAX,EAAe0T,OAAf;AACD;;AACD,SAAK,MAAM1T,EAAX,IAAiB,KAAKmS,kBAAtB,EAA0C;AACxC7tB,MAAAA,MAAM,CAACV,GAAP,CAAWoc,EAAX,EAAe,EAAf;AACD;;AACD,WAAO1b,MAAP;AACD;;AACD0uB,EAAAA,KAAK,CAACD,WAAD,EAAc;AACjB,UAAMa,MAAM,GAAG;AACbC,MAAAA,iBAAiB,EAAEd,WAAW,CAACc,iBADlB;AAEbC,MAAAA,eAAe,EAAEf,WAAW,CAACe,eAFhB;AAGbC,MAAAA,eAAe,EAAEhB,WAAW,CAACgB,eAHhB;AAIbpzB,MAAAA,IAAI,EAAEoyB,WAAW,CAACpyB,IAJL;AAKbqzB,MAAAA,MAAM,EAAE;AALK,KAAf;;AAOA,SAAK,MAAMC,UAAX,IAAyBlB,WAAW,CAACiB,MAArC,EAA6C;AAC3C,YAAMzD,OAAO,GAAG,KAAK8B,cAAL,CAAoB/uB,GAApB,CAAwB2wB,UAAU,CAAC1D,OAAX,CAAmBntB,IAA3C,CAAhB;AACA,UAAI8wB,KAAK,GAAG7D,KAAK,CAACC,OAAN,CAAcC,OAAd,EAAuB0D,UAAU,CAACzD,QAAlC,CAAZ;;AACA,UAAIyD,UAAU,CAACvD,KAAX,KAAqBP,UAAU,CAACgB,QAAhC,IAA4C8C,UAAU,CAACvD,KAAX,KAAqBP,UAAU,CAACkB,QAAhF,EAA0F;AACxF,cAAMtlB,MAAM,GAAG,KAAKooB,kBAAL,CAAwB5D,OAAxB,EAAiCqD,MAAM,CAACjzB,IAAxC,EAA8CszB,UAAU,CAACrD,QAAzD,CAAf;AACAsD,QAAAA,KAAK,GAAGA,KAAK,CAAClD,UAAN,CAAiBiD,UAAU,CAACrD,QAA5B,EAAsCqD,UAAU,CAACnD,mBAAjD,EAAsE/kB,MAAtE,CAAR;;AACA,YAAImoB,KAAK,CAACtD,QAAN,KAAmB,IAAnB,IAA2BsD,KAAK,CAAC3D,OAAN,CAAc6D,QAAd,KAA2B,KAAK,CAA/D,EAAkE;AAChEF,UAAAA,KAAK,CAAC3D,OAAN,CAAc6D,QAAd,CAAuBR,MAAM,CAACjzB,IAA9B,EAAoCuzB,KAAK,CAACtD,QAA1C;AACD;AACF,OAND,MAMO,IAAIqD,UAAU,CAACvD,KAAX,KAAqBP,UAAU,CAACoB,OAApC,EAA6C;AAClD2C,QAAAA,KAAK,GAAGA,KAAK,CAAC5C,SAAN,EAAR;AACD;;AACDsC,MAAAA,MAAM,CAACI,MAAP,CAAcxvB,IAAd,CAAmB0vB,KAAnB;AACD;;AACD,SAAKvG,OAAL,CAAa/pB,GAAb,CAAiBgwB,MAAM,CAACjzB,IAAxB,EAA8BizB,MAA9B;AACA,UAAM5T,EAAE,GAAG4T,MAAM,CAACjzB,IAAP,CAAYhB,aAAZ,EAAX;;AACA,QAAI,CAAC,KAAKuyB,aAAL,CAAmB7uB,GAAnB,CAAuB2c,EAAvB,CAAL,EAAiC;AAC/B,WAAKkS,aAAL,CAAmBtuB,GAAnB,CAAuBoc,EAAvB,EAA2B,IAAI1L,GAAJ,EAA3B;AACD;;AACD,SAAK4d,aAAL,CAAmB5uB,GAAnB,CAAuB0c,EAAvB,EAA2BL,GAA3B,CAA+BiU,MAAM,CAACjzB,IAAtC;AACD;;AACD0zB,EAAAA,kBAAkB,CAAClb,KAAD,EAAQ;AACxB,QAAI,CAAC,KAAK2Y,yBAAN,IAAmC,CAAC,KAAK1Y,SAAL,CAAekb,oBAAf,CAAoCnb,KAApC,CAAxC,EAAoF;AAClF,aAAO,IAAP;AACD;;AACD,UAAMe,UAAU,GAAG,KAAKd,SAAL,CAAemb,0BAAf,CAA0Cpb,KAA1C,CAAnB;AACA,WAAO,KAAKqb,YAAL,CAAkBrb,KAAlB,EAAyBe,UAAzB,CAAP;AACD;;AACDsa,EAAAA,YAAY,CAACrb,KAAD,EAAQe,UAAR,EAAoB;AAC9B,QAAI0Z,MAAM,GAAG,KAAKJ,SAAL,CAAera,KAAf,CAAb;AACA,QAAIsb,WAAW,GAAG,EAAlB;;AACA,SAAK,MAAMlE,OAAX,IAAsB,KAAKoB,QAA3B,EAAqC;AACnC,YAAMrtB,MAAM,GAAGisB,OAAO,CAACmE,MAAR,CAAevb,KAAf,EAAsBe,UAAtB,CAAf;;AACA,UAAI5V,MAAM,KAAK,KAAK,CAApB,EAAuB;AACrB;AACD;;AACD,YAAMqwB,gBAAgB,GAAGpE,OAAO,CAACqE,UAAR,KAAuBvF,iBAAiB,CAACwF,OAAlE;AACA,YAAMC,aAAa,GAAGvE,OAAO,CAACqE,UAAR,KAAuBvF,iBAAiB,CAAC0F,IAA/D;AACA,YAAMb,KAAK,GAAG7D,KAAK,CAACC,OAAN,CAAcC,OAAd,EAAuBjsB,MAAvB,CAAd;AACAmwB,MAAAA,WAAW,CAACjwB,IAAZ,CAAiB0vB,KAAjB;;AACA,UAAIN,MAAM,KAAK,IAAf,EAAqB;AACnBA,QAAAA,MAAM,GAAG;AACPjzB,UAAAA,IAAI,EAAEwY,KADC;AAEP6a,UAAAA,MAAM,EAAE,CAACE,KAAD,CAFD;AAGPH,UAAAA,eAAe,EAAE,IAHV;AAIPF,UAAAA,iBAAiB,EAAEc,gBAJZ;AAKPb,UAAAA,eAAe,EAAEgB;AALV,SAAT;AAOA,aAAKnH,OAAL,CAAa/pB,GAAb,CAAiBuV,KAAjB,EAAwBya,MAAxB;AACA,cAAM5T,EAAE,GAAG7G,KAAK,CAACxZ,aAAN,EAAX;;AACA,YAAI,CAAC,KAAKuyB,aAAL,CAAmB7uB,GAAnB,CAAuB2c,EAAvB,CAAL,EAAiC;AAC/B,eAAKkS,aAAL,CAAmBtuB,GAAnB,CAAuBoc,EAAvB,EAA2B,IAAI1L,GAAJ,EAA3B;AACD;;AACD,aAAK4d,aAAL,CAAmB5uB,GAAnB,CAAuB0c,EAAvB,EAA2BL,GAA3B,CAA+BxG,KAA/B;AACD,OAdD,MAcO;AACL,YAAI,CAAC2b,aAAD,IAAkBlB,MAAM,CAACE,eAA7B,EAA8C;AAC5CF,UAAAA,MAAM,CAACI,MAAP,GAAgBJ,MAAM,CAACI,MAAP,CAAc7Z,MAAd,CAAsBkP,KAAD,IAAWA,KAAK,CAACkH,OAAN,CAAcqE,UAAd,KAA6BvF,iBAAiB,CAAC0F,IAA/E,CAAhB;AACAnB,UAAAA,MAAM,CAACE,eAAP,GAAyB,KAAzB;AACD,SAHD,MAGO,IAAIgB,aAAa,IAAI,CAAClB,MAAM,CAACE,eAA7B,EAA8C;AACnD;AACD;;AACD,YAAIa,gBAAgB,IAAIf,MAAM,CAACC,iBAA/B,EAAkD;AAChDD,UAAAA,MAAM,CAACG,eAAP,GAAyB,CAAC;AACxBle,YAAAA,QAAQ,EAAEqa,IAAI,CAACpa,kBAAL,CAAwB1P,KADV;AAExBvF,YAAAA,IAAI,EAAEsO,MAAM,CAAC,QAAQgF,SAAS,CAAC6gB,mBAAnB,CAFY;AAGxBjf,YAAAA,IAAI,EAAEpW,aAAa,CAACwZ,KAAD,CAHK;AAIxBnD,YAAAA,KAAK,EAAEmD,KAAK,CAAClD,QAAN,CAAe,KAAK,CAApB,EAAuB,KAAvB,CAJiB;AAKxB7R,YAAAA,MAAM,EAAE+U,KAAK,CAACjD,QAAN,EALgB;AAMxBP,YAAAA,WAAW,EAAE;AANW,WAAD,CAAzB;AAQAie,UAAAA,MAAM,CAACI,MAAP,GAAgBS,WAAW,GAAG,EAA9B;AACA;AACD;;AACDb,QAAAA,MAAM,CAACI,MAAP,CAAcxvB,IAAd,CAAmB0vB,KAAnB;AACAN,QAAAA,MAAM,CAACC,iBAAP,GAA2BD,MAAM,CAACC,iBAAP,IAA4Bc,gBAAvD;AACD;AACF;;AACD,WAAOF,WAAW,CAACrwB,MAAZ,GAAqB,CAArB,GAAyBqwB,WAAzB,GAAuC,IAA9C;AACD;;AACDN,EAAAA,kBAAkB,CAAC5D,OAAD,EAAU5sB,IAAV,EAAgBitB,QAAhB,EAA0B;AAC1C,QAAIA,QAAQ,KAAK,IAAjB,EAAuB;AACrB,aAAO,IAAP;AACD;;AACD,UAAM7kB,MAAM,GAAGwkB,OAAO,CAACxkB,MAAR,CAAepI,IAAf,EAAqBitB,QAArB,CAAf;;AACA,QAAI7kB,MAAM,KAAK,IAAX,IAAmB,KAAKkmB,uBAAL,KAAiC,IAAxD,EAA8D;AAC5D,YAAMgD,SAAS,GAAG1E,OAAO,CAACqE,UAAR,KAAuBvF,iBAAiB,CAACwF,OAA3D;;AACA,UAAI,CAACI,SAAL,EAAgB;AACd,cAAM,IAAI7uB,KAAJ,CAAW,mBAAkBmqB,OAAO,CAACntB,IAAK,kDAA1C,CAAN;AACD;;AACD,WAAK6uB,uBAAL,CAA6B3O,cAA7B,CAA4CvX,MAA5C;AACD;;AACD,WAAOA,MAAP;AACD;;AACDonB,EAAAA,YAAY,CAACha,KAAD,EAAQ+b,eAAR,EAAyB;AACnC,UAAMlB,MAAM,GAAG,KAAKK,kBAAL,CAAwBlb,KAAxB,CAAf;;AACA,QAAI6a,MAAM,KAAK,IAAf,EAAqB;AACnB;AACD;;AACD,SAAK,MAAME,KAAX,IAAoBF,MAApB,EAA4B;AAC1B,YAAMzB,OAAO,GAAG,MAAM,KAAK4C,YAAL,CAAkBhc,KAAlB,EAAyB+a,KAAzB,CAAtB;;AACA,UAAIkB,WAAW,GAAG,IAAlB;;AACA,UAAIF,eAAe,KAAK,IAApB,IAA4BhB,KAAK,CAAC3D,OAAN,CAAckC,UAAd,KAA6B,KAAK,CAAlE,EAAqE;AACnE,YAAI;AACF2C,UAAAA,WAAW,GAAGlB,KAAK,CAAC3D,OAAN,CAAckC,UAAd,CAAyBtZ,KAAzB,EAAgC+a,KAAK,CAAC1D,QAAN,CAAe6E,QAA/C,KAA4D,IAA1E;AACD,SAFD,CAEE,OAAO/e,GAAP,EAAY;AACZ,cAAIA,GAAG,YAAYjB,oBAAnB,EAAyC;AACvC6e,YAAAA,KAAK,CAAClD,UAAN,CAAiB,IAAjB,EAAuB,CAAC1a,GAAG,CAACb,YAAJ,EAAD,CAAvB,EAA6C,IAA7C;AACA;AACD,WAHD,MAGO;AACL,kBAAMa,GAAN;AACD;AACF;AACF;;AACD,UAAI8e,WAAW,KAAK,IAApB,EAA0B;AACxBF,QAAAA,eAAe,CAAC1wB,IAAhB,CAAqB4wB,WAAW,CAAC7B,IAAZ,CAAiBhB,OAAjB,CAArB;AACD,OAFD,MAEO;AACLA,QAAAA,OAAO;AACR;AACF;AACF;;AACD4C,EAAAA,YAAY,CAAChc,KAAD,EAAQ+a,KAAR,EAAe/H,KAAf,EAAsB;AAChC,QAAIzV,EAAJ,EAAQC,EAAR,EAAY2e,EAAZ;;AACA,QAAIpB,KAAK,CAACxD,KAAN,KAAgBP,UAAU,CAACQ,OAA/B,EAAwC;AACtC,YAAM,IAAIvqB,KAAJ,CAAW,+BAA8B+S,KAAK,CAAC/V,IAAN,CAAWgG,IAAK,aAAY+mB,UAAU,CAAC+D,KAAK,CAACxD,KAAP,CAAc,sBAA7F,CAAN;AACD;;AACD,SAAKkB,IAAL,CAAUiB,UAAV,CAAqBxyB,SAAS,CAACk1B,YAA/B;AACA,QAAIjxB,MAAJ;;AACA,QAAI;AACFA,MAAAA,MAAM,GAAG4vB,KAAK,CAAC3D,OAAN,CAAcgC,OAAd,CAAsBpZ,KAAtB,EAA6B+a,KAAK,CAAC1D,QAAN,CAAe6E,QAA5C,EAAsDlJ,KAAtD,CAAT;AACD,KAFD,CAEE,OAAO7V,GAAP,EAAY;AACZ,UAAIA,GAAG,YAAYjB,oBAAnB,EAAyC;AACvC6e,QAAAA,KAAK,CAAClD,UAAN,CAAiB,IAAjB,EAAuB,CAAC1a,GAAG,CAACb,YAAJ,EAAD,CAAvB,EAA6C,IAA7C;AACA;AACD,OAHD,MAGO;AACL,cAAMa,GAAN;AACD;AACF;;AACD,UAAMvK,MAAM,GAAG,KAAKooB,kBAAL,CAAwBD,KAAK,CAAC3D,OAA9B,EAAuCpX,KAAvC,EAA8C,CAACzC,EAAE,GAAGpS,MAAM,CAACssB,QAAb,KAA0B,IAA1B,GAAiCla,EAAjC,GAAsC,IAApF,CAAf;;AACA,QAAIpS,MAAM,CAACssB,QAAP,KAAoB,KAAK,CAAzB,IAA8BsD,KAAK,CAAC3D,OAAN,CAAc6D,QAAd,KAA2B,KAAK,CAAlE,EAAqE;AACnEF,MAAAA,KAAK,CAAC3D,OAAN,CAAc6D,QAAd,CAAuBjb,KAAvB,EAA8B7U,MAAM,CAACssB,QAArC;AACD;;AACDsD,IAAAA,KAAK,GAAGA,KAAK,CAAClD,UAAN,CAAiB,CAACra,EAAE,GAAGrS,MAAM,CAACssB,QAAb,KAA0B,IAA1B,GAAiCja,EAAjC,GAAsC,IAAvD,EAA6D,CAAC2e,EAAE,GAAGhxB,MAAM,CAAC2sB,WAAb,KAA6B,IAA7B,GAAoCqE,EAApC,GAAyC,IAAtG,EAA4GvpB,MAA5G,CAAR;AACD;;AACDypB,EAAAA,OAAO,GAAG;AACR,QAAI9e,EAAJ,EAAQC,EAAR;;AACA,UAAMgX,OAAO,GAAGlpB,KAAK,CAACa,IAAN,CAAW,KAAKqoB,OAAL,CAAa7G,IAAb,EAAX,CAAhB;;AACA,SAAK,MAAM3N,KAAX,IAAoBwU,OAApB,EAA6B;AAC3B,YAAMiG,MAAM,GAAG,KAAKjG,OAAL,CAAarqB,GAAb,CAAiB6V,KAAjB,CAAf;;AACA,WAAK,IAAI+a,KAAT,IAAkBN,MAAM,CAACI,MAAzB,EAAiC;AAC/B,cAAMzD,OAAO,GAAG2D,KAAK,CAAC3D,OAAtB;;AACA,gBAAQ2D,KAAK,CAACxD,KAAd;AACE,eAAKP,UAAU,CAACoB,OAAhB;AACE;;AACF,eAAKpB,UAAU,CAACQ,OAAhB;AACE,kBAAM,IAAIvqB,KAAJ,CAAW,gDAA+C+S,KAAK,CAAC/V,IAAN,CAAWgG,IAAK,MAAKyd,MAAM,CAAC4O,cAAP,CAAsBvB,KAAK,CAAC3D,OAA5B,EAAqC7vB,WAArC,CAAiD0C,IAAK,EAArI,CAAN;;AACF,eAAK+sB,UAAU,CAACkB,QAAhB;AACE,kBAAM,IAAIjrB,KAAJ,CAAW,qCAAX,CAAN;AANJ;;AAQA,YAAI8tB,KAAK,CAACtD,QAAN,KAAmB,IAAvB,EAA6B;AAC3B;AACD;;AACD,YAAIL,OAAO,CAACiF,OAAR,KAAoB,KAAK,CAA7B,EAAgC;AAC9BtB,UAAAA,KAAK,GAAGA,KAAK,CAAC9C,UAAN,CAAiB,IAAjB,EAAuB,IAAvB,CAAR;AACA;AACD;;AACD,YAAI9sB,MAAJ;;AACA,YAAI;AACFA,UAAAA,MAAM,GAAGisB,OAAO,CAACiF,OAAR,CAAgBrc,KAAhB,EAAuB+a,KAAK,CAACtD,QAA7B,EAAuCsD,KAAK,CAACnoB,MAA7C,CAAT;AACD,SAFD,CAEE,OAAOuK,GAAP,EAAY;AACZ,cAAIA,GAAG,YAAYjB,oBAAnB,EAAyC;AACvC6e,YAAAA,KAAK,GAAGA,KAAK,CAAC9C,UAAN,CAAiB,IAAjB,EAAuB,CAAC9a,GAAG,CAACb,YAAJ,EAAD,CAAvB,CAAR;AACA;AACD,WAHD,MAGO;AACL,kBAAMa,GAAN;AACD;AACF;;AACD4d,QAAAA,KAAK,GAAGA,KAAK,CAAC9C,UAAN,CAAiB,CAAC1a,EAAE,GAAGpS,MAAM,CAACqa,IAAb,KAAsB,IAAtB,GAA6BjI,EAA7B,GAAkC,IAAnD,EAAyD,CAACC,EAAE,GAAGrS,MAAM,CAAC2sB,WAAb,KAA6B,IAA7B,GAAoCta,EAApC,GAAyC,IAAlG,CAAR;;AACA,YAAIrS,MAAM,CAACoxB,SAAP,KAAqB,KAAK,CAA9B,EAAiC;AAC/B,gBAAM7hB,QAAQ,GAAGsF,KAAK,CAACxZ,aAAN,GAAsBkU,QAAvC;;AACA,cAAI,CAAC,KAAKue,WAAL,CAAiB/uB,GAAjB,CAAqBwQ,QAArB,CAAL,EAAqC;AACnC,iBAAKue,WAAL,CAAiBxuB,GAAjB,CAAqBiQ,QAArB,EAA+B,IAAIpQ,GAAJ,EAA/B;AACD;;AACD,gBAAMkyB,aAAa,GAAG,KAAKvD,WAAL,CAAiB9uB,GAAjB,CAAqBuQ,QAArB,CAAtB;;AACA,eAAK,MAAM+hB,QAAX,IAAuBtxB,MAAM,CAACoxB,SAA9B,EAAyC;AACvCC,YAAAA,aAAa,CAAC/xB,GAAd,CAAkBgyB,QAAQ,CAACC,OAA3B,EAAoC,CAACD,QAAQ,CAACE,UAAV,EAAsBF,QAAQ,CAAClZ,UAA/B,CAApC;AACD;AACF;AACF;AACF;AACF;;AACDqZ,EAAAA,SAAS,CAAC/V,EAAD,EAAKgW,GAAL,EAAU;AACjB,QAAI,CAAC,KAAK9D,aAAL,CAAmB7uB,GAAnB,CAAuB2c,EAAvB,CAAL,EAAiC;AAC/B;AACD;;AACD,SAAK,MAAM7G,KAAX,IAAoB,KAAK+Y,aAAL,CAAmB5uB,GAAnB,CAAuB0c,EAAvB,CAApB,EAAgD;AAC9C,YAAM4T,MAAM,GAAG,KAAKjG,OAAL,CAAarqB,GAAb,CAAiB6V,KAAjB,CAAf;;AACA,WAAK,MAAM+a,KAAX,IAAoBN,MAAM,CAACI,MAA3B,EAAmC;AACjC,YAAIE,KAAK,CAACxD,KAAN,KAAgBP,UAAU,CAACkB,QAA/B,EAAyC;AACvC;AACD,SAFD,MAEO,IAAI6C,KAAK,CAAC3D,OAAN,CAAcwF,SAAd,KAA4B,KAAK,CAArC,EAAwC;AAC7C;AACD;;AACD,YAAI7B,KAAK,CAACrD,UAAN,KAAqB,IAAzB,EAA+B;AAC7BqD,UAAAA,KAAK,CAAC3D,OAAN,CAAcwF,SAAd,CAAwBC,GAAxB,EAA6B7c,KAA7B,EAAoC+a,KAAK,CAACtD,QAA1C,EAAoDsD,KAAK,CAACrD,UAA1D;AACD;AACF;AACF;AACF;;AACDoF,EAAAA,qBAAqB,CAACjW,EAAD,EAAKkW,uBAAL,EAA8B;AACjD,UAAMvI,OAAO,GAAG,KAAKuE,aAAL,CAAmB5uB,GAAnB,CAAuB0c,EAAvB,CAAhB;;AACA,QAAI2N,OAAO,KAAK,KAAK,CAArB,EAAwB;AACtB,aAAO,EAAP;AACD;;AACD,UAAMsD,WAAW,GAAG,EAApB;;AACA,SAAK,MAAM9X,KAAX,IAAoBwU,OAApB,EAA6B;AAC3B,UAAI,CAAC1uB,uBAAuB,CAACka,KAAD,CAA5B,EAAqC;AACnC;AACD;;AACD,YAAMya,MAAM,GAAG,KAAKjG,OAAL,CAAarqB,GAAb,CAAiB6V,KAAjB,CAAf;;AACA,WAAK,MAAM+a,KAAX,IAAoBN,MAAM,CAACI,MAA3B,EAAmC;AACjC,YAAIE,KAAK,CAAC3D,OAAN,CAAc0F,qBAAd,KAAwC,KAAK,CAAjD,EAAoD;AAClD;AACD;;AACDhF,QAAAA,WAAW,CAACzsB,IAAZ,CAAiB,GAAG0vB,KAAK,CAAC3D,OAAN,CAAc0F,qBAAd,CAAoC9c,KAApC,EAA2C+c,uBAA3C,CAApB;AACD;AACF;;AACD,WAAOjF,WAAP;AACD;;AACDhgB,EAAAA,KAAK,CAAC+kB,GAAD,EAAM;AACT,SAAK,MAAM7c,KAAX,IAAoB,KAAKwU,OAAL,CAAa7G,IAAb,EAApB,EAAyC;AACvC,YAAM8M,MAAM,GAAG,KAAKjG,OAAL,CAAarqB,GAAb,CAAiB6V,KAAjB,CAAf;;AACA,WAAK,MAAM+a,KAAX,IAAoBN,MAAM,CAACI,MAA3B,EAAmC;AACjC,YAAIE,KAAK,CAACxD,KAAN,KAAgBP,UAAU,CAACkB,QAA/B,EAAyC;AACvC;AACD,SAFD,MAEO,IAAI6C,KAAK,CAAC3D,OAAN,CAActf,KAAd,KAAwB,KAAK,CAAjC,EAAoC;AACzC;AACD;;AACD,YAAIijB,KAAK,CAACrD,UAAN,KAAqB,IAAzB,EAA+B;AAC7BqD,UAAAA,KAAK,CAAC3D,OAAN,CAActf,KAAd,CAAoB+kB,GAApB,EAAyB7c,KAAzB,EAAgC+a,KAAK,CAACtD,QAAtC,EAAgDsD,KAAK,CAACrD,UAAtD;AACD;AACF;AACF;AACF;;AACDsF,EAAAA,KAAK,CAACC,MAAD,EAAS;AACZ,SAAK,MAAMjd,KAAX,IAAoB,KAAKwU,OAAL,CAAa7G,IAAb,EAApB,EAAyC;AACvC,YAAM8M,MAAM,GAAG,KAAKjG,OAAL,CAAarqB,GAAb,CAAiB6V,KAAjB,CAAf;;AACA,WAAK,MAAM+a,KAAX,IAAoBN,MAAM,CAACI,MAA3B,EAAmC;AACjC,YAAIE,KAAK,CAACxD,KAAN,KAAgBP,UAAU,CAACgB,QAA3B,IAAuC+C,KAAK,CAACxD,KAAN,KAAgBP,UAAU,CAACkB,QAAtE,EAAgF;AAC9E;AACD,SAFD,MAEO,IAAI6C,KAAK,CAAC3D,OAAN,CAAc4F,KAAd,KAAwB,KAAK,CAAjC,EAAoC;AACzC;AACD;;AACD,YAAIjC,KAAK,CAACtD,QAAN,KAAmB,IAAvB,EAA6B;AAC3BsD,UAAAA,KAAK,CAAC3D,OAAN,CAAc4F,KAAd,CAAoBC,MAApB,EAA4Bjd,KAA5B,EAAmC+a,KAAK,CAACtD,QAAzC;AACD;AACF;AACF;AACF;;AACDyF,EAAAA,eAAe,CAACld,KAAD,EAAQ;AACrB,QAAI,CAAC,KAAKC,SAAL,CAAenO,OAAf,CAAuBkO,KAAvB,CAAD,IAAkC,CAAC,KAAKwU,OAAL,CAAatqB,GAAb,CAAiB8V,KAAjB,CAAvC,EAAgE;AAC9D;AACD;;AACD,UAAMya,MAAM,GAAG,KAAKjG,OAAL,CAAarqB,GAAb,CAAiB6V,KAAjB,CAAf;;AACA,SAAK,MAAM+a,KAAX,IAAoBN,MAAM,CAACI,MAA3B,EAAmC;AACjC,UAAIE,KAAK,CAACxD,KAAN,KAAgBP,UAAU,CAACkB,QAA3B,IAAuC6C,KAAK,CAAC3D,OAAN,CAAc8F,eAAd,KAAkC,KAAK,CAAlF,EAAqF;AACnF;AACD;;AACDnC,MAAAA,KAAK,CAAC3D,OAAN,CAAc8F,eAAd,CAA8Bld,KAA9B,EAAqC+a,KAAK,CAACtD,QAA3C,EAAqDsD,KAAK,CAACrD,UAA3D;AACD;AACF;;AACDyF,EAAAA,OAAO,CAACnd,KAAD,EAAQod,YAAR,EAAsB;AAC3B,UAAMC,QAAQ,GAAGtG,IAAI,CAACta,eAAL,CAAqBuD,KAArB,CAAjB;;AACA,QAAI,CAAC,KAAKC,SAAL,CAAenO,OAAf,CAAuBkO,KAAvB,CAAD,IAAkC,CAAC,KAAKC,SAAL,CAAenO,OAAf,CAAuBurB,QAAvB,CAAnC,IAAuE,CAAC,KAAK7I,OAAL,CAAatqB,GAAb,CAAiBmzB,QAAjB,CAA5E,EAAwG;AACtG,aAAO,IAAP;AACD;;AACD,UAAM5C,MAAM,GAAG,KAAKjG,OAAL,CAAarqB,GAAb,CAAiBkzB,QAAjB,CAAf;AACA,QAAIjmB,GAAG,GAAG,EAAV;;AACA,SAAK,MAAM2jB,KAAX,IAAoBN,MAAM,CAACI,MAA3B,EAAmC;AACjC,UAAIE,KAAK,CAACxD,KAAN,KAAgBP,UAAU,CAACkB,QAA3B,IAAuC6C,KAAK,CAACpD,mBAAN,KAA8B,IAArE,IAA6EoD,KAAK,CAACnD,kBAAN,KAA6B,IAA9G,EAAoH;AAClH;AACD;;AACD,UAAI0F,UAAJ;;AACA,UAAI,KAAK1E,eAAL,KAAyB5C,eAAe,CAACuH,OAAzC,IAAoDxC,KAAK,CAAC3D,OAAN,CAAcoG,cAAd,KAAiC,KAAK,CAA9F,EAAiG;AAC/FF,QAAAA,UAAU,GAAGvC,KAAK,CAAC3D,OAAN,CAAcoG,cAAd,CAA6Bxd,KAA7B,EAAoC+a,KAAK,CAACtD,QAA1C,EAAoDsD,KAAK,CAACrD,UAA1D,CAAb;AACD,OAFD,MAEO;AACL4F,QAAAA,UAAU,GAAGvC,KAAK,CAAC3D,OAAN,CAAcqG,WAAd,CAA0Bzd,KAA1B,EAAiC+a,KAAK,CAACtD,QAAvC,EAAiDsD,KAAK,CAACrD,UAAvD,EAAmE0F,YAAnE,CAAb;AACD;;AACD,YAAMM,eAAe,GAAGJ,UAAxB;;AACA,UAAIhyB,KAAK,CAACC,OAAN,CAAcmyB,eAAd,CAAJ,EAAoC;AAClC,aAAK,MAAMvyB,MAAX,IAAqBuyB,eAArB,EAAsC;AACpC,cAAI,CAACtmB,GAAG,CAACgD,IAAJ,CAAUujB,CAAD,IAAOA,CAAC,CAAC1zB,IAAF,KAAWkB,MAAM,CAAClB,IAAlC,CAAL,EAA8C;AAC5CmN,YAAAA,GAAG,CAAC/L,IAAJ,CAASF,MAAT;AACD;AACF;AACF,OAND,MAMO,IAAI,CAACiM,GAAG,CAACgD,IAAJ,CAAUjP,MAAD,IAAYA,MAAM,CAAClB,IAAP,KAAgByzB,eAAe,CAACzzB,IAArD,CAAL,EAAiE;AACtEmN,QAAAA,GAAG,CAAC/L,IAAJ,CAASqyB,eAAT;AACD;AACF;;AACD,SAAK7E,aAAL,CAAmB+E,0BAAnB,CAA8CP,QAAQ,CAAC72B,aAAT,EAA9C,EAAwEq3B,SAAxE,CAAkFR,QAAlF,EAA4FjmB,GAA5F;AACA,WAAOA,GAAG,CAACnM,MAAJ,GAAa,CAAb,GAAiBmM,GAAjB,GAAuB,IAA9B;AACD;;AACD0mB,EAAAA,aAAa,CAACt2B,IAAD,EAAO;AAClB,UAAM61B,QAAQ,GAAGtG,IAAI,CAACta,eAAL,CAAqBjV,IAArB,CAAjB;;AACA,QAAI,CAAC,KAAKyY,SAAL,CAAenO,OAAf,CAAuBurB,QAAvB,CAAD,IAAqC,CAAC,KAAK7I,OAAL,CAAatqB,GAAb,CAAiBmzB,QAAjB,CAA1C,EAAsE;AACpE,aAAO,EAAP;AACD;;AACD,UAAM5C,MAAM,GAAG,KAAKjG,OAAL,CAAarqB,GAAb,CAAiBkzB,QAAjB,CAAf;AACA,UAAMtc,UAAU,GAAG,EAAnB;;AACA,SAAK,MAAMga,KAAX,IAAoBN,MAAM,CAACI,MAA3B,EAAmC;AACjC,UAAIE,KAAK,CAACxD,KAAN,KAAgBP,UAAU,CAACkB,QAA/B,EAAyC;AACvC;AACD;;AACD,UAAI6C,KAAK,CAAC1D,QAAN,CAAe0G,OAAf,KAA2B,IAA3B,IAAmChH,IAAI,CAACiH,WAAL,CAAiBjD,KAAK,CAAC1D,QAAN,CAAe0G,OAAhC,CAAvC,EAAiF;AAC/Ehd,QAAAA,UAAU,CAAC1V,IAAX,CAAgB0vB,KAAK,CAAC1D,QAAN,CAAe0G,OAA/B;AACD;AACF;;AACD,WAAOhd,UAAP;AACD;;AACc,MAAX+W,WAAW,GAAG;AAChB,UAAMA,WAAW,GAAG,EAApB;;AACA,SAAK,MAAM9X,KAAX,IAAoB,KAAKwU,OAAL,CAAa7G,IAAb,EAApB,EAAyC;AACvC,YAAM8M,MAAM,GAAG,KAAKjG,OAAL,CAAarqB,GAAb,CAAiB6V,KAAjB,CAAf;;AACA,UAAIya,MAAM,CAACG,eAAP,KAA2B,IAA/B,EAAqC;AACnC9C,QAAAA,WAAW,CAACzsB,IAAZ,CAAiB,GAAGovB,MAAM,CAACG,eAA3B;AACD;;AACD,WAAK,MAAMG,KAAX,IAAoBN,MAAM,CAACI,MAA3B,EAAmC;AACjC,YAAI,CAACE,KAAK,CAACxD,KAAN,KAAgBP,UAAU,CAACgB,QAA3B,IAAuC+C,KAAK,CAACxD,KAAN,KAAgBP,UAAU,CAACkB,QAAnE,KAAgF6C,KAAK,CAACpD,mBAAN,KAA8B,IAAlH,EAAwH;AACtHG,UAAAA,WAAW,CAACzsB,IAAZ,CAAiB,GAAG0vB,KAAK,CAACpD,mBAA1B;AACD;;AACD,YAAIoD,KAAK,CAACxD,KAAN,KAAgBP,UAAU,CAACkB,QAA3B,IAAuC6C,KAAK,CAACnD,kBAAN,KAA6B,IAAxE,EAA8E;AAC5EE,UAAAA,WAAW,CAACzsB,IAAZ,CAAiB,GAAG0vB,KAAK,CAACnD,kBAA1B;AACD;AACF;AACF;;AACD,WAAOE,WAAP;AACD;;AACmB,MAAhBtB,gBAAgB,GAAG;AACrB,WAAO,KAAKyC,WAAZ;AACD;;AAjbuB,CAA1B,C,CAobA;;AACA,OAAOgF,IAAP,MAAiB,YAAjB,C,CAEA;;AACA,OAAOC,IAAP,MAAiB,YAAjB;;AACA,SAASC,UAAT,CAAoBC,aAApB,EAAmCvX,EAAnC,EAAuCwX,eAAe,GAAG,EAAzD,EAA6D;AAC3D,QAAMC,YAAY,GAAGF,aAAa,CAACG,aAAd,CAA4B1X,EAAE,CAACnM,QAA/B,EAAyCrQ,GAAzC,CAA8C4H,CAAD,IAAO;AACvE,UAAMusB,SAAS,GAAGN,IAAI,CAACO,gBAAL,CAAsBxsB,CAAC,CAACusB,SAAF,CAAYvuB,IAAlC,CAAlB;AACA,UAAMuS,YAAY,GAAG0b,IAAI,CAACQ,kBAAL,CAAwB,KAAK,CAA7B,EAAgCR,IAAI,CAACS,qBAAL,CAA2BH,SAA3B,CAAhC,CAArB;AACA,UAAMh0B,IAAI,GAAG0zB,IAAI,CAACU,uBAAL,CAA6B,KAAK,CAAlC,EAAqC,KAAK,CAA1C,EAA6Cpc,YAA7C,EAA2D0b,IAAI,CAACW,aAAL,CAAmB5sB,CAAC,CAACgF,SAArB,CAA3D,CAAb;AACAinB,IAAAA,IAAI,CAACY,eAAL,CAAqB7sB,CAAC,CAACusB,SAAvB,EAAkCh0B,IAAlC;AACA,WAAOA,IAAP;AACD,GANoB,CAArB;AAOA,QAAMu0B,eAAe,GAAGlY,EAAE,CAAC9C,UAAH,CAAc/C,MAAd,CAAsBgD,IAAD,IAAUgb,iBAAiB,CAAChb,IAAD,CAAhD,CAAxB;AACA,QAAMpN,IAAI,GAAGiQ,EAAE,CAAC9C,UAAH,CAAc/C,MAAd,CAAsBgD,IAAD,IAAU,CAACgb,iBAAiB,CAAChb,IAAD,CAAjD,CAAb;;AACA,MAAIsa,YAAY,CAACrzB,MAAb,GAAsB,CAA1B,EAA6B;AAC3B,UAAMg0B,sBAAsB,GAAGf,IAAI,CAACgB,yBAAL,CAA+BrY,EAA/B,CAA/B;AACA,WAAOqX,IAAI,CAACpH,oBAAL,CAA0BjQ,EAA1B,EAA8BqX,IAAI,CAACiB,eAAL,CAAqB,CACxDF,sBADwD,EAExD,GAAGF,eAFqD,EAGxD,GAAGT,YAHqD,EAIxD,GAAGD,eAJqD,EAKxD,GAAGznB,IALqD,CAArB,CAA9B,CAAP;AAOD;;AACD,SAAOiQ,EAAP;AACD;;AACD,SAASmY,iBAAT,CAA2Bhb,IAA3B,EAAiC;AAC/B,SAAOka,IAAI,CAACkB,mBAAL,CAAyBpb,IAAzB,KAAkCka,IAAI,CAACmB,yBAAL,CAA+Brb,IAA/B,CAAlC,IAA0Eka,IAAI,CAACoB,iBAAL,CAAuBtb,IAAvB,CAAjF;AACD,C,CAED;;;AACA,IAAIub,oBAAoB,GAAG,MAAM;AAC/Bh4B,EAAAA,WAAW,GAAG;AACZ,SAAKi4B,wBAAL,GAAgC,IAAIl1B,GAAJ,EAAhC;AACD;;AACDszB,EAAAA,0BAA0B,CAAC/W,EAAD,EAAK;AAC7B,QAAI,CAAC,KAAK2Y,wBAAL,CAA8Bt1B,GAA9B,CAAkC2c,EAAlC,CAAL,EAA4C;AAC1C,WAAK2Y,wBAAL,CAA8B/0B,GAA9B,CAAkCoc,EAAlC,EAAsC,IAAI4Y,0BAAJ,EAAtC;AACD;;AACD,WAAO,KAAKD,wBAAL,CAA8Br1B,GAA9B,CAAkC0c,EAAlC,CAAP;AACD;;AACD6Y,EAAAA,gBAAgB,CAAC7Y,EAAD,EAAK;AACnB,QAAI,CAACA,EAAE,CAACP,iBAAR,EAA2B;AACzB,aAAO,IAAP;AACD;;AACD,UAAMqZ,UAAU,GAAG1B,IAAI,CAACxhB,eAAL,CAAqBoK,EAArB,CAAnB;AACA,QAAI+Y,UAAU,GAAG,IAAjB;;AACA,QAAI,KAAKJ,wBAAL,CAA8Bt1B,GAA9B,CAAkCy1B,UAAlC,CAAJ,EAAmD;AACjDC,MAAAA,UAAU,GAAG,EAAb;AACAA,MAAAA,UAAU,CAACv0B,IAAX,CAAgB,KAAKm0B,wBAAL,CAA8Br1B,GAA9B,CAAkCw1B,UAAlC,CAAhB;AACD;;AACD,WAAOC,UAAP;AACD;;AArB8B,CAAjC;;AAuBA,SAASC,2BAAT,CAAqCC,iBAArC,EAAwDC,cAAxD,EAAwEC,YAAxE,EAAsF;AACpF,SAAQtwB,OAAD,IAAa;AAClB,UAAMuwB,WAAW,GAAG,IAAIC,cAAJ,CAAmBxwB,OAAnB,EAA4BqwB,cAA5B,EAA4CC,YAA5C,CAApB;AACA,WAAQG,YAAD,IAAkB;AACvB,UAAIlC,IAAI,CAACxH,QAAL,CAAc0J,YAAd,CAAJ,EAAiC;AAC/B,eAAOA,YAAP;AACD;;AACD,YAAMP,UAAU,GAAGE,iBAAiB,CAACJ,gBAAlB,CAAmCS,YAAnC,CAAnB;;AACA,UAAIP,UAAU,KAAK,IAAnB,EAAyB;AACvB,eAAOO,YAAP;AACD;;AACD,aAAOF,WAAW,CAAC5a,SAAZ,CAAsB8a,YAAtB,EAAoCP,UAApC,CAAP;AACD,KATD;AAUD,GAZD;AAaD;;AACD,IAAIM,cAAc,GAAG,MAAM;AACzB34B,EAAAA,WAAW,CAACs1B,GAAD,EAAMkD,cAAN,EAAsBC,YAAtB,EAAoC;AAC7C,SAAKnD,GAAL,GAAWA,GAAX;AACA,SAAKkD,cAAL,GAAsBA,cAAtB;AACA,SAAKC,YAAL,GAAoBA,YAApB;AACD;;AACD3a,EAAAA,SAAS,CAACwB,EAAD,EAAK+Y,UAAL,EAAiB;AACxB,UAAM/N,OAAO,GAAG,IAAI1rB,aAAJ,CAAkB,KAAK45B,cAAvB,EAAuC,KAAKC,YAA5C,CAAhB;;AACA,UAAM92B,OAAO,GAAI1B,IAAD,IAAU;AACxB,UAAIy2B,IAAI,CAAC3R,kBAAL,CAAwB9kB,IAAxB,CAAJ,EAAmC;AACjC,eAAO,KAAK44B,yBAAL,CAA+B54B,IAA/B,EAAqCo4B,UAArC,EAAiD/N,OAAjD,CAAP;AACD,OAFD,MAEO,IAAIoM,IAAI,CAACtkB,qBAAL,CAA2BnS,IAA3B,CAAJ,EAAsC;AAC3C,eAAO,KAAK64B,4BAAL,CAAkC74B,IAAlC,EAAwCo4B,UAAxC,EAAoD/N,OAApD,CAAP;AACD,OAFM,MAEA;AACL,eAAOoM,IAAI,CAAC/Y,cAAL,CAAoB1d,IAApB,EAA0B0B,OAA1B,EAAmC,KAAK2zB,GAAxC,CAAP;AACD;AACF,KARD;;AASAhW,IAAAA,EAAE,GAAGoX,IAAI,CAACqC,SAAL,CAAezZ,EAAf,EAAmB3d,OAAnB,CAAL;AACA,WAAOi1B,UAAU,CAACtM,OAAD,EAAUhL,EAAV,CAAjB;AACD;;AACDuZ,EAAAA,yBAAyB,CAACpgB,KAAD,EAAQ4f,UAAR,EAAoB/N,OAApB,EAA6B;AACpD,QAAI3f,QAAQ,GAAG8N,KAAK,CAACzK,OAArB;AACA,QAAIgrB,eAAe,GAAG,KAAtB;;AACA,SAAK,MAAMlb,SAAX,IAAwBua,UAAxB,EAAoC;AAClC,UAAIva,SAAS,CAACmb,qBAAV,KAAoC,KAAK,CAA7C,EAAgD;AAC9C,aAAK,IAAIvuB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,QAAQ,CAACjH,MAA7B,EAAqCgH,CAAC,EAAtC,EAA0C;AACxC,gBAAMmF,GAAG,GAAGiO,SAAS,CAACmb,qBAAV,CAAgCtuB,QAAQ,CAACD,CAAD,CAAxC,EAA6C4f,OAA7C,CAAZ;;AACA,cAAIza,GAAG,KAAKlF,QAAQ,CAACD,CAAD,CAApB,EAAyB;AACvB,gBAAI,CAACsuB,eAAL,EAAsB;AACpBruB,cAAAA,QAAQ,GAAG,CAAC,GAAGA,QAAJ,CAAX;AACAquB,cAAAA,eAAe,GAAG,IAAlB;AACD;;AACDruB,YAAAA,QAAQ,CAACD,CAAD,CAAR,GAAcmF,GAAd;AACD;AACF;AACF;AACF;;AACD,QAAIqpB,QAAQ,GAAGzgB,KAAf;;AACA,SAAK,MAAMqF,SAAX,IAAwBua,UAAxB,EAAoC;AAClC,UAAIva,SAAS,CAACqb,cAAV,KAA6B,KAAK,CAAtC,EAAyC;AACvC,cAAMC,YAAY,GAAG3gB,KAAK,KAAKygB,QAAV,GAAqBvuB,QAArB,GAAgCuuB,QAAQ,CAAClrB,OAA9D;AACAkrB,QAAAA,QAAQ,GAAGpb,SAAS,CAACqb,cAAV,CAAyBD,QAAzB,EAAmCE,YAAnC,EAAiD9O,OAAjD,CAAX;AACD;AACF;;AACD,QAAI0O,eAAe,IAAIvgB,KAAK,KAAKygB,QAAjC,EAA2C;AACzCA,MAAAA,QAAQ,GAAGxC,IAAI,CAAC2C,sBAAL,CAA4B5gB,KAA5B,EAAmCA,KAAK,CAACe,UAAzC,EAAqDf,KAAK,CAAC7F,SAA3D,EAAsE6F,KAAK,CAAC/V,IAA5E,EAAkF+V,KAAK,CAACuM,cAAxF,EAAwGvM,KAAK,CAAC0S,eAA9G,EAA+HxgB,QAA/H,CAAX;AACD;;AACD,WAAOuuB,QAAP;AACD;;AACDJ,EAAAA,4BAA4B,CAAC3L,WAAD,EAAckL,UAAd,EAA0B/N,OAA1B,EAAmC;AAC7D,QAAIgP,OAAO,GAAGnM,WAAd;;AACA,SAAK,MAAMrP,SAAX,IAAwBua,UAAxB,EAAoC;AAClC,UAAIva,SAAS,CAACgb,4BAAV,KAA2C,KAAK,CAApD,EAAuD;AACrDQ,QAAAA,OAAO,GAAGxb,SAAS,CAACgb,4BAAV,CAAuCQ,OAAvC,EAAgDhP,OAAhD,CAAV;AACD;AACF;;AACD,WAAOgP,OAAP;AACD;;AAzDwB,CAA3B;AA2DA,IAAIpB,0BAA0B,GAAG,MAAM;AACrCl4B,EAAAA,WAAW,GAAG;AACZ,SAAKu5B,iBAAL,GAAyB,IAAIx2B,GAAJ,EAAzB;AACD;;AACDuzB,EAAAA,SAAS,CAACrzB,IAAD,EAAOu2B,MAAP,EAAe;AACtB,SAAKD,iBAAL,CAAuBr2B,GAAvB,CAA2BD,IAA3B,EAAiCu2B,MAAjC;AACD;;AACDL,EAAAA,cAAc,CAAC1gB,KAAD,EAAQzK,OAAR,EAAiBsc,OAAjB,EAA0B;AACtC,UAAMwL,QAAQ,GAAGY,IAAI,CAACxhB,eAAL,CAAqBuD,KAArB,CAAjB;;AACA,QAAI,CAAC,KAAK8gB,iBAAL,CAAuB52B,GAAvB,CAA2BmzB,QAA3B,CAAL,EAA2C;AACzC,aAAOrd,KAAP;AACD;;AACD,UAAM+gB,MAAM,GAAG,KAAKD,iBAAL,CAAuB32B,GAAvB,CAA2BkzB,QAA3B,CAAf;AACA,UAAM2D,UAAU,GAAGD,MAAM,CAAC12B,GAAP,CAAYG,IAAD,IAAU;AACtC,YAAM2P,SAAS,GAAG,CAAC8jB,IAAI,CAACgD,cAAL,CAAoBhD,IAAI,CAAC1wB,UAAL,CAAgB2zB,aAApC,CAAD,CAAlB;AACA,YAAMre,OAAO,GAAG/b,aAAa,CAAC0D,IAAI,CAAC4K,IAAN,EAAYyc,OAAZ,CAA7B;AACAsP,MAAAA,uBAAuB,CAACte,OAAD,CAAvB;AACA,aAAOob,IAAI,CAACmD,cAAL,CAAoB,KAAK,CAAzB,EAA4BjnB,SAA5B,EAAuC3P,IAAI,CAACP,IAA5C,EAAkD,KAAK,CAAvD,EAA0D4Y,OAA1D,EAAmE,KAAK,CAAxE,CAAP;AACD,KALkB,CAAnB;AAMA,WAAOob,IAAI,CAAC2C,sBAAL,CAA4B5gB,KAA5B,EAAmCA,KAAK,CAACe,UAAzC,EAAqDf,KAAK,CAAC7F,SAA3D,EAAsE6F,KAAK,CAAC/V,IAA5E,EAAkF+V,KAAK,CAACuM,cAAxF,EAAwGvM,KAAK,CAAC0S,eAA9G,EAA+H,CAAC,GAAGnd,OAAJ,EAAa,GAAGyrB,UAAhB,CAA/H,CAAP;AACD;;AApBoC,CAAvC;;AAsBA,SAASG,uBAAT,CAAiC35B,IAAjC,EAAuC;AACrCy2B,EAAAA,IAAI,CAACoD,YAAL,CAAkB75B,IAAlB,EAAwBy2B,IAAI,CAACqD,SAAL,CAAeC,UAAvC;AACAtD,EAAAA,IAAI,CAAChE,YAAL,CAAkBzyB,IAAlB,EAAwB25B,uBAAxB;AACD,C,CAED;;;AACA,SAASK,YAAT,QAA6B,mBAA7B;AACA,OAAOC,IAAP,MAAiB,YAAjB,C,CAEA;;AACA,OAAOC,IAAP,MAAiB,YAAjB;;AACA,SAASjyB,KAAT,CAAejI,IAAf,EAAqB0B,OAArB,EAA8BwG,OAA9B,EAAuC;AACrC,SAAOxG,OAAO,CAACy4B,MAAR,CAAen6B,IAAf,EAAqBkI,OAArB,CAAP;AACD;;AACD,IAAIkyB,OAAO,GAAG,MAAM;AAClBr6B,EAAAA,WAAW,GAAG;AACZ,SAAKs6B,OAAL,GAAe,IAAIv3B,GAAJ,EAAf;AACA,SAAKw3B,MAAL,GAAc,IAAIx3B,GAAJ,EAAd;AACD;;AACDy3B,EAAAA,mBAAmB,CAACv6B,IAAD,EAAO0B,OAAP,EAAgB;AACjC,UAAMiC,MAAM,GAAGjC,OAAO,CAAC1B,IAAD,CAAtB;;AACA,QAAI2D,MAAM,CAAC62B,MAAP,KAAkB,KAAK,CAA3B,EAA8B;AAC5B,WAAKH,OAAL,CAAap3B,GAAb,CAAiBU,MAAM,CAAC3D,IAAxB,EAA8B2D,MAAM,CAAC62B,MAArC;AACD;;AACD,QAAI72B,MAAM,CAAC82B,KAAP,KAAiB,KAAK,CAA1B,EAA6B;AAC3B,WAAKH,MAAL,CAAYr3B,GAAZ,CAAgBU,MAAM,CAAC3D,IAAvB,EAA6B2D,MAAM,CAAC82B,KAApC;AACD;;AACD,WAAO92B,MAAM,CAAC3D,IAAd;AACD;;AACD06B,EAAAA,cAAc,CAAC16B,IAAD,EAAO;AACnB,WAAOA,IAAP;AACD;;AACDm6B,EAAAA,MAAM,CAACn6B,IAAD,EAAOkI,OAAP,EAAgB;AACpB,QAAIyyB,WAAW,GAAG,IAAlB;AACA36B,IAAAA,IAAI,GAAGk6B,IAAI,CAACxc,cAAL,CAAoB1d,IAApB,EAA2B46B,KAAD,IAAW,KAAKT,MAAL,CAAYS,KAAZ,EAAmB1yB,OAAnB,CAArC,EAAkEA,OAAlE,CAAP;;AACA,QAAIgyB,IAAI,CAACpV,kBAAL,CAAwB9kB,IAAxB,CAAJ,EAAmC;AACjC26B,MAAAA,WAAW,GAAG,KAAKJ,mBAAL,CAAyBv6B,IAAzB,EAAgC66B,KAAD,IAAW,KAAKC,qBAAL,CAA2BD,KAA3B,CAA1C,CAAd;AACD,KAFD,MAEO;AACLF,MAAAA,WAAW,GAAG,KAAKD,cAAL,CAAoB16B,IAApB,CAAd;AACD;;AACD,QAAI+6B,aAAa,CAACJ,WAAD,CAAjB,EAAgC;AAC9BA,MAAAA,WAAW,GAAG,KAAKK,uBAAL,CAA6BL,WAA7B,CAAd;AACD;;AACD,WAAOA,WAAP;AACD;;AACDK,EAAAA,uBAAuB,CAACh7B,IAAD,EAAO;AAC5B,QAAIA,IAAI,CAACuc,UAAL,CAAgB0e,KAAhB,CAAuBze,IAAD,IAAU,CAAC,KAAK6d,OAAL,CAAa33B,GAAb,CAAiB8Z,IAAjB,CAAD,IAA2B,CAAC,KAAK8d,MAAL,CAAY53B,GAAZ,CAAgB8Z,IAAhB,CAA5D,CAAJ,EAAwF;AACtF,aAAOxc,IAAP;AACD;;AACD,UAAMk7B,KAAK,GAAGhB,IAAI,CAACiB,eAAL,CAAqBn7B,IAArB,CAAd;AACA,UAAMo7B,aAAa,GAAG,EAAtB;AACAF,IAAAA,KAAK,CAAC3e,UAAN,CAAiBxZ,OAAjB,CAA0ByZ,IAAD,IAAU;AACjC,UAAI,KAAK6d,OAAL,CAAa33B,GAAb,CAAiB8Z,IAAjB,CAAJ,EAA4B;AAC1B4e,QAAAA,aAAa,CAACv3B,IAAd,CAAmB,GAAG,KAAKw2B,OAAL,CAAa13B,GAAb,CAAiB6Z,IAAjB,CAAtB;;AACA,aAAK6d,OAAL,CAAagB,MAAb,CAAoB7e,IAApB;AACD;;AACD4e,MAAAA,aAAa,CAACv3B,IAAd,CAAmB2Y,IAAnB;;AACA,UAAI,KAAK8d,MAAL,CAAY53B,GAAZ,CAAgB8Z,IAAhB,CAAJ,EAA2B;AACzB4e,QAAAA,aAAa,CAACv3B,IAAd,CAAmB,GAAG,KAAKy2B,MAAL,CAAY33B,GAAZ,CAAgB6Z,IAAhB,CAAtB;;AACA,aAAK8d,MAAL,CAAYe,MAAZ,CAAmB7e,IAAnB;AACD;AACF,KAVD;AAWA0e,IAAAA,KAAK,CAAC3e,UAAN,GAAmB2d,IAAI,CAACvC,eAAL,CAAqByD,aAArB,EAAoCp7B,IAAI,CAACuc,UAAL,CAAgB+e,gBAApD,CAAnB;AACA,WAAOJ,KAAP;AACD;;AAlDiB,CAApB;;AAoDA,SAASH,aAAT,CAAuB/6B,IAAvB,EAA6B;AAC3B,QAAMu7B,KAAK,GAAGv7B,IAAd;AACA,SAAOu7B,KAAK,CAAChf,UAAN,KAAqB,KAAK,CAA1B,IAA+BzY,KAAK,CAACC,OAAN,CAAcw3B,KAAK,CAAChf,UAApB,CAAtC;AACD,C,CAED;;;AACA,IAAIif,aAAa,GAAG,IAAI7nB,GAAJ,EAApB;AACA,IAAI8nB,4BAA4B,GAAG,sBAAnC;;AACA,SAASC,mBAAT,CAA6BC,WAA7B,EAA0CljB,SAA1C,EAAqD8f,cAArD,EAAqEqD,oBAArE,EAA2F3K,IAA3F,EAAiGvY,MAAjG,EAAyGmjB,wBAAzG,EAAmI;AACjI,QAAMC,iBAAiB,GAAGC,gBAAgB,CAACH,oBAAD,CAA1C;AACA,SAAQ1zB,OAAD,IAAa;AAClB,WAAQkN,IAAD,IAAU;AACf,aAAO6b,IAAI,CAAC+K,OAAL,CAAar8B,SAAS,CAACs8B,OAAvB,EAAgC,MAAMC,sBAAsB,CAACP,WAAD,EAAczzB,OAAd,EAAuBuQ,SAAvB,EAAkC8f,cAAlC,EAAkDnjB,IAAlD,EAAwDsD,MAAxD,EAAgEmjB,wBAAhE,EAA0FC,iBAA1F,CAA5D,CAAP;AACD,KAFD;AAGD,GAJD;AAKD;;AACD,IAAIK,qBAAqB,GAAG,cAAc/B,OAAd,CAAsB;AAChDr6B,EAAAA,WAAW,CAAC47B,WAAD,EAAc/F,YAAd,EAA4B;AACrC;AACA,SAAK+F,WAAL,GAAmBA,WAAnB;AACA,SAAK/F,YAAL,GAAoBA,YAApB;AACA,SAAKwG,mBAAL,GAA2B,IAAIt5B,GAAJ,EAA3B;AACD;;AACDg4B,EAAAA,qBAAqB,CAAC96B,IAAD,EAAO;AAC1B,UAAM2D,MAAM,GAAG,KAAKg4B,WAAL,CAAiBhG,OAAjB,CAAyB31B,IAAzB,EAA+B,KAAK41B,YAApC,CAAf;;AACA,QAAIjyB,MAAM,KAAK,IAAf,EAAqB;AACnB,WAAKy4B,mBAAL,CAAyBn5B,GAAzB,CAA6BjD,IAA7B,EAAmC2D,MAAnC;AACD;;AACD,WAAO;AAAE3D,MAAAA;AAAF,KAAP;AACD;;AAb+C,CAAlD;AAeA,IAAIq8B,wBAAwB,GAAG,cAAcjC,OAAd,CAAsB;AACnDr6B,EAAAA,WAAW,CAAC47B,WAAD,EAAcS,mBAAd,EAAmC3jB,SAAnC,EAA8Cme,aAA9C,EAA6D0F,qBAA7D,EAAoFT,wBAApF,EAA8GnjB,MAA9G,EAAsH;AAC/H;AACA,SAAKijB,WAAL,GAAmBA,WAAnB;AACA,SAAKS,mBAAL,GAA2BA,mBAA3B;AACA,SAAK3jB,SAAL,GAAiBA,SAAjB;AACA,SAAKme,aAAL,GAAqBA,aAArB;AACA,SAAK0F,qBAAL,GAA6BA,qBAA7B;AACA,SAAKT,wBAAL,GAAgCA,wBAAhC;AACA,SAAKnjB,MAAL,GAAcA,MAAd;AACD;;AACDoiB,EAAAA,qBAAqB,CAAC96B,IAAD,EAAO;AAC1B,QAAI,CAAC,KAAKo8B,mBAAL,CAAyB15B,GAAzB,CAA6B1C,IAA7B,CAAL,EAAyC;AACvC,aAAO;AAAEA,QAAAA;AAAF,OAAP;AACD;;AACD,UAAMu8B,gBAAgB,GAAG;AACvBT,MAAAA,iBAAiB,EAAE,KAAKQ,qBADD;AAEvBE,MAAAA,0BAA0B,EAAE,KAAKX;AAFV,KAAzB;AAIA,UAAMtf,UAAU,GAAG,EAAnB;AACA,UAAMxO,OAAO,GAAG,CAAC,GAAG/N,IAAI,CAAC+N,OAAT,CAAhB;;AACA,SAAK,MAAM2a,KAAX,IAAoB,KAAK0T,mBAAL,CAAyBz5B,GAAzB,CAA6B3C,IAA7B,CAApB,EAAwD;AACtD,YAAMy8B,QAAQ,GAAGr9B,mBAAmB,CAACspB,KAAK,CAACxd,WAAP,EAAoB,KAAK0rB,aAAzB,EAAwC2F,gBAAxC,CAApC;AACA,YAAMxxB,QAAQ,GAAGkvB,IAAI,CAACL,cAAL,CAAoB,KAAK,CAAzB,EAA4B,CAACK,IAAI,CAACyC,WAAL,CAAiBzC,IAAI,CAACl0B,UAAL,CAAgB2zB,aAAjC,CAAD,CAA5B,EAA+EhR,KAAK,CAACjmB,IAArF,EAA2F,KAAK,CAAhG,EAAmG,KAAK,CAAxG,EAA2Gg6B,QAA3G,CAAjB;;AACA,UAAI,KAAKZ,wBAAT,EAAmC;AACjC5B,QAAAA,IAAI,CAAC0C,0BAAL,CAAgC5xB,QAAhC,EAA0CkvB,IAAI,CAACl0B,UAAL,CAAgB62B,sBAA1D,EAAkF,gBAAlF,EAAoG,KAApG;AACD;;AACDlU,MAAAA,KAAK,CAACnM,UAAN,CAAiB1Z,GAAjB,CAAsB2Z,IAAD,IAAUnd,kBAAkB,CAACmd,IAAD,EAAO,KAAKoa,aAAZ,EAA2B2F,gBAA3B,CAAjD,EAA+Fx5B,OAA/F,CAAwGyZ,IAAD,IAAUD,UAAU,CAAC1Y,IAAX,CAAgB2Y,IAAhB,CAAjH;AACAzO,MAAAA,OAAO,CAAClK,IAAR,CAAakH,QAAb;AACD;;AACD/K,IAAAA,IAAI,GAAGi6B,IAAI,CAACb,sBAAL,CAA4Bp5B,IAA5B,EAAkC68B,oBAAoB,CAAC78B,IAAI,CAACuZ,UAAN,EAAkB,KAAKoiB,WAAL,CAAiBrF,aAAjB,CAA+Bt2B,IAA/B,CAAlB,CAAtD,EAA+GA,IAAI,CAAC2S,SAApH,EAA+H3S,IAAI,CAACyC,IAApI,EAA0IzC,IAAI,CAAC+kB,cAA/I,EAA+J/kB,IAAI,CAACkrB,eAAL,IAAwB,EAAvL,EAA2Lnd,OAAO,CAAClL,GAAR,CAAamL,MAAD,IAAY,KAAK8uB,uBAAL,CAA6B9uB,MAA7B,CAAxB,CAA3L,CAAP;AACA,WAAO;AAAEhO,MAAAA,IAAF;AAAQy6B,MAAAA,KAAK,EAAEle;AAAf,KAAP;AACD;;AACDwgB,EAAAA,sBAAsB,CAAC/5B,IAAD,EAAO;AAC3B,UAAMuW,UAAU,GAAG,KAAKd,SAAL,CAAemb,0BAAf,CAA0C5wB,IAA1C,CAAnB;;AACA,QAAIuW,UAAU,KAAK,IAAnB,EAAyB;AACvB,aAAOiiB,aAAP;AACD;;AACD,UAAMwB,cAAc,GAAGzjB,UAAU,CAACC,MAAX,CAAmBC,GAAD,IAAS,KAAKf,MAAL,IAAeukB,iBAAiB,CAACxjB,GAAD,CAA3D,EAAkE5W,GAAlE,CAAuE4W,GAAD,IAASA,GAAG,CAACzZ,IAAnF,CAAvB;;AACA,QAAIg9B,cAAc,CAACv5B,MAAf,GAAwB,CAA5B,EAA+B;AAC7B,aAAO,IAAIkQ,GAAJ,CAAQqpB,cAAR,CAAP;AACD,KAFD,MAEO;AACL,aAAOxB,aAAP;AACD;AACF;;AACD0B,EAAAA,sBAAsB,CAACl9B,IAAD,EAAO;AAC3B,QAAIA,IAAI,CAACuZ,UAAL,KAAoB,KAAK,CAA7B,EAAgC;AAC9B,aAAO,KAAK,CAAZ;AACD;;AACD,UAAMyjB,cAAc,GAAG,KAAKD,sBAAL,CAA4B/8B,IAA5B,CAAvB;;AACA,QAAIg9B,cAAc,CAACvY,IAAf,KAAwBzkB,IAAI,CAACuZ,UAAL,CAAgB9V,MAA5C,EAAoD;AAClD,aAAO,KAAK,CAAZ;AACD,KAFD,MAEO,IAAIu5B,cAAc,CAACvY,IAAf,KAAwB,CAA5B,EAA+B;AACpC,aAAOzkB,IAAI,CAACuZ,UAAZ;AACD;;AACD,UAAM4jB,QAAQ,GAAGn9B,IAAI,CAACuZ,UAAL,CAAgBC,MAAhB,CAAwBC,GAAD,IAAS,CAACujB,cAAc,CAACt6B,GAAf,CAAmB+W,GAAnB,CAAjC,CAAjB;;AACA,QAAI0jB,QAAQ,CAAC15B,MAAT,KAAoB,CAAxB,EAA2B;AACzB,aAAO,KAAK,CAAZ;AACD;;AACD,UAAM+G,KAAK,GAAGyvB,IAAI,CAACtC,eAAL,CAAqBwF,QAArB,CAAd;AACA3yB,IAAAA,KAAK,CAAC0S,GAAN,GAAYld,IAAI,CAACuZ,UAAL,CAAgB2D,GAA5B;AACA1S,IAAAA,KAAK,CAAC4yB,GAAN,GAAYp9B,IAAI,CAACuZ,UAAL,CAAgB6jB,GAA5B;AACA,WAAO5yB,KAAP;AACD;;AACDsyB,EAAAA,uBAAuB,CAAC98B,IAAD,EAAO;AAC5B,QAAIi6B,IAAI,CAAChtB,WAAL,CAAiBjN,IAAjB,CAAJ,EAA4B;AAC1BA,MAAAA,IAAI,GAAGi6B,IAAI,CAACoD,eAAL,CAAqBr9B,IAArB,EAA2B,KAAKk9B,sBAAL,CAA4Bl9B,IAA5B,CAA3B,EAA8DA,IAAI,CAAC2S,SAAnE,EAA8E3S,IAAI,CAACuQ,cAAnF,EAAmGvQ,IAAI,CAACyC,IAAxG,EAA8GzC,IAAI,CAACs9B,aAAnH,EAAkIt9B,IAAI,CAAC4N,IAAvI,EAA6I5N,IAAI,CAACkL,WAAlJ,CAAP;AACD,KAFD,MAEO,IAAI+uB,IAAI,CAAC7nB,mBAAL,CAAyBpS,IAAzB,KAAkCA,IAAI,CAACuZ,UAAL,KAAoB,KAAK,CAA/D,EAAkE;AACvEvZ,MAAAA,IAAI,GAAGi6B,IAAI,CAACsD,YAAL,CAAkBv9B,IAAlB,EAAwB,KAAKk9B,sBAAL,CAA4Bl9B,IAA5B,CAAxB,EAA2DA,IAAI,CAAC2S,SAAhE,EAA2E3S,IAAI,CAACw9B,aAAhF,EAA+Fx9B,IAAI,CAACyC,IAApG,EAA0GzC,IAAI,CAACs9B,aAA/G,EAA8Ht9B,IAAI,CAAC+kB,cAAnI,EAAmJ/kB,IAAI,CAACoQ,UAAxJ,EAAoKpQ,IAAI,CAAC4N,IAAzK,EAA+K5N,IAAI,CAACoP,IAApL,CAAP;AACD,KAFM,MAEA,IAAI6qB,IAAI,CAACwD,qBAAL,CAA2Bz9B,IAA3B,KAAoCA,IAAI,CAACuZ,UAAL,KAAoB,KAAK,CAAjE,EAAoE;AACzEvZ,MAAAA,IAAI,GAAGi6B,IAAI,CAACyD,cAAL,CAAoB19B,IAApB,EAA0B,KAAKk9B,sBAAL,CAA4Bl9B,IAA5B,CAA1B,EAA6DA,IAAI,CAAC2S,SAAlE,EAA6E3S,IAAI,CAACyC,IAAlF,EAAwFzC,IAAI,CAACs9B,aAA7F,EAA4Gt9B,IAAI,CAAC4N,IAAjH,EAAuH5N,IAAI,CAACkL,WAA5H,CAAP;AACD,KAFM,MAEA,IAAI+uB,IAAI,CAAC0D,aAAL,CAAmB39B,IAAnB,CAAJ,EAA8B;AACnCA,MAAAA,IAAI,GAAGi6B,IAAI,CAAC2D,iBAAL,CAAuB59B,IAAvB,EAA6B,KAAKk9B,sBAAL,CAA4Bl9B,IAA5B,CAA7B,EAAgEA,IAAI,CAAC2S,SAArE,EAAgF3S,IAAI,CAACyC,IAArF,EAA2FzC,IAAI,CAACoQ,UAAhG,EAA4GpQ,IAAI,CAAC4N,IAAjH,EAAuH5N,IAAI,CAACoP,IAA5H,CAAP;AACD,KAFM,MAEA,IAAI6qB,IAAI,CAAC4D,aAAL,CAAmB79B,IAAnB,CAAJ,EAA8B;AACnCA,MAAAA,IAAI,GAAGi6B,IAAI,CAAC6D,iBAAL,CAAuB99B,IAAvB,EAA6B,KAAKk9B,sBAAL,CAA4Bl9B,IAA5B,CAA7B,EAAgEA,IAAI,CAAC2S,SAArE,EAAgF3S,IAAI,CAACyC,IAArF,EAA2FzC,IAAI,CAACoQ,UAAhG,EAA4GpQ,IAAI,CAACoP,IAAjH,CAAP;AACD,KAFM,MAEA,IAAI6qB,IAAI,CAAC8D,wBAAL,CAA8B/9B,IAA9B,CAAJ,EAAyC;AAC9C,YAAMoQ,UAAU,GAAGpQ,IAAI,CAACoQ,UAAL,CAAgBvN,GAAhB,CAAqBwN,KAAD,IAAW,KAAKysB,uBAAL,CAA6BzsB,KAA7B,CAA/B,CAAnB;AACArQ,MAAAA,IAAI,GAAGi6B,IAAI,CAAC+D,iBAAL,CAAuBh+B,IAAvB,EAA6BA,IAAI,CAACuZ,UAAlC,EAA8CvZ,IAAI,CAAC2S,SAAnD,EAA8DvC,UAA9D,EAA0EpQ,IAAI,CAACoP,IAA/E,CAAP;AACD;;AACD,WAAOpP,IAAP;AACD;;AAhFkD,CAArD;;AAkFA,SAASk8B,sBAAT,CAAgCP,WAAhC,EAA6CzzB,OAA7C,EAAsDuQ,SAAtD,EAAiE8f,cAAjE,EAAiFnjB,IAAjF,EAAuFsD,MAAvF,EAA+FmjB,wBAA/F,EAAyHC,iBAAzH,EAA4I;AAC1I,QAAMlG,YAAY,GAAG,IAAIoE,YAAJ,CAAiB6B,wBAAjB,CAArB;AACA,QAAMjF,aAAa,GAAG,IAAIj4B,aAAJ,CAAkB45B,cAAlB,CAAtB;AACA,QAAM0F,kBAAkB,GAAG,IAAI9B,qBAAJ,CAA0BR,WAA1B,EAAuC/F,YAAvC,CAA3B;AACA3tB,EAAAA,KAAK,CAACmN,IAAD,EAAO6oB,kBAAP,EAA2B/1B,OAA3B,CAAL;AACA,QAAMg2B,qBAAqB,GAAG,IAAI7B,wBAAJ,CAA6BV,WAA7B,EAA0CsC,kBAAkB,CAAC7B,mBAA7D,EAAkF3jB,SAAlF,EAA6Fme,aAA7F,EAA4GkF,iBAA5G,EAA+HD,wBAA/H,EAAyJnjB,MAAzJ,CAA9B;AACA,MAAI2G,EAAE,GAAGpX,KAAK,CAACmN,IAAD,EAAO8oB,qBAAP,EAA8Bh2B,OAA9B,CAAd;AACA,QAAMi2B,uBAAuB,GAAGC,wBAAwB,CAACl2B,OAAD,CAAxB,GAAoC+xB,IAAI,CAACoE,YAAL,CAAkBC,MAAtF;AACA,QAAMC,SAAS,GAAG3I,YAAY,CAACrZ,UAAb,CAAwB1Z,GAAxB,CAA6B2Z,IAAD,IAAUnd,kBAAkB,CAACmd,IAAD,EAAOoa,aAAP,EAAsB;AAC9FkF,IAAAA,iBAD8F;AAE9F0C,IAAAA,wBAAwB,EAAEL,uBAFoE;AAG9FM,IAAAA,6BAA6B,EAAEN,uBAH+D;AAI9F3B,IAAAA,0BAA0B,EAAEX;AAJkE,GAAtB,CAAxD,CAAlB;AAMA,QAAM6C,gBAAgB,GAAG7C,wBAAwB,GAAG8C,sBAAsB,CAACtf,EAAE,CAAC9C,UAAJ,CAAzB,GAA2C,IAA5F;AACA8C,EAAAA,EAAE,GAAGsX,UAAU,CAACC,aAAD,EAAgBvX,EAAhB,EAAoBkf,SAApB,CAAf;;AACA,MAAIG,gBAAgB,KAAK,IAAzB,EAA+B;AAC7BE,IAAAA,sBAAsB,CAACvf,EAAD,EAAKqf,gBAAL,CAAtB;AACD;;AACD,SAAOrf,EAAP;AACD;;AACD,SAAS+e,wBAAT,CAAkCl2B,OAAlC,EAA2C;AACzC,QAAM/D,MAAM,GAAG+D,OAAO,CAAC22B,kBAAR,GAA6B16B,MAA7B,IAAuC81B,IAAI,CAACoE,YAAL,CAAkBC,MAAxE;AACA,SAAOn6B,MAAM,KAAK81B,IAAI,CAACoE,YAAL,CAAkBS,IAA7B,GAAoC36B,MAApC,GAA6C81B,IAAI,CAACoE,YAAL,CAAkBC,MAAtE;AACD;;AACD,SAASK,sBAAT,CAAgCpiB,UAAhC,EAA4C;AAC1C,MAAIA,UAAU,CAAC9Y,MAAX,GAAoB,CAAxB,EAA2B;AACzB,UAAMqE,IAAI,GAAGyU,UAAU,CAAC,CAAD,CAAvB;AACA,QAAIwiB,QAAQ,GAAG,KAAf;AACA,QAAIC,QAAQ,GAAG/E,IAAI,CAACgF,2BAAL,CAAiCn3B,IAAjC,CAAf;;AACA,QAAI,CAACk3B,QAAD,IAAaA,QAAQ,CAACv7B,MAAT,KAAoB,CAArC,EAAwC;AACtCs7B,MAAAA,QAAQ,GAAG,IAAX;AACAC,MAAAA,QAAQ,GAAG/E,IAAI,CAACiF,4BAAL,CAAkCp3B,IAAlC,CAAX;AACD;;AACD,QAAIk3B,QAAQ,IAAIA,QAAQ,CAACv7B,MAAT,GAAkB,CAA9B,IAAmCg4B,4BAA4B,CAACplB,IAA7B,CAAkC2oB,QAAQ,CAAC,CAAD,CAAR,CAAYv2B,IAA9C,CAAvC,EAA4F;AAC1F,aAAO;AAAEu2B,QAAAA,QAAF;AAAYl3B,QAAAA,IAAZ;AAAkBi3B,QAAAA;AAAlB,OAAP;AACD;AACF;;AACD,SAAO,IAAP;AACD;;AACD,SAASH,sBAAT,CAAgCvf,EAAhC,EAAoC8f,YAApC,EAAkD;AAChD,QAAM;AAAEH,IAAAA,QAAF;AAAYl3B,IAAAA,IAAZ;AAAkBi3B,IAAAA;AAAlB,MAA+BI,YAArC;;AACA,MAAI9f,EAAE,CAAC9C,UAAH,CAAc9Y,MAAd,GAAuB,CAAvB,IAA4BqE,IAAI,KAAKuX,EAAE,CAAC9C,UAAH,CAAc,CAAd,CAAzC,EAA2D;AACzD,QAAIwiB,QAAJ,EAAc;AACZ9E,MAAAA,IAAI,CAACmF,4BAAL,CAAkCt3B,IAAlC,EAAwC,KAAK,CAA7C;AACD,KAFD,MAEO;AACLmyB,MAAAA,IAAI,CAACoF,2BAAL,CAAiCv3B,IAAjC,EAAuC,KAAK,CAA5C;AACD;;AACDmyB,IAAAA,IAAI,CAACoF,2BAAL,CAAiChgB,EAAE,CAAC9C,UAAH,CAAc,CAAd,CAAjC,EAAmDyiB,QAAnD;AACD;AACF;;AACD,SAASnC,oBAAT,CAA8BtjB,UAA9B,EAA0C+lB,QAA1C,EAAoD;AAClD,MAAI/lB,UAAU,KAAK,KAAK,CAAxB,EAA2B;AACzB,WAAO,KAAK,CAAZ;AACD;;AACD,QAAM4jB,QAAQ,GAAG5jB,UAAU,CAACC,MAAX,CAAmBC,GAAD,IAAS6lB,QAAQ,CAACxwB,IAAT,CAAeywB,WAAD,IAAiBtF,IAAI,CAAChlB,eAAL,CAAqBwE,GAArB,MAA8B8lB,WAA7D,MAA8E,KAAK,CAA9G,CAAjB;;AACA,MAAIpC,QAAQ,CAAC15B,MAAT,KAAoB,CAAxB,EAA2B;AACzB,WAAO,KAAK,CAAZ;AACD;;AACD,SAAOw2B,IAAI,CAACtC,eAAL,CAAqBwF,QAArB,CAAP;AACD;;AACD,SAASF,iBAAT,CAA2BrhB,SAA3B,EAAsC;AACpC,SAAOA,SAAS,CAAC/d,MAAV,KAAqB,IAArB,IAA6B+d,SAAS,CAAC/d,MAAV,CAAiB8G,IAAjB,KAA0B,eAA9D;AACD;;AACD,SAASo3B,gBAAT,CAA0BH,oBAA1B,EAAgD;AAC9C,SAAQ57B,IAAD,IAAU;AACf,UAAMw/B,UAAU,GAAGzgC,2BAA2B,CAACiB,IAAD,CAA9C;;AACA,QAAIw/B,UAAU,KAAK,IAAnB,EAAyB;AACvB5D,MAAAA,oBAAoB,CAAC6D,gBAArB,CAAsCD,UAAtC;AACD;AACF,GALD;AAMD,C,CAED;;;AACA,OAAOE,IAAP,MAAiB,YAAjB;;AACA,SAASC,4BAAT,CAAsC3/B,IAAtC,EAA4CW,KAA5C,EAAmDqU,WAAnD,EAAgE;AAC9D,MAAIe,EAAJ;;AACA,MAAI6pB,cAAJ;AACA,MAAIhrB,kBAAJ;;AACA,MAAIjU,KAAK,YAAYb,YAArB,EAAmC;AACjC8/B,IAAAA,cAAc,GAAG,2CAAjB;AACAhrB,IAAAA,kBAAkB,GAAG0B,iBAAiB,CAACtW,IAAD,EAAOW,KAAP,CAAtC;AACD,GAHD,MAGO,IAAIA,KAAK,YAAY/B,SAArB,EAAgC;AACrC,UAAMuF,MAAM,GAAGxD,KAAK,CAACyV,SAAN,KAAoB,IAApB,GAA4B,IAAGzV,KAAK,CAACyV,SAAU,GAA/C,GAAoD,0BAAnE;AACAwpB,IAAAA,cAAc,GAAI,2BAA0Bz7B,MAAO,GAAnD;AACA,UAAM07B,aAAa,GAAG,CAAC9pB,EAAE,GAAG9W,gBAAgB,CAAC0B,KAAK,CAACX,IAAP,CAAtB,KAAuC,IAAvC,GAA8C+V,EAA9C,GAAmDpV,KAAK,CAACX,IAA/E;AACA4U,IAAAA,kBAAkB,GAAG,CAACY,sBAAsB,CAACqqB,aAAD,EAAgB,6BAAhB,CAAvB,CAArB;AACD,GALM,MAKA;AACLD,IAAAA,cAAc,GAAI,qBAAoB/pB,oBAAoB,CAAClV,KAAD,CAAQ,IAAlE;AACD;;AACD,QAAMsa,KAAK,GAAG;AACZjG,IAAAA,WADY;AAEZE,IAAAA,QAAQ,EAAEwqB,IAAI,CAACvqB,kBAAL,CAAwB1P,KAFtB;AAGZvF,IAAAA,IAAI,EAAE,CAHM;AAIZgb,IAAAA,IAAI,EAAE,CAAC;AACLlG,MAAAA,WAAW,EAAE4qB,cADR;AAEL1qB,MAAAA,QAAQ,EAAEwqB,IAAI,CAACvqB,kBAAL,CAAwBM,OAF7B;AAGLvV,MAAAA,IAAI,EAAE;AAHD,KAAD;AAJM,GAAd;AAUA,SAAO,IAAIwU,oBAAJ,CAAyBlB,SAAS,CAACssB,oBAAnC,EAAyD9/B,IAAzD,EAA+Dib,KAA/D,EAAsErG,kBAAtE,CAAP;AACD;;AACD,SAASmrB,sBAAT,CAAgCC,eAAhC,EAAiDC,oBAAjD,EAAuEnT,QAAvE,EAAiF;AAC/E,QAAMwD,WAAW,GAAG,EAApB;;AACA,OAAK,MAAM3R,QAAX,IAAuBqhB,eAAvB,EAAwC;AACtC,QAAIlT,QAAQ,CAACK,YAAT,CAAsBxO,QAAQ,CAAC3e,IAA/B,CAAJ,EAA0C;AACxC;AACD;;AACD,UAAMke,WAAW,GAAGS,QAAQ,CAACR,uBAAT,CAAiC8hB,oBAAjC,CAApB;AACA3P,IAAAA,WAAW,CAACzsB,IAAZ,CAAiBkR,cAAc,CAACvB,SAAS,CAAC0sB,oBAAX,EAAiChiB,WAAjC,EAA+C,cAAaS,QAAQ,CAAC3e,IAAT,CAAcyC,IAAd,CAAmBgG,IAAK;AACvH;AACA,6CAA6CkW,QAAQ,CAAC3e,IAAT,CAAcyC,IAAd,CAAmBgG,IAAK;AACrE,CAHmC,EAGhC,CAAC+M,sBAAsB,CAACmJ,QAAQ,CAAC3e,IAAV,EAAiB,IAAG2e,QAAQ,CAAC3e,IAAT,CAAcyC,IAAd,CAAmBgG,IAAK,qBAA5C,CAAvB,CAHgC,CAA/B;AAID;;AACD,SAAO6nB,WAAP;AACD;;AACD,SAAS6P,uBAAT,CAAiCngC,IAAjC,EAAuCwpB,MAAvC,EAA+CpM,SAA/C,EAA0D3E,SAA1D,EAAqE2nB,aAArE,EAAoFh4B,IAApF,EAA0F;AACxF,MAAIkoB,WAAW,GAAG,EAAlB;;AACA,QAAM+P,cAAc,GAAIC,IAAD,IAAU;AAC/B,QAAIA,IAAI,KAAK,IAAb,EAAmB;AACjB;AACD,KAFD,MAEO,IAAIhQ,WAAW,KAAK,IAApB,EAA0B;AAC/BA,MAAAA,WAAW,GAAGxsB,KAAK,CAACC,OAAN,CAAcu8B,IAAd,IAAsBA,IAAtB,GAA6B,CAACA,IAAD,CAA3C;AACD,KAFM,MAEA,IAAIx8B,KAAK,CAACC,OAAN,CAAcu8B,IAAd,CAAJ,EAAyB;AAC9BhQ,MAAAA,WAAW,CAACzsB,IAAZ,CAAiB,GAAGy8B,IAApB;AACD,KAFM,MAEA;AACLhQ,MAAAA,WAAW,CAACzsB,IAAZ,CAAiBy8B,IAAjB;AACD;AACF,GAVD;;AAWA,QAAMC,qBAAqB,GAAGH,aAAa,CAACI,wBAAd,CAAuCxgC,IAAvC,CAA9B;;AACA,MAAIugC,qBAAqB,KAAK,IAA9B,EAAoC;AAClCF,IAAAA,cAAc,CAACtiB,6BAA6B,CAAC/d,IAAD,EAAOugC,qBAAP,EAA8Bn4B,IAA9B,CAA9B,CAAd;AACD;;AACDi4B,EAAAA,cAAc,CAACI,2BAA2B,CAACzgC,IAAD,EAAOwpB,MAAP,EAAe/Q,SAAf,EAA0B2E,SAA1B,CAA5B,CAAd;AACA,SAAOkT,WAAP;AACD;;AACD,SAASoQ,gDAAT,CAA0D1gC,IAA1D,EAAgE;AAC9D,SAAO+U,cAAc,CAACvB,SAAS,CAACmtB,wCAAX,EAAqD3gC,IAAI,CAACyC,IAA1D,EAAiE,iGAAjE,CAArB;AACD;;AACD,SAASg+B,2BAAT,CAAqCzgC,IAArC,EAA2CwpB,MAA3C,EAAmD/Q,SAAnD,EAA8D2E,SAA9D,EAAyE;AACvE,MAAI,CAAC3E,SAAS,CAACnO,OAAV,CAAkBtK,IAAlB,CAAD,IAA4ByY,SAAS,CAACI,wBAAV,CAAmC7Y,IAAnC,MAA6C,IAA7E,EAAmF;AACjF,WAAO,IAAP;AACD;;AACD,MAAIud,SAAS,GAAGJ,aAAa,CAACnd,IAAD,EAAOyY,SAAP,EAAkB2E,SAAlB,CAA7B;;AACA,SAAOG,SAAS,KAAK,IAArB,EAA2B;AACzB,QAAIA,SAAS,KAAK,SAAlB,EAA6B;AAC3B,aAAO,IAAP;AACD;;AACD,UAAMqjB,aAAa,GAAGpX,MAAM,CAACD,oBAAP,CAA4BhM,SAA5B,CAAtB;;AACA,QAAIqjB,aAAa,KAAK,IAAtB,EAA4B;AAC1B,aAAO,IAAP;AACD;;AACD,UAAMC,0BAA0B,GAAGpoB,SAAS,CAACI,wBAAV,CAAmC0E,SAAS,CAACvd,IAA7C,CAAnC;AACA,UAAM8gC,cAAc,GAAG3jB,aAAa,CAACI,SAAS,CAACvd,IAAX,EAAiByY,SAAjB,EAA4B2E,SAA5B,CAApC;;AACA,QAAIyjB,0BAA0B,KAAK,IAA/B,IAAuCA,0BAA0B,CAACp9B,MAA3B,GAAoC,CAA/E,EAAkF;AAChF,aAAOs9B,qCAAqC,CAAC/gC,IAAD,EAAOud,SAAP,EAAkBiM,MAAlB,CAA5C;AACD,KAFD,MAEO,IAAIqX,0BAA0B,KAAK,IAA/B,IAAuCC,cAAc,KAAK,IAA9D,EAAoE;AACzE,aAAO,IAAP;AACD;;AACDvjB,IAAAA,SAAS,GAAGujB,cAAZ;AACD;;AACD,SAAO,IAAP;AACD;;AACD,SAASC,qCAAT,CAA+C/gC,IAA/C,EAAqDud,SAArD,EAAgEiM,MAAhE,EAAwE;AACtE,QAAMwX,YAAY,GAAGxX,MAAM,CAACD,oBAAP,CAA4B,IAAI3qB,SAAJ,CAAcoB,IAAd,CAA5B,CAArB;AACA,QAAMihC,SAAS,GAAGD,YAAY,CAACzW,WAAb,GAA2B,WAA3B,GAAyC,WAA3D;AACA,QAAM2W,aAAa,GAAG3jB,SAAS,CAACnH,SAAhC;AACA,SAAOrB,cAAc,CAACvB,SAAS,CAAC2tB,mCAAX,EAAgDnhC,IAAI,CAACyC,IAArD,EAA4D,OAAMw+B,SAAS,CAACG,WAAV,EAAwB,IAAGphC,IAAI,CAACyC,IAAL,CAAUgG,IAAK,kCAAiCy4B,aAAc,sIAAqIA,aAAc,wDAAuDA,aAAc,uCAAsClhC,IAAI,CAACyC,IAAL,CAAUgG,IAAK,GAAxa,CAArB;AACD,C,CAED;;;AACA,SAASiY,oBAAT,EAA+BG,2BAA/B,EAA4DwgB,mCAA5D,EAAiGC,4BAAjG,EAA+HC,+BAA/H,EAAgKC,mCAAhK,EAAqMzpB,YAAY,IAAI0pB,aAArN,EAAoOrgB,aAApO,EAAmPsgB,2BAAnP,EAAgRngB,iBAAhR,EAAmSogB,iBAAnS,EAAsTC,kBAAtT,EAA0UvpB,eAAe,IAAIwpB,gBAA7V,QAAqX,mBAArX;AACA,OAAOC,IAAP,MAAiB,YAAjB,C,CAEA;;AACA,SAASC,6BAAT,EAAwCC,sBAAxC,QAAsE,mBAAtE;;AACA,SAASC,wBAAT,CAAkCvN,QAAlC,EAA4C;AAC1C,QAAM9kB,GAAG,GAAGoyB,sBAAsB,CAACtN,QAAD,CAAlC;AACA,SAAO;AAAEjyB,IAAAA,IAAI,EAAE,WAAR;AAAqByI,IAAAA,WAAW,EAAE0E,GAAG,CAACxF,UAAtC;AAAkDmS,IAAAA,UAAU,EAAE3M,GAAG,CAAC2M,UAAlE;AAA8E3O,IAAAA,IAAI,EAAEgC,GAAG,CAAChC;AAAxF,GAAP;AACD;;AACD,SAASs0B,qBAAT,CAA+BxN,QAA/B,EAAyC;AACvC,QAAM9kB,GAAG,GAAGmyB,6BAA6B,CAACrN,QAAD,CAAzC;AACA,SAAO;AAAEjyB,IAAAA,IAAI,EAAE,WAAR;AAAqByI,IAAAA,WAAW,EAAE0E,GAAG,CAACxF,UAAtC;AAAkDmS,IAAAA,UAAU,EAAE3M,GAAG,CAAC2M,UAAlE;AAA8E3O,IAAAA,IAAI,EAAEgC,GAAG,CAAChC;AAAxF,GAAP;AACD,C,CAED;;;AACA,SAASu0B,YAAT,EAAuBC,gBAAvB,EAAyCpqB,WAAW,IAAIqqB,YAAxD,EAAsEC,UAAtE,EAAkFprB,eAAlF,EAAmGmB,eAAe,IAAIkqB,gBAAtH,QAA8I,mBAA9I;AACA,OAAOC,IAAP,MAAiB,YAAjB;;AACA,SAASC,oBAAT,CAA8BjqB,KAA9B,EAAqCkqB,UAArC,EAAiDhqB,MAAjD,EAAyD8jB,0BAAzD,EAAqFmG,yBAAyB,GAAIlpB,GAAD,IAASA,GAA1H,EAA+H;AAC7H,MAAI,CAACipB,UAAU,CAACp4B,OAAX,CAAmBkO,KAAnB,CAAL,EAAgC;AAC9B,WAAO,IAAP;AACD;;AACD,QAAMoqB,EAAE,GAAGF,UAAU,CAACG,sBAAX,CAAkCrqB,KAAlC,CAAX;AACA,QAAMsqB,eAAe,GAAGJ,UAAU,CAAC9O,0BAAX,CAAsCpb,KAAtC,CAAxB;;AACA,MAAIsqB,eAAe,KAAK,IAAxB,EAA8B;AAC5B,WAAO,IAAP;AACD;;AACD,QAAMC,iBAAiB,GAAGD,eAAe,CAACtpB,MAAhB,CAAwBC,GAAD,IAASupB,mBAAmB,CAACvpB,GAAD,EAAMf,MAAN,CAAnD,EAAkE7V,GAAlE,CAAuE+Y,SAAD,IAAeqnB,mBAAmB,CAACN,yBAAyB,CAAC/mB,SAAD,CAA1B,EAAuC4gB,0BAAvC,CAAxG,EAA4K35B,GAA5K,CAAiL+Y,SAAD,IAAesnB,0BAA0B,CAACtnB,SAAD,EAAYgnB,EAAE,CAACn6B,IAAf,CAAzN,CAA1B;;AACA,MAAIs6B,iBAAiB,CAACt/B,MAAlB,KAA6B,CAAjC,EAAoC;AAClC,WAAO,IAAP;AACD;;AACD,QAAM0/B,cAAc,GAAG,IAAIZ,gBAAJ,CAAqBC,IAAI,CAACY,kBAAL,CAAwBL,iBAAxB,CAArB,CAAvB;AACA,MAAIM,kBAAkB,GAAG,IAAzB;AACA,QAAMC,mBAAmB,GAAGZ,UAAU,CAAC7pB,wBAAX,CAAoCL,KAApC,CAA5B;;AACA,MAAI8qB,mBAAmB,KAAK,IAA5B,EAAkC;AAChC,UAAMC,cAAc,GAAGD,mBAAmB,CAACzgC,GAApB,CAAyBwN,KAAD,IAAWmzB,uBAAuB,CAACnzB,KAAD,EAAQqI,MAAR,CAA1D,CAAvB;AACA2qB,IAAAA,kBAAkB,GAAG,IAAIlB,YAAJ,CAAiB,EAAjB,EAAqB,CACxC,IAAIjrB,eAAJ,CAAoB,IAAIkrB,gBAAJ,CAAqBmB,cAArB,CAApB,CADwC,CAArB,CAArB;AAGD;;AACD,MAAIE,kBAAkB,GAAG,IAAzB;AACA,QAAMC,YAAY,GAAGhB,UAAU,CAAC7zB,iBAAX,CAA6B2J,KAA7B,EAAoCgB,MAApC,CAA4CxL,MAAD,IAAY,CAACA,MAAM,CAACgB,QAAR,IAAoBhB,MAAM,CAACuL,UAAP,KAAsB,IAA1C,IAAkDvL,MAAM,CAACuL,UAAP,CAAkB9V,MAAlB,GAA2B,CAApI,CAArB;AACA,QAAMkgC,6BAA6B,GAAGD,YAAY,CAAC7gC,GAAb,CAAkBmL,MAAD,IAAYA,MAAM,CAACvL,IAApC,EAA0C+W,MAA1C,CAAiD,CAAC/W,IAAD,EAAOgI,CAAP,EAAUm5B,GAAV,KAAkBA,GAAG,CAAClyB,OAAJ,CAAYjP,IAAZ,IAAoBgI,CAAvF,CAAtC;;AACA,MAAIk5B,6BAA6B,CAAClgC,MAA9B,GAAuC,CAA3C,EAA8C;AAC5C,UAAM,IAAIgC,KAAJ,CAAW,kDAAiD+S,KAAK,CAAC/V,IAAN,CAAWgG,IAAK,KAAlE,GAAyEk7B,6BAA6B,CAAC93B,IAA9B,CAAmC,IAAnC,CAAnF,CAAN;AACD;;AACD,QAAMg4B,gBAAgB,GAAGH,YAAY,CAAC7gC,GAAb,CAAkBmL,MAAD,IAAY;AACpD,QAAI+H,EAAJ;;AACA,WAAO+tB,qBAAqB,CAAC,CAAC/tB,EAAE,GAAG/H,MAAM,CAACmN,QAAb,KAA0B,IAA1B,GAAiCpF,EAAjC,GAAsC/H,MAAM,CAACvL,IAA9C,EAAoDuL,MAAM,CAACuL,UAA3D,EAAuEb,MAAvE,CAA5B;AACD,GAHwB,CAAzB;;AAIA,MAAImrB,gBAAgB,CAACpgC,MAAjB,GAA0B,CAA9B,EAAiC;AAC/BggC,IAAAA,kBAAkB,GAAG,IAAIlB,gBAAJ,CAAqBC,IAAI,CAACuB,mBAAL,CAAyBF,gBAAzB,CAArB,CAArB;AACD;;AACD,SAAO;AACLj2B,IAAAA,IAAI,EAAE,IAAI20B,gBAAJ,CAAqBK,EAArB,CADD;AAELrpB,IAAAA,UAAU,EAAE4pB,cAFP;AAGLI,IAAAA,cAAc,EAAEF,kBAHX;AAILW,IAAAA,cAAc,EAAEP;AAJX,GAAP;AAMD;;AACD,SAASD,uBAAT,CAAiCnzB,KAAjC,EAAwCqI,MAAxC,EAAgD;AAC9C,QAAM9K,IAAI,GAAGyC,KAAK,CAAC6I,kBAAN,CAAyB9Q,IAAzB,KAAkC,CAAlC,GAAsC6Q,0BAA0B,CAAC5I,KAAK,CAAC6I,kBAAP,CAAhE,GAA6F,IAAImpB,YAAJ,CAAiB,KAAK,CAAtB,CAA1G;AACA,QAAM4B,UAAU,GAAG,CACjB;AAAE3/B,IAAAA,GAAG,EAAE,MAAP;AAAe3D,IAAAA,KAAK,EAAEiN,IAAtB;AAA4Bs2B,IAAAA,MAAM,EAAE;AAApC,GADiB,CAAnB;;AAGA,MAAI7zB,KAAK,CAACkJ,UAAN,KAAqB,IAAzB,EAA+B;AAC7B,UAAM4qB,YAAY,GAAG9zB,KAAK,CAACkJ,UAAN,CAAiBC,MAAjB,CAAyBC,GAAD,IAASupB,mBAAmB,CAACvpB,GAAD,EAAMf,MAAN,CAApD,EAAmE7V,GAAnE,CAAwE+Y,SAAD,IAAeqnB,mBAAmB,CAACrnB,SAAD,CAAzG,CAArB;AACA,UAAMjb,KAAK,GAAG,IAAI4hC,gBAAJ,CAAqBC,IAAI,CAACY,kBAAL,CAAwBe,YAAxB,CAArB,CAAd;AACAF,IAAAA,UAAU,CAACpgC,IAAX,CAAgB;AAAES,MAAAA,GAAG,EAAE,YAAP;AAAqB3D,MAAAA,KAArB;AAA4BujC,MAAAA,MAAM,EAAE;AAApC,KAAhB;AACD;;AACD,SAAO5B,UAAU,CAAC2B,UAAD,CAAjB;AACD;;AACD,SAASH,qBAAT,CAA+BrhC,IAA/B,EAAqC8W,UAArC,EAAiDb,MAAjD,EAAyD;AACvD,QAAMyrB,YAAY,GAAG5qB,UAAU,CAACC,MAAX,CAAmBC,GAAD,IAASupB,mBAAmB,CAACvpB,GAAD,EAAMf,MAAN,CAA9C,EAA6D7V,GAA7D,CAAkE+Y,SAAD,IAAeqnB,mBAAmB,CAACrnB,SAAD,CAAnG,CAArB;AACA,QAAMwoB,aAAa,GAAG5B,IAAI,CAACY,kBAAL,CAAwBe,YAAxB,CAAtB;AACA,SAAO3B,IAAI,CAAC6B,wBAAL,CAA8B5hC,IAA9B,EAAoC2hC,aAApC,CAAP;AACD;;AACD,SAASnB,mBAAT,CAA6BrnB,SAA7B,EAAwC0oB,qBAAxC,EAA+D;AAC7D,MAAI1oB,SAAS,CAACsG,UAAV,KAAyB,IAA7B,EAAmC;AACjC,UAAM,IAAIzc,KAAJ,CAAU,2EAAV,CAAN;AACD;;AACD,QAAMqF,UAAU,GAAG,CACjB03B,IAAI,CAAC6B,wBAAL,CAA8B,MAA9B,EAAsC7B,IAAI,CAACrH,eAAL,CAAqBvf,SAAS,CAACsG,UAA/B,CAAtC,CADiB,CAAnB;;AAGA,MAAItG,SAAS,CAACpY,IAAV,KAAmB,IAAnB,IAA2BoY,SAAS,CAACpY,IAAV,CAAeC,MAAf,GAAwB,CAAvD,EAA0D;AACxD,UAAMD,IAAI,GAAGoY,SAAS,CAACpY,IAAV,CAAeX,GAAf,CAAoBe,GAAD,IAAS;AACvC,YAAMyL,IAAI,GAAGmzB,IAAI,CAACrH,eAAL,CAAqBv3B,GAArB,CAAb;AACA,aAAO0gC,qBAAqB,GAAG1mB,+BAA+B,CAACvO,IAAD,CAAlC,GAA2CA,IAAvE;AACD,KAHY,CAAb;AAIAvE,IAAAA,UAAU,CAACjH,IAAX,CAAgB2+B,IAAI,CAAC6B,wBAAL,CAA8B,MAA9B,EAAsC7B,IAAI,CAACY,kBAAL,CAAwB5/B,IAAxB,CAAtC,CAAhB;AACD;;AACD,SAAOg/B,IAAI,CAACuB,mBAAL,CAAyBj5B,UAAzB,EAAqC,IAArC,CAAP;AACD;;AACD,SAASk4B,mBAAT,CAA6BpnB,SAA7B,EAAwClD,MAAxC,EAAgD;AAC9C,SAAOA,MAAM,IAAIkD,SAAS,CAAC/d,MAAV,KAAqB,IAArB,IAA6B+d,SAAS,CAAC/d,MAAV,CAAiB8G,IAAjB,KAA0B,eAAxE;AACD;;AACD,SAASu+B,0BAAT,CAAoCljC,IAApC,EAA0CyC,IAA1C,EAAgD;AAC9C,QAAMkB,MAAM,GAAG6+B,IAAI,CAAC3kB,SAAL,CAAe7d,IAAf,EAAqB,CAAEkI,OAAD,IAAcq8B,IAAD,IAAU/B,IAAI,CAAC1J,SAAL,CAAeyL,IAAf,EAAqB,SAASC,IAAT,CAAcpf,OAAd,EAAuB;AACtG,WAAOod,IAAI,CAACv5B,YAAL,CAAkBmc,OAAlB,KAA8BA,OAAO,CAAC3c,IAAR,KAAiBhG,IAA/C,GAAsD+/B,IAAI,CAACvL,gBAAL,CAAsB7R,OAAO,CAAC3c,IAA9B,CAAtD,GAA4F+5B,IAAI,CAAC9kB,cAAL,CAAoB0H,OAApB,EAA6Bof,IAA7B,EAAmCt8B,OAAnC,CAAnG;AACD,GAF2D,CAAxB,CAArB,CAAf;AAGA,SAAOvE,MAAM,CAACma,WAAP,CAAmB,CAAnB,CAAP;AACD,C,CAED;;;AACA,IAAI2mB,YAAY,GAAG,EAAnB;AACA,IAAIC,gBAAgB,GAAG,CACrB,OADqB,EAErB,QAFqB,EAGrB,WAHqB,EAIrB,cAJqB,EAKrB,cALqB,EAMrB,iBANqB,EAOrB,aAPqB,EAQrB,cARqB,CAAvB;AAUA,IAAIC,eAAe,GAAG,IAAIhxB,GAAJ,CAAQ,CAC5B,aAD4B,EAE5B,UAF4B,EAG5B,aAH4B,EAI5B,WAJ4B,EAK5B,iBAL4B,EAM5B,oBAN4B,EAO5B,oBAP4B,EAQ5B,uBAR4B,CAAR,CAAtB;AAUA,IAAIixB,eAAe,GAAG,cAAc3iB,cAAd,CAA6B;AACjDliB,EAAAA,WAAW,CAACiD,IAAD,EAAO2nB,QAAP,EAAiB9C,MAAjB,EAAyB4C,OAAzB,EAAkCG,QAAlC,EAA4Cia,aAA5C,EAA2D9f,cAA3D,EAA2E;AACpF,UAAM/hB,IAAN;AACA,SAAK2nB,QAAL,GAAgBA,QAAhB;AACA,SAAK9C,MAAL,GAAcA,MAAd;AACA,SAAK4C,OAAL,GAAeA,OAAf;AACA,SAAKG,QAAL,GAAgBA,QAAhB;AACA,SAAKia,aAAL,GAAqBA,aAArB;AACA,SAAK9f,cAAL,GAAsBA,cAAtB;AACA,SAAKxH,SAAL,GAAiB,IAAjB;AACD;;AACD+E,EAAAA,mBAAmB,CAACO,cAAD,EAAiB;AAClC,QAAI,EAAEA,cAAc,YAAY+hB,eAA5B,CAAJ,EAAkD;AAChD,aAAO,IAAP;AACD;;AACD,WAAO,KAAKja,QAAL,KAAkB9H,cAAc,CAAC8H,QAAjC,IAA6C,CAACtG,YAAY,CAAC,KAAKwD,MAAL,CAAYrB,aAAb,EAA4B3D,cAAc,CAACgF,MAAf,CAAsBrB,aAAlD,CAA1D,IAA8H,CAACnC,YAAY,CAAC,KAAKoG,OAAL,CAAajE,aAAd,EAA6B3D,cAAc,CAAC4H,OAAf,CAAuBjE,aAApD,CAA3I,IAAiN,CAACnC,YAAY,CAAC,KAAKuG,QAAN,EAAgB/H,cAAc,CAAC+H,QAA/B,CAArO;AACD;;AACDrI,EAAAA,sBAAsB,CAACM,cAAD,EAAiB;AACrC,QAAI,KAAKP,mBAAL,CAAyBO,cAAzB,CAAJ,EAA8C;AAC5C,aAAO,IAAP;AACD;;AACD,QAAI,EAAEA,cAAc,YAAY+hB,eAA5B,CAAJ,EAAkD;AAChD,aAAO,IAAP;AACD;;AACD,QAAI,CAACvgB,YAAY,CAACvgB,KAAK,CAACa,IAAN,CAAW,KAAKkjB,MAAhB,CAAD,EAA0B/jB,KAAK,CAACa,IAAN,CAAWke,cAAc,CAACgF,MAA1B,CAA1B,EAA6Did,mBAA7D,CAAb,IAAkG,CAACzgB,YAAY,CAACvgB,KAAK,CAACa,IAAN,CAAW,KAAK8lB,OAAhB,CAAD,EAA2B3mB,KAAK,CAACa,IAAN,CAAWke,cAAc,CAAC4H,OAA1B,CAA3B,EAA+Dqa,mBAA/D,CAAnH,EAAwM;AACtM,aAAO,IAAP;AACD;;AACD,QAAI,CAAC3f,sBAAsB,CAAC,KAAKJ,cAAN,EAAsBlC,cAAc,CAACkC,cAArC,CAA3B,EAAiF;AAC/E,aAAO,IAAP;AACD;;AACD,QAAI,CAACggB,oBAAoB,CAAC,KAAKF,aAAN,EAAqBhiB,cAAc,CAACgiB,aAApC,CAAzB,EAA6E;AAC3E,aAAO,IAAP;AACD;;AACD,QAAI,CAACG,gBAAgB,CAAC,KAAKznB,SAAN,EAAiBsF,cAAc,CAACtF,SAAhC,CAArB,EAAiE;AAC/D,aAAO,IAAP;AACD;;AACD,WAAO,KAAP;AACD;;AArCgD,CAAnD;;AAuCA,SAASunB,mBAAT,CAA6B1f,OAA7B,EAAsCC,QAAtC,EAAgD;AAC9C,SAAOD,OAAO,CAAC,CAAD,CAAP,KAAeC,QAAQ,CAAC,CAAD,CAAvB,IAA8BD,OAAO,CAAC,CAAD,CAAP,KAAeC,QAAQ,CAAC,CAAD,CAA5D;AACD;;AACD,SAAS0f,oBAAT,CAA8B3f,OAA9B,EAAuCC,QAAvC,EAAiD;AAC/C,MAAID,OAAO,CAAC8C,yBAAR,KAAsC7C,QAAQ,CAAC6C,yBAAnD,EAA8E;AAC5E,WAAO,KAAP;AACD;;AACD,MAAI9C,OAAO,CAAC0D,SAAR,KAAsBzD,QAAQ,CAACyD,SAAnC,EAA8C;AAC5C,WAAO,KAAP;AACD;;AACD,MAAI,CAACzE,YAAY,CAACe,OAAO,CAAC2C,gBAAT,EAA2B1C,QAAQ,CAAC0C,gBAApC,EAAsDkd,oBAAtD,CAAjB,EAA8F;AAC5F,WAAO,KAAP;AACD;;AACD,MAAI,CAACzgB,UAAU,CAACY,OAAO,CAACgD,kBAAT,EAA6B/C,QAAQ,CAAC+C,kBAAtC,CAAf,EAA0E;AACxE,WAAO,KAAP;AACD;;AACD,MAAI,CAAC5D,UAAU,CAACY,OAAO,CAACmD,qBAAT,EAAgClD,QAAQ,CAACkD,qBAAzC,CAAf,EAAgF;AAC9E,WAAO,KAAP;AACD;;AACD,MAAI,CAAC/D,UAAU,CAACY,OAAO,CAACoD,wBAAT,EAAmCnD,QAAQ,CAACmD,wBAA5C,CAAf,EAAsF;AACpF,WAAO,KAAP;AACD;;AACD,MAAI,CAAChE,UAAU,CAACY,OAAO,CAACqD,qBAAT,EAAgCpD,QAAQ,CAACoD,qBAAzC,CAAf,EAAgF;AAC9E,WAAO,KAAP;AACD;;AACD,SAAO,IAAP;AACD;;AACD,SAASwc,oBAAT,CAA8B7f,OAA9B,EAAuCC,QAAvC,EAAiD;AAC/C,SAAOD,OAAO,CAACkD,SAAR,KAAsBjD,QAAQ,CAACiD,SAA/B,IAA4ClD,OAAO,CAACxX,IAAR,KAAiByX,QAAQ,CAACzX,IAA7E;AACD;;AACD,SAASo3B,gBAAT,CAA0B5f,OAA1B,EAAmCC,QAAnC,EAA6C;AAC3C,MAAID,OAAO,KAAK,IAAZ,IAAoBC,QAAQ,KAAK,IAArC,EAA2C;AACzC,WAAOD,OAAO,KAAKC,QAAnB;AACD;;AACD,SAAOnB,aAAa,CAACkB,OAAD,EAAUC,QAAV,CAApB;AACD;;AACD,IAAI6f,yBAAyB,GAAG,MAAM;AACpCnlC,EAAAA,WAAW,CAAC0Y,SAAD,EAAY2E,SAAZ,EAAuB+nB,YAAvB,EAAqC/E,aAArC,EAAoDgF,UAApD,EAAgEC,kBAAhE,EAAoF3sB,MAApF,EAA4F4Y,uBAA5F,EAAqHkL,0BAArH,EAAiJ8I,4CAAjJ,EAA+LrU,IAA/L,EAAqM;AAC9M,SAAKxY,SAAL,GAAiBA,SAAjB;AACA,SAAK2E,SAAL,GAAiBA,SAAjB;AACA,SAAK+nB,YAAL,GAAoBA,YAApB;AACA,SAAK/E,aAAL,GAAqBA,aAArB;AACA,SAAKgF,UAAL,GAAkBA,UAAlB;AACA,SAAKC,kBAAL,GAA0BA,kBAA1B;AACA,SAAK3sB,MAAL,GAAcA,MAAd;AACA,SAAK4Y,uBAAL,GAA+BA,uBAA/B;AACA,SAAKkL,0BAAL,GAAkCA,0BAAlC;AACA,SAAK8I,4CAAL,GAAoDA,4CAApD;AACA,SAAKrU,IAAL,GAAYA,IAAZ;AACA,SAAKgD,UAAL,GAAkBvF,iBAAiB,CAACwF,OAApC;AACA,SAAKzxB,IAAL,GAAYyiC,yBAAyB,CAACziC,IAAtC;AACD;;AACDsxB,EAAAA,MAAM,CAAC/zB,IAAD,EAAOuZ,UAAP,EAAmB;AACvB,QAAI,CAACA,UAAL,EAAiB;AACf,YAAMgsB,YAAY,GAAG,KAAKC,iCAAL,CAAuCxlC,IAAvC,CAArB;AACA,aAAOulC,YAAY,GAAG;AAAEhP,QAAAA,OAAO,EAAEgP,YAAY,CAACvlC,IAAxB;AAA8B4b,QAAAA,SAAS,EAAE,IAAzC;AAA+C8Y,QAAAA,QAAQ,EAAE;AAAzD,OAAH,GAAqE,KAAK,CAA7F;AACD,KAHD,MAGO;AACL,YAAM9Y,SAAS,GAAGK,oBAAoB,CAAC1C,UAAD,EAAa,WAAb,EAA0B,KAAKb,MAA/B,CAAtC;AACA,aAAOkD,SAAS,GAAG;AAAE2a,QAAAA,OAAO,EAAE3a,SAAS,CAAC5b,IAArB;AAA2B4b,QAAAA,SAA3B;AAAsC8Y,QAAAA,QAAQ,EAAE9Y;AAAhD,OAAH,GAAiE,KAAK,CAAtF;AACD;AACF;;AACDgW,EAAAA,OAAO,CAAC5xB,IAAD,EAAO4b,SAAP,EAAkB4P,KAAK,GAAGoD,YAAY,CAAC6W,IAAvC,EAA6C;AAClD,QAAI,KAAKH,4CAAL,KAAsD,KAAtD,IAA+D1pB,SAAS,KAAK,IAAjF,EAAuF;AACrF,aAAO;AAAE0U,QAAAA,WAAW,EAAE,CAACoQ,gDAAgD,CAAC1gC,IAAD,CAAjD;AAAf,OAAP;AACD;;AACD,SAAKixB,IAAL,CAAUiB,UAAV,CAAqBxyB,SAAS,CAACgmC,gBAA/B;AACA,UAAMC,eAAe,GAAGC,wBAAwB,CAAC5lC,IAAD,EAAO4b,SAAP,EAAkB,KAAKnD,SAAvB,EAAkC,KAAK2E,SAAvC,EAAkD,KAAK1E,MAAvD,EAA+D8S,KAA/D,EAAsE,KAAKgR,0BAA3E,CAAhD;;AACA,QAAImJ,eAAe,KAAK,KAAK,CAA7B,EAAgC;AAC9B,aAAO,EAAP;AACD;;AACD,UAAM1V,QAAQ,GAAG0V,eAAe,CAACjR,QAAjC;AACA,QAAImR,yBAAyB,GAAG,IAAhC;;AACA,QAAIF,eAAe,KAAK,KAAK,CAAzB,IAA8BA,eAAe,CAAC/pB,SAAhB,CAA0BlZ,GAA1B,CAA8B,WAA9B,CAAlC,EAA8E;AAC5EmjC,MAAAA,yBAAyB,GAAGvnB,gCAAgC,CAACqnB,eAAe,CAAC/pB,SAAhB,CAA0BjZ,GAA1B,CAA8B,WAA9B,CAAD,EAA6C,KAAK8V,SAAlD,EAA6D,KAAK2E,SAAlE,CAA5D;AACD;;AACD,WAAO;AACL6S,MAAAA,QAAQ,EAAE;AACRpI,QAAAA,MAAM,EAAE8d,eAAe,CAAC9d,MADhB;AAER4C,QAAAA,OAAO,EAAEkb,eAAe,CAAClb,OAFjB;AAGR3sB,QAAAA,IAAI,EAAEmyB,QAHE;AAIR6V,QAAAA,aAAa,EAAErD,oBAAoB,CAACziC,IAAD,EAAO,KAAKyY,SAAZ,EAAuB,KAAKC,MAA5B,EAAoC,KAAK8jB,0BAAzC,CAJ3B;AAKRjf,QAAAA,SAAS,EAAEJ,aAAa,CAACnd,IAAD,EAAO,KAAKyY,SAAZ,EAAuB,KAAK2E,SAA5B,CALhB;AAMRynB,QAAAA,aAAa,EAAEjd,6BAA6B,CAAC5nB,IAAD,EAAO2lC,eAAe,CAAC9d,MAAvB,EAA+B,KAAKpP,SAApC,CANpC;AAORotB,QAAAA,yBAPQ;AAQR9a,QAAAA,UAAU,EAAE,KARJ;AASRP,QAAAA,YAAY,EAAEmb,eAAe,CAACnb;AATtB;AADL,KAAP;AAaD;;AACDpf,EAAAA,MAAM,CAACpL,IAAD,EAAOiwB,QAAP,EAAiB;AACrB,UAAMlL,cAAc,GAAGF,6BAA6B,CAAC7kB,IAAD,CAApD;AACA,WAAO,IAAI4kC,eAAJ,CAAoB5kC,IAApB,EAA0BiwB,QAAQ,CAACnyB,IAAT,CAAc6sB,QAAxC,EAAkDsF,QAAQ,CAACpI,MAA3D,EAAmEoI,QAAQ,CAACxF,OAA5E,EAAqFwF,QAAQ,CAACnyB,IAAT,CAAc8sB,QAAnG,EAA6GqF,QAAQ,CAAC4U,aAAtH,EAAqI9f,cAArI,CAAP;AACD;;AACD0O,EAAAA,QAAQ,CAACzzB,IAAD,EAAOiwB,QAAP,EAAiB;AACvB,UAAM1vB,GAAG,GAAG,IAAI3B,SAAJ,CAAcoB,IAAd,CAAZ;AACA,SAAKmlC,YAAL,CAAkB1Y,yBAAlB,CAA4C7sB,aAAa,CAACC,cAAc,CAAC;AACvE+N,MAAAA,IAAI,EAAE2X,QAAQ,CAACmF,SADwD;AAEvEnqB,MAAAA,GAFuE;AAGvEkC,MAAAA,IAAI,EAAEzC,IAAI,CAACyC,IAAL,CAAUgG,IAHuD;AAIvEkiB,MAAAA,QAAQ,EAAEsF,QAAQ,CAACnyB,IAAT,CAAc6sB,QAJ+C;AAKvEC,MAAAA,QAAQ,EAAEqF,QAAQ,CAACnyB,IAAT,CAAc8sB,QAL+C;AAMvE/C,MAAAA,MAAM,EAAEoI,QAAQ,CAACpI,MANsD;AAOvE4C,MAAAA,OAAO,EAAEwF,QAAQ,CAACxF,OAPqD;AAQvEI,MAAAA,OAAO,EAAEoF,QAAQ,CAACnyB,IAAT,CAAc+sB,OAAd,CAAsBhoB,GAAtB,CAA2BkjC,KAAD,IAAWA,KAAK,CAACp0B,YAA3C,CAR8D;AASvE4Y,MAAAA,WAAW,EAAE,KAT0D;AAUvEhN,MAAAA,SAAS,EAAE0S,QAAQ,CAAC1S;AAVmD,KAAD,EAWrE0S,QAAQ,CAAC4U,aAX4D,CAAf,EAW7B;AAC1B9Z,MAAAA,UAAU,EAAEkF,QAAQ,CAAClF,UADK;AAE1BP,MAAAA,YAAY,EAAEyF,QAAQ,CAACzF;AAFG,KAX6B,CAAzD;AAeA,SAAK6a,kBAAL,CAAwBpY,kBAAxB,CAA2CjtB,IAA3C;AACD;;AACD60B,EAAAA,OAAO,CAAC70B,IAAD,EAAOiwB,QAAP,EAAiB7kB,MAAjB,EAAyB;AAC9B,QAAI,KAAKkmB,uBAAL,KAAiC,IAAjC,IAAyCrB,QAAQ,CAAC1S,SAAT,YAA8B3e,SAA3E,EAAsF;AACpFwM,MAAAA,MAAM,CAACmS,SAAP,GAAmB,KAAK+T,uBAAL,CAA6BzN,SAA7B,CAAuCoM,QAAQ,CAAC1S,SAAT,CAAmBvd,IAA1D,CAAnB;AACD;;AACD,UAAMswB,WAAW,GAAG,EAApB;;AACA,QAAIL,QAAQ,CAAC4V,yBAAT,KAAuC,IAAvC,IAA+C5V,QAAQ,CAACnyB,IAAT,CAAc0gB,SAAd,YAAmCqjB,gBAAtF,EAAwG;AACtG,YAAMmE,mBAAmB,GAAGjG,sBAAsB,CAAC9P,QAAQ,CAAC4V,yBAAV,EAAqC5V,QAAQ,CAACnyB,IAAT,CAAc0gB,SAAd,CAAwBxe,IAA7D,EAAmE,KAAKqlC,kBAAxE,CAAlD;AACA/U,MAAAA,WAAW,CAACzsB,IAAZ,CAAiB,GAAGmiC,mBAApB;AACD;;AACD,UAAMC,oBAAoB,GAAG9F,uBAAuB,CAACngC,IAAD,EAAO,KAAKolC,UAAZ,EAAwB,KAAKhoB,SAA7B,EAAwC,KAAK3E,SAA7C,EAAwD,KAAK2nB,aAA7D,EAA4E,WAA5E,CAApD;;AACA,QAAI6F,oBAAoB,KAAK,IAA7B,EAAmC;AACjC3V,MAAAA,WAAW,CAACzsB,IAAZ,CAAiB,GAAGoiC,oBAApB;AACD;;AACD,WAAO;AAAE3V,MAAAA,WAAW,EAAEA,WAAW,CAAC7sB,MAAZ,GAAqB,CAArB,GAAyB6sB,WAAzB,GAAuC,KAAK;AAA3D,KAAP;AACD;;AACD2F,EAAAA,WAAW,CAACj2B,IAAD,EAAOiwB,QAAP,EAAiBC,UAAjB,EAA6BgW,IAA7B,EAAmC;AAC5C,UAAM/lB,GAAG,GAAG8hB,wBAAwB,CAAC1hB,iBAAiB,CAAC0P,QAAQ,CAACnyB,IAAV,EAAgBsjB,aAAa,CAACsJ,SAA9B,CAAlB,CAApC;AACA,UAAMtK,GAAG,GAAGkhB,4BAA4B,CAACrR,QAAQ,CAACnyB,IAAV,EAAgBooC,IAAhB,EAAsB3kB,iBAAiB,EAAvC,CAAxC;AACA,UAAMukB,aAAa,GAAG7V,QAAQ,CAAC6V,aAAT,KAA2B,IAA3B,GAAkCplB,oBAAoB,CAACuP,QAAQ,CAAC6V,aAAV,CAApB,CAA6CK,MAA7C,EAAlC,GAA0F,IAAhH;AACA,WAAOjmB,cAAc,CAACC,GAAD,EAAMC,GAAN,EAAW0lB,aAAX,EAA0B,WAA1B,CAArB;AACD;;AACD9P,EAAAA,cAAc,CAACh2B,IAAD,EAAOiwB,QAAP,EAAiBC,UAAjB,EAA6B;AACzC,UAAM/P,GAAG,GAAG+hB,qBAAqB,CAAC3hB,iBAAiB,CAAC0P,QAAQ,CAACnyB,IAAV,EAAgBsjB,aAAa,CAACsJ,SAA9B,CAAlB,CAAjC;AACA,UAAMtK,GAAG,GAAGihB,mCAAmC,CAACpR,QAAQ,CAACnyB,IAAV,CAA/C;AACA,UAAMgoC,aAAa,GAAG7V,QAAQ,CAAC6V,aAAT,KAA2B,IAA3B,GAAkCjlB,2BAA2B,CAACoP,QAAQ,CAAC6V,aAAV,CAA3B,CAAoDK,MAApD,EAAlC,GAAiG,IAAvH;AACA,WAAOjmB,cAAc,CAACC,GAAD,EAAMC,GAAN,EAAW0lB,aAAX,EAA0B,WAA1B,CAArB;AACD;;AACDN,EAAAA,iCAAiC,CAACxlC,IAAD,EAAO;AACtC,WAAO,KAAKyY,SAAL,CAAe5J,iBAAf,CAAiC7O,IAAjC,EAAuC8O,IAAvC,CAA6Cd,MAAD,IAAY;AAC7D,UAAI,CAACA,MAAM,CAACgB,QAAR,IAAoBhB,MAAM,CAAC5F,IAAP,KAAgBnK,eAAe,CAACkqB,MAApD,IAA8Dwc,eAAe,CAACjiC,GAAhB,CAAoBsL,MAAM,CAACvL,IAA3B,CAAlE,EAAoG;AAClG,eAAO,IAAP;AACD;;AACD,UAAIuL,MAAM,CAACuL,UAAX,EAAuB;AACrB,eAAOvL,MAAM,CAACuL,UAAP,CAAkB3G,IAAlB,CAAwBgJ,SAAD,IAAe8oB,gBAAgB,CAAC9xB,IAAjB,CAAuBwzB,aAAD,IAAmBlqB,kBAAkB,CAACN,SAAD,EAAYwqB,aAAZ,EAA2B,KAAK1tB,MAAhC,CAA3D,CAAtC,CAAP;AACD;;AACD,aAAO,KAAP;AACD,KARM,CAAP;AASD;;AAjHmC,CAAtC;;AAmHA,SAASktB,wBAAT,CAAkCptB,KAAlC,EAAyCoD,SAAzC,EAAoDnD,SAApD,EAA+D2E,SAA/D,EAA0E1E,MAA1E,EAAkF8S,KAAlF,EAAyFgR,0BAAzF,EAAqH6J,eAAe,GAAG,IAAvI,EAA6I;AAC3I,MAAIC,SAAJ;;AACA,MAAI1qB,SAAS,KAAK,IAAd,IAAsBA,SAAS,CAACpY,IAAV,KAAmB,IAAzC,IAAiDoY,SAAS,CAACpY,IAAV,CAAeC,MAAf,KAA0B,CAA/E,EAAkF;AAChF6iC,IAAAA,SAAS,GAAG,IAAIxjC,GAAJ,EAAZ;AACD,GAFD,MAEO,IAAI8Y,SAAS,CAACpY,IAAV,CAAeC,MAAf,KAA0B,CAA9B,EAAiC;AACtC,UAAM,IAAIiR,oBAAJ,CAAyBlB,SAAS,CAACmG,qBAAnC,EAA0Dzb,SAAS,CAAC0b,YAAV,CAAuBgC,SAAvB,CAA1D,EAA8F,qCAAoCA,SAAS,CAACnZ,IAAK,YAAjJ,CAAN;AACD,GAFM,MAEA;AACL,UAAM3E,IAAI,GAAGqe,gBAAgB,CAACP,SAAS,CAACpY,IAAV,CAAe,CAAf,CAAD,CAA7B;;AACA,QAAI,CAACs+B,IAAI,CAAC/4B,yBAAL,CAA+BjL,IAA/B,CAAL,EAA2C;AACzC,YAAM,IAAI4W,oBAAJ,CAAyBlB,SAAS,CAACI,yBAAnC,EAA8D9V,IAA9D,EAAqE,IAAG8d,SAAS,CAACnZ,IAAK,qCAAvF,CAAN;AACD;;AACD6jC,IAAAA,SAAS,GAAG/nC,oBAAoB,CAACT,IAAD,CAAhC;AACD;;AACD,MAAIwoC,SAAS,CAAC5jC,GAAV,CAAc,KAAd,CAAJ,EAA0B;AACxB,WAAO,KAAK,CAAZ;AACD;;AACD,QAAMqL,OAAO,GAAG0K,SAAS,CAAC5J,iBAAV,CAA4B2J,KAA5B,CAAhB;AACA,QAAM+tB,iBAAiB,GAAGx4B,OAAO,CAACyL,MAAR,CAAgBxL,MAAD,IAAY,CAACA,MAAM,CAACgB,QAAR,IAAoBhB,MAAM,CAACuL,UAAP,KAAsB,IAArE,CAA1B;AACA,QAAMitB,UAAU,GAAG9tB,MAAM,GAAG,KAAK,CAAR,GAAY,eAArC;AACA,QAAM+tB,cAAc,GAAGC,2BAA2B,CAACJ,SAAD,EAAY,QAAZ,EAAsBlpB,SAAtB,CAAlD;AACA,QAAMupB,gBAAgB,GAAGC,oBAAoB,CAACxoC,4BAA4B,CAACmoC,iBAAD,EAAoB,OAApB,EAA6BC,UAA7B,CAA7B,EAAuEppB,SAAvE,EAAkFypB,YAAlF,CAA7C;AACA,QAAMC,eAAe,GAAGJ,2BAA2B,CAACJ,SAAD,EAAY,SAAZ,EAAuBlpB,SAAvB,CAAnD;AACA,QAAM2pB,iBAAiB,GAAGH,oBAAoB,CAACxoC,4BAA4B,CAACmoC,iBAAD,EAAoB,QAApB,EAA8BC,UAA9B,CAA7B,EAAwEppB,SAAxE,EAAmF4pB,aAAnF,CAA9C;AACA,QAAMC,sBAAsB,GAAGC,iBAAiB,CAAC9oC,4BAA4B,CAACmoC,iBAAD,EAAoB,cAApB,EAAoCC,UAApC,CAA7B,EAA8E/tB,SAA9E,EAAyF2E,SAAzF,CAAhD;AACA,QAAM+pB,yBAAyB,GAAGD,iBAAiB,CAAC9oC,4BAA4B,CAACmoC,iBAAD,EAAoB,iBAApB,EAAuCC,UAAvC,CAA7B,EAAiF/tB,SAAjF,EAA4F2E,SAA5F,CAAnD;AACA,QAAMyN,OAAO,GAAG,CAAC,GAAGoc,sBAAJ,EAA4B,GAAGE,yBAA/B,CAAhB;AACA,QAAMC,mBAAmB,GAAGF,iBAAiB,CAAC9oC,4BAA4B,CAACmoC,iBAAD,EAAoB,WAApB,EAAiCC,UAAjC,CAA7B,EAA2E/tB,SAA3E,EAAsF2E,SAAtF,CAA7C;AACA,QAAMiqB,sBAAsB,GAAGH,iBAAiB,CAAC9oC,4BAA4B,CAACmoC,iBAAD,EAAoB,cAApB,EAAoCC,UAApC,CAA7B,EAA8E/tB,SAA9E,EAAyF2E,SAAzF,CAAhD;AACA,QAAMkqB,WAAW,GAAG,CAAC,GAAGF,mBAAJ,EAAyB,GAAGC,sBAA5B,CAApB;;AACA,MAAIf,SAAS,CAAC5jC,GAAV,CAAc,SAAd,CAAJ,EAA8B;AAC5B,UAAM6kC,oBAAoB,GAAGC,2BAA2B,CAAClB,SAAS,CAAC3jC,GAAV,CAAc,SAAd,CAAD,EAA2B8V,SAA3B,EAAsC2E,SAAtC,EAAiD1E,MAAjD,CAAxD;AACAmS,IAAAA,OAAO,CAAChnB,IAAR,CAAa,GAAG0jC,oBAAoB,CAACE,OAArC;AACAH,IAAAA,WAAW,CAACzjC,IAAZ,CAAiB,GAAG0jC,oBAAoB,CAACG,IAAzC;AACD;;AACD,MAAI/c,QAAQ,GAAG0b,eAAf;;AACA,MAAIC,SAAS,CAAC5jC,GAAV,CAAc,UAAd,CAAJ,EAA+B;AAC7B,UAAM2M,IAAI,GAAGi3B,SAAS,CAAC3jC,GAAV,CAAc,UAAd,CAAb;AACA,UAAMS,QAAQ,GAAGga,SAAS,CAAC7a,QAAV,CAAmB8M,IAAnB,CAAjB;;AACA,QAAI,OAAOjM,QAAP,KAAoB,QAAxB,EAAkC;AAChC,YAAMu8B,4BAA4B,CAACtwB,IAAD,EAAOjM,QAAP,EAAkB,2BAAlB,CAAlC;AACD;;AACDunB,IAAAA,QAAQ,GAAGvnB,QAAQ,KAAK,EAAb,GAAkBijC,eAAlB,GAAoCjjC,QAA/C;;AACA,QAAI,CAACunB,QAAL,EAAe;AACb,YAAM,IAAIjW,oBAAJ,CAAyBlB,SAAS,CAACm0B,0BAAnC,EAA+Dt4B,IAA/D,EAAsE,aAAYmJ,KAAK,CAAC/V,IAAN,CAAWgG,IAAK,kCAAlG,CAAN;AACD;AACF;;AACD,QAAMX,IAAI,GAAG8/B,mBAAmB,CAACrB,iBAAD,EAAoBnpB,SAApB,EAA+BopB,UAA/B,EAA2CF,SAA3C,CAAhC;AACA,QAAM9nB,SAAS,GAAG8nB,SAAS,CAAC5jC,GAAV,CAAc,WAAd,IAA6B,IAAIm/B,gBAAJ,CAAqBrF,0BAA0B,GAAG5e,+BAA+B,CAAC0oB,SAAS,CAAC3jC,GAAV,CAAc,WAAd,CAAD,CAAlC,GAAiE2jC,SAAS,CAAC3jC,GAAV,CAAc,WAAd,CAAhH,CAA7B,GAA2K,IAA7L;AACA,QAAMklC,aAAa,GAAG95B,OAAO,CAAC6E,IAAR,CAAc5E,MAAD,IAAY,CAACA,MAAM,CAACgB,QAAR,IAAoBhB,MAAM,CAAC5F,IAAP,KAAgBnK,eAAe,CAACkqB,MAApD,IAA8Dna,MAAM,CAACvL,IAAP,KAAgB,aAAvG,CAAtB;AACA,MAAImoB,QAAQ,GAAG,IAAf;;AACA,MAAI0b,SAAS,CAAC5jC,GAAV,CAAc,UAAd,CAAJ,EAA+B;AAC7B,UAAM2M,IAAI,GAAGi3B,SAAS,CAAC3jC,GAAV,CAAc,UAAd,CAAb;AACA,UAAMS,QAAQ,GAAGga,SAAS,CAAC7a,QAAV,CAAmB8M,IAAnB,CAAjB;;AACA,QAAI,OAAOjM,QAAP,KAAoB,QAAxB,EAAkC;AAChC,YAAMu8B,4BAA4B,CAACtwB,IAAD,EAAOjM,QAAP,EAAkB,2BAAlB,CAAlC;AACD;;AACDwnB,IAAAA,QAAQ,GAAGxnB,QAAQ,CAAC0kC,KAAT,CAAe,GAAf,EAAoBjlC,GAApB,CAAyBklC,IAAD,IAAUA,IAAI,CAACC,IAAL,EAAlC,CAAX;AACD;;AACD,QAAMC,WAAW,GAAG1vB,0BAA0B,CAACC,KAAD,EAAQC,SAAR,EAAmBC,MAAnB,CAA9C;AACA,QAAMwvB,QAAQ,GAAGvd,QAAQ,KAAK,IAAb,GAAoBjQ,+BAA+B,CAAClC,KAAD,EAAQyvB,WAAR,CAAnD,GAA0EztB,6BAA6B,CAACytB,WAAD,CAAxH;AACA,QAAMzd,YAAY,GAAG0d,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,KAAK,SAAlC,IAA+CA,QAAQ,CAACt1B,IAAT,CAAeu1B,GAAD,IAASA,GAAG,CAACnvB,KAAJ,YAAqByoB,aAArB,IAAsC0G,GAAG,CAACnvB,KAAJ,CAAUrY,KAAV,CAAgB0Z,UAAhB,KAA+B,eAArE,IAAwF8tB,GAAG,CAACnvB,KAAJ,CAAUrY,KAAV,CAAgB8B,IAAhB,KAAyB,aAAxI,CAApE;AACA,QAAM2lC,eAAe,GAAG3vB,SAAS,CAACK,YAAV,CAAuBN,KAAvB,CAAxB;AACA,QAAM5K,IAAI,GAAGqR,iBAAiB,CAACxG,SAAD,EAAYD,KAAZ,CAA9B;AACA,QAAMgI,YAAY,GAAG,IAAIqhB,gBAAJ,CAAqBppB,SAAS,CAAC4vB,sBAAV,CAAiC7vB,KAAjC,CAArB,CAArB;AACA,QAAMqP,MAAM,GAAGnC,oBAAoB,CAACK,gBAArB,CAAsClmB,cAAc,CAACA,cAAc,CAAC,EAAD,EAAK4mC,cAAL,CAAf,EAAqCE,gBAArC,CAApD,CAAf;AACA,QAAMlc,OAAO,GAAG/E,oBAAoB,CAACK,gBAArB,CAAsClmB,cAAc,CAACA,cAAc,CAAC,EAAD,EAAKinC,eAAL,CAAf,EAAsCC,iBAAtC,CAApD,CAAhB;AACA,QAAMrS,QAAQ,GAAG;AACfjyB,IAAAA,IAAI,EAAE+V,KAAK,CAAC/V,IAAN,CAAWgG,IADF;AAEfkQ,IAAAA,IAAI,EAAEuvB,QAFS;AAGfpgC,IAAAA,IAHe;AAIfwgC,IAAAA,SAAS,EAAE;AACTT,MAAAA;AADS,KAJI;AAOfhgB,IAAAA,MAAM,EAAEA,MAAM,CAAChB,mBAAP,EAPO;AAQf4D,IAAAA,OAAO,EAAEA,OAAO,CAAC7D,oBAAR,EARM;AASfiE,IAAAA,OATe;AAUfyc,IAAAA,WAVe;AAWf3c,IAAAA,QAXe;AAYf4d,IAAAA,eAAe,EAAE,CAAC,EAAE/c,KAAK,GAAGoD,YAAY,CAAC4Z,gBAAvB,CAZH;AAaf56B,IAAAA,IAbe;AAcf4S,IAAAA,YAde;AAefC,IAAAA,iBAAiB,EAAEhI,SAAS,CAACoQ,sBAAV,CAAiCrQ,KAAjC,KAA2C,CAf/C;AAgBfiwB,IAAAA,cAAc,EAAErpB,gBAAgB,CAAC5G,KAAK,CAAC/V,IAAP,CAhBjB;AAiBf2lC,IAAAA,eAjBe;AAkBfxd,IAAAA,QAlBe;AAmBfpM,IAAAA;AAnBe,GAAjB;AAqBA,SAAO;AACL5C,IAAAA,SAAS,EAAE0qB,SADN;AAEL5R,IAAAA,QAFK;AAGL7M,IAAAA,MAHK;AAIL4C,IAAAA,OAJK;AAKLD,IAAAA;AALK,GAAP;AAOD;;AACD,SAASke,oBAAT,CAA8BjM,QAA9B,EAAwCh6B,IAAxC,EAA8Ce,IAA9C,EAAoDmO,YAApD,EAAkE8G,SAAlE,EAA6E2E,SAA7E,EAAwF;AACtF,MAAI5Z,IAAI,CAACC,MAAL,KAAgB,CAApB,EAAuB;AACrB,UAAM,IAAIiR,oBAAJ,CAAyBlB,SAAS,CAACmG,qBAAnC,EAA0D8iB,QAA1D,EAAqE,IAAGh6B,IAAK,sBAA7E,CAAN;AACD;;AACD,QAAMkmC,KAAK,GAAGlmC,IAAI,KAAK,WAAT,IAAwBA,IAAI,KAAK,cAA/C;AACA,QAAMmmC,sBAAsB,GAAGnsB,mBAAmB,CAACjZ,IAAI,CAAC,CAAD,CAAL,EAAUiV,SAAV,CAAlD;AACA,QAAMzY,IAAI,GAAG4oC,sBAAsB,IAAI,IAA1B,GAAiCA,sBAAjC,GAA0DplC,IAAI,CAAC,CAAD,CAA3E;AACA,QAAMI,GAAG,GAAGwZ,SAAS,CAAC7a,QAAV,CAAmBvC,IAAnB,CAAZ;AACA,MAAIgP,QAAQ,GAAG,KAAf;AACA,MAAI65B,SAAS,GAAG,IAAhB;;AACA,MAAIjlC,GAAG,YAAYhF,SAAf,IAA4BgF,GAAG,YAAY9D,YAA/C,EAA6D;AAC3D+oC,IAAAA,SAAS,GAAGtH,+BAA+B,CAAC,IAAIM,gBAAJ,CAAqB7hC,IAArB,CAAD,EAA6B4oC,sBAAsB,KAAK,IAA3B,GAAkC,CAAlC,GAAsC,CAAnE,CAA3C;AACD,GAFD,MAEO,IAAI,OAAOhlC,GAAP,KAAe,QAAnB,EAA6B;AAClCilC,IAAAA,SAAS,GAAG,CAACjlC,GAAD,CAAZ;AACD,GAFM,MAEA,IAAIklC,kBAAkB,CAACllC,GAAD,EAAO,IAAGnB,IAAK,YAAf,EAA4BzC,IAA5B,CAAtB,EAAyD;AAC9D6oC,IAAAA,SAAS,GAAGjlC,GAAZ;AACD,GAFM,MAEA;AACL,UAAM+7B,4BAA4B,CAAC3/B,IAAD,EAAO4D,GAAP,EAAa,IAAGnB,IAAK,kCAArB,CAAlC;AACD;;AACD,MAAIsmC,IAAI,GAAG,IAAX;AACA,MAAIC,WAAW,GAAGvmC,IAAI,KAAK,iBAA3B;AACA,MAAIwmC,uBAAuB,GAAGzH,mCAA9B;;AACA,MAAIh+B,IAAI,CAACC,MAAL,KAAgB,CAApB,EAAuB;AACrB,UAAMylC,WAAW,GAAG/sB,gBAAgB,CAAC3Y,IAAI,CAAC,CAAD,CAAL,CAApC;;AACA,QAAI,CAACs+B,IAAI,CAAC/4B,yBAAL,CAA+BmgC,WAA/B,CAAL,EAAkD;AAChD,YAAM,IAAIx0B,oBAAJ,CAAyBlB,SAAS,CAACI,yBAAnC,EAA8Ds1B,WAA9D,EAA4E,IAAGzmC,IAAK,oCAApF,CAAN;AACD;;AACD,UAAM0mC,OAAO,GAAG5qC,oBAAoB,CAAC2qC,WAAD,CAApC;;AACA,QAAIC,OAAO,CAACzmC,GAAR,CAAY,MAAZ,CAAJ,EAAyB;AACvBqmC,MAAAA,IAAI,GAAG,IAAIlH,gBAAJ,CAAqBsH,OAAO,CAACxmC,GAAR,CAAY,MAAZ,CAArB,CAAP;AACD;;AACD,QAAIwmC,OAAO,CAACzmC,GAAR,CAAY,aAAZ,CAAJ,EAAgC;AAC9B,YAAM0mC,eAAe,GAAGD,OAAO,CAACxmC,GAAR,CAAY,aAAZ,CAAxB;AACA,YAAM0mC,gBAAgB,GAAGjsB,SAAS,CAAC7a,QAAV,CAAmB6mC,eAAnB,CAAzB;;AACA,UAAI,OAAOC,gBAAP,KAA4B,SAAhC,EAA2C;AACzC,cAAM1J,4BAA4B,CAACyJ,eAAD,EAAkBC,gBAAlB,EAAqC,IAAG5mC,IAAK,wCAA7C,CAAlC;AACD;;AACDumC,MAAAA,WAAW,GAAGK,gBAAd;AACD;;AACD,QAAIF,OAAO,CAACzmC,GAAR,CAAY,yBAAZ,CAAJ,EAA4C;AAC1C,YAAM4mC,2BAA2B,GAAGH,OAAO,CAACxmC,GAAR,CAAY,yBAAZ,CAApC;AACA,YAAM4mC,4BAA4B,GAAGnsB,SAAS,CAAC7a,QAAV,CAAmB+mC,2BAAnB,CAArC;;AACA,UAAI,OAAOC,4BAAP,KAAwC,SAA5C,EAAuD;AACrD,cAAM5J,4BAA4B,CAAC2J,2BAAD,EAA8BC,4BAA9B,EAA6D,IAAG9mC,IAAK,oDAArE,CAAlC;AACD;;AACDwmC,MAAAA,uBAAuB,GAAGM,4BAA1B;AACD;;AACD,QAAIJ,OAAO,CAACzmC,GAAR,CAAY,QAAZ,CAAJ,EAA2B;AACzB,YAAM8mC,WAAW,GAAGpsB,SAAS,CAAC7a,QAAV,CAAmB4mC,OAAO,CAACxmC,GAAR,CAAY,QAAZ,CAAnB,CAApB;;AACA,UAAI,OAAO6mC,WAAP,KAAuB,SAA3B,EAAsC;AACpC,cAAM7J,4BAA4B,CAAC3/B,IAAD,EAAOwpC,WAAP,EAAqB,IAAG/mC,IAAK,mCAA7B,CAAlC;AACD;;AACDuM,MAAAA,QAAQ,GAAGw6B,WAAX;AACD;AACF,GAhCD,MAgCO,IAAIhmC,IAAI,CAACC,MAAL,GAAc,CAAlB,EAAqB;AAC1B,UAAM,IAAIiR,oBAAJ,CAAyBlB,SAAS,CAACmG,qBAAnC,EAA0D3Z,IAA1D,EAAiE,IAAGyC,IAAK,yBAAzE,CAAN;AACD;;AACD,SAAO;AACLkP,IAAAA,YADK;AAELk3B,IAAAA,SAFK;AAGLF,IAAAA,KAHK;AAILK,IAAAA,WAJK;AAKLD,IAAAA,IALK;AAMLU,IAAAA,MAAM,EAAEz6B,QANH;AAOLi6B,IAAAA;AAPK,GAAP;AASD;;AACD,SAASzB,2BAAT,CAAqCkC,SAArC,EAAgDjxB,SAAhD,EAA2D2E,SAA3D,EAAsE1E,MAAtE,EAA8E;AAC5E,QAAM+uB,OAAO,GAAG,EAAhB;AAAA,QAAoBC,IAAI,GAAG,EAA3B;;AACA,MAAI,CAAC5F,IAAI,CAAC/4B,yBAAL,CAA+B2gC,SAA/B,CAAL,EAAgD;AAC9C,UAAM,IAAIh1B,oBAAJ,CAAyBlB,SAAS,CAACssB,oBAAnC,EAAyD4J,SAAzD,EAAoE,sDAApE,CAAN;AACD;;AACDnrC,EAAAA,oBAAoB,CAACmrC,SAAD,CAApB,CAAgC3mC,OAAhC,CAAwC,CAAC4mC,SAAD,EAAYh4B,YAAZ,KAA6B;AACnEg4B,IAAAA,SAAS,GAAGxtB,gBAAgB,CAACwtB,SAAD,CAA5B;;AACA,QAAI,CAAC7H,IAAI,CAAC8H,eAAL,CAAqBD,SAArB,CAAL,EAAsC;AACpC,YAAM,IAAIj1B,oBAAJ,CAAyBlB,SAAS,CAACssB,oBAAnC,EAAyD4J,SAAzD,EAAoE,8DAApE,CAAN;AACD;;AACD,UAAMG,SAAS,GAAG/H,IAAI,CAAC34B,0BAAL,CAAgCwgC,SAAS,CAACv/B,UAA1C,IAAwDu/B,SAAS,CAACv/B,UAAV,CAAqB3H,IAA7E,GAAoFknC,SAAS,CAACv/B,UAAhH;;AACA,QAAI,CAAC03B,IAAI,CAAC74B,YAAL,CAAkB4gC,SAAlB,CAAL,EAAmC;AACjC,YAAM,IAAIn1B,oBAAJ,CAAyBlB,SAAS,CAACssB,oBAAnC,EAAyD4J,SAAzD,EAAoE,8DAApE,CAAN;AACD;;AACD,UAAM97B,IAAI,GAAG6K,SAAS,CAACxM,qBAAV,CAAgC49B,SAAhC,CAAb;;AACA,QAAIj8B,IAAI,KAAK,IAAT,IAAiB,CAAC8K,MAAD,IAAW9K,IAAI,CAACjJ,IAAL,KAAc,eAA1C,IAA6D,CAACmlC,WAAW,CAACpnC,GAAZ,CAAgBkL,IAAI,CAACnL,IAArB,CAAlE,EAA8F;AAC5F,YAAM,IAAIiS,oBAAJ,CAAyBlB,SAAS,CAACssB,oBAAnC,EAAyD4J,SAAzD,EAAoE,8DAApE,CAAN;AACD;;AACD,UAAM3D,KAAK,GAAG2C,oBAAoB,CAACiB,SAAD,EAAY/7B,IAAI,CAACnL,IAAjB,EAAuBknC,SAAS,CAACp6B,SAAV,IAAuB,EAA9C,EAAkDoC,YAAlD,EAAgE8G,SAAhE,EAA2E2E,SAA3E,CAAlC;;AACA,QAAIxP,IAAI,CAACnL,IAAL,CAAU4kB,UAAV,CAAqB,SAArB,CAAJ,EAAqC;AACnCogB,MAAAA,OAAO,CAAC5jC,IAAR,CAAakiC,KAAb;AACD,KAFD,MAEO;AACL2B,MAAAA,IAAI,CAAC7jC,IAAL,CAAUkiC,KAAV;AACD;AACF,GAnBD;AAoBA,SAAO;AAAE0B,IAAAA,OAAF;AAAWC,IAAAA;AAAX,GAAP;AACD;;AACD,SAASoB,kBAAT,CAA4BnoC,KAA5B,EAAmC8B,IAAnC,EAAyCzC,IAAzC,EAA+C;AAC7C,MAAI,CAAC8D,KAAK,CAACC,OAAN,CAAcpD,KAAd,CAAL,EAA2B;AACzB,WAAO,KAAP;AACD;;AACD,OAAK,IAAI8J,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG9J,KAAK,CAAC8C,MAA1B,EAAkCgH,CAAC,EAAnC,EAAuC;AACrC,QAAI,OAAO9J,KAAK,CAAC8J,CAAD,CAAZ,KAAoB,QAAxB,EAAkC;AAChC,YAAMk1B,4BAA4B,CAAC3/B,IAAD,EAAOW,KAAK,CAAC8J,CAAD,CAAZ,EAAkB,qBAAoBhI,IAAK,gBAAegI,CAAE,cAA5D,CAAlC;AACD;AACF;;AACD,SAAO,IAAP;AACD;;AACD,SAASs/B,oBAAT,CAA8BzD,SAA9B,EAAyC5d,KAAzC,EAAgDtL,SAAhD,EAA2D;AACzD,MAAI,CAACkpB,SAAS,CAAC5jC,GAAV,CAAcgmB,KAAd,CAAL,EAA2B;AACzB,WAAO,IAAP;AACD;;AACD,QAAMte,UAAU,GAAGk8B,SAAS,CAAC3jC,GAAV,CAAc+lB,KAAd,CAAnB;AACA,QAAM/nB,KAAK,GAAGyc,SAAS,CAAC7a,QAAV,CAAmB6H,UAAnB,CAAd;;AACA,MAAI,CAAC0+B,kBAAkB,CAACnoC,KAAD,EAAQ+nB,KAAR,EAAete,UAAf,CAAvB,EAAmD;AACjD,UAAMu1B,4BAA4B,CAACv1B,UAAD,EAAazJ,KAAb,EAAqB,gCAA+B+nB,KAAM,oBAA1D,CAAlC;AACD;;AACD,SAAO/nB,KAAP;AACD;;AACD,SAAS+lC,2BAAT,CAAqCJ,SAArC,EAAgD5d,KAAhD,EAAuDtL,SAAvD,EAAkE;AAChE,QAAM4sB,UAAU,GAAGD,oBAAoB,CAACzD,SAAD,EAAY5d,KAAZ,EAAmBtL,SAAnB,CAAvC;;AACA,MAAI,CAAC4sB,UAAL,EAAiB;AACf,WAAOvF,YAAP;AACD;;AACD,SAAOuF,UAAU,CAACC,MAAX,CAAkB,CAACC,OAAD,EAAUvpC,KAAV,KAAoB;AAC3C,UAAM,CAACwpC,MAAD,EAASp/B,QAAT,IAAqBpK,KAAK,CAACmnC,KAAN,CAAY,GAAZ,EAAiB,CAAjB,EAAoBjlC,GAApB,CAAyB8mB,GAAD,IAASA,GAAG,CAACqe,IAAJ,EAAjC,CAA3B;AACAkC,IAAAA,OAAO,CAACC,MAAD,CAAP,GAAkBp/B,QAAQ,IAAIo/B,MAA9B;AACA,WAAOD,OAAP;AACD,GAJM,EAIJ,EAJI,CAAP;AAKD;;AACD,SAAStD,oBAAT,CAA8BrN,MAA9B,EAAsCnc,SAAtC,EAAiDgtB,gBAAjD,EAAmE;AACjE,SAAO7Q,MAAM,CAAC0Q,MAAP,CAAc,CAACC,OAAD,EAAUxhB,KAAV,KAAoB;AACvC,UAAM2hB,SAAS,GAAG3hB,KAAK,CAAC1a,MAAN,CAAavL,IAA/B;AACAimB,IAAAA,KAAK,CAACnP,UAAN,CAAiBxW,OAAjB,CAA0B6Y,SAAD,IAAe;AACtC,UAAIA,SAAS,CAACpY,IAAV,IAAkB,IAAlB,IAA0BoY,SAAS,CAACpY,IAAV,CAAeC,MAAf,KAA0B,CAAxD,EAA2D;AACzDymC,QAAAA,OAAO,CAACG,SAAD,CAAP,GAAqBA,SAArB;AACD,OAFD,MAEO,IAAIzuB,SAAS,CAACpY,IAAV,CAAeC,MAAf,KAA0B,CAA9B,EAAiC;AACtC,cAAMsH,QAAQ,GAAGqS,SAAS,CAAC7a,QAAV,CAAmBqZ,SAAS,CAACpY,IAAV,CAAe,CAAf,CAAnB,CAAjB;;AACA,YAAI,OAAOuH,QAAP,KAAoB,QAAxB,EAAkC;AAChC,gBAAM40B,4BAA4B,CAACzhC,SAAS,CAAC0b,YAAV,CAAuBgC,SAAvB,CAAD,EAAoC7Q,QAApC,EAA+C,IAAG6Q,SAAS,CAACnZ,IAAK,8CAAjE,CAAlC;AACD;;AACDynC,QAAAA,OAAO,CAACG,SAAD,CAAP,GAAqBD,gBAAgB,CAACr/B,QAAD,EAAWs/B,SAAX,CAArC;AACD,OANM,MAMA;AACL,cAAM,IAAI31B,oBAAJ,CAAyBlB,SAAS,CAACmG,qBAAnC,EAA0Dzb,SAAS,CAAC0b,YAAV,CAAuBgC,SAAvB,CAA1D,EAA8F,IAAGA,SAAS,CAACnZ,IAAK,uCAAsCmZ,SAAS,CAACpY,IAAV,CAAeC,MAAO,cAA5K,CAAN;AACD;AACF,KAZD;AAaA,WAAOymC,OAAP;AACD,GAhBM,EAgBJ,EAhBI,CAAP;AAiBD;;AACD,SAASrD,YAAT,CAAsByD,UAAtB,EAAkCC,YAAlC,EAAgD;AAC9C,SAAO,CAACD,UAAD,EAAaC,YAAb,CAAP;AACD;;AACD,SAASvD,aAAT,CAAuBsD,UAAvB,EAAmCC,YAAnC,EAAiD;AAC/C,SAAOD,UAAP;AACD;;AACD,SAASpD,iBAAT,CAA2B3N,MAA3B,EAAmC9gB,SAAnC,EAA8C2E,SAA9C,EAAyD;AACvD,SAAOmc,MAAM,CAAC12B,GAAP,CAAW,CAAC;AAAEmL,IAAAA,MAAF;AAAUuL,IAAAA;AAAV,GAAD,KAA4B;AAC5C,UAAMqC,SAAS,GAAGrC,UAAU,CAAC,CAAD,CAA5B;AACA,UAAMvZ,IAAI,GAAGgO,MAAM,CAAChO,IAAP,IAAe9B,SAAS,CAAC0b,YAAV,CAAuBgC,SAAvB,CAA5B;;AACA,QAAI5N,MAAM,CAACuL,UAAP,CAAkB3G,IAAlB,CAAwBsD,CAAD,IAAOA,CAAC,CAACzT,IAAF,KAAW,OAAzC,CAAJ,EAAuD;AACrD,YAAM,IAAIiS,oBAAJ,CAAyBlB,SAAS,CAAC6gB,mBAAnC,EAAwDr0B,IAAxD,EAA8D,wDAA9D,CAAN;AACD;;AACD,QAAIuZ,UAAU,CAAC9V,MAAX,KAAsB,CAA1B,EAA6B;AAC3B,YAAM,IAAIiR,oBAAJ,CAAyBlB,SAAS,CAAC6gB,mBAAnC,EAAwDr0B,IAAxD,EAA8D,gEAA9D,CAAN;AACD,KAFD,MAEO,IAAI,CAACwqC,oBAAoB,CAACx8B,MAAD,CAAzB,EAAmC;AACxC,YAAM,IAAI0G,oBAAJ,CAAyBlB,SAAS,CAACyG,oBAAnC,EAAyDja,IAAzD,EAA+D,mDAA/D,CAAN;AACD;;AACD,WAAO0oC,oBAAoB,CAAC1oC,IAAD,EAAO4b,SAAS,CAACnZ,IAAjB,EAAuBmZ,SAAS,CAACpY,IAAV,IAAkB,EAAzC,EAA6CwK,MAAM,CAACvL,IAApD,EAA0DgW,SAA1D,EAAqE2E,SAArE,CAA3B;AACD,GAZM,CAAP;AAaD;;AACD,SAASotB,oBAAT,CAA8Bx8B,MAA9B,EAAsC;AACpC,SAAOA,MAAM,CAAC5F,IAAP,KAAgBnK,eAAe,CAACwsC,MAAhC,IAA0Cz8B,MAAM,CAAC5F,IAAP,KAAgBnK,eAAe,CAACysC,MAA1E,IAAoF18B,MAAM,CAAC5F,IAAP,KAAgBnK,eAAe,CAACmrB,QAA3H;AACD;;AACD,SAASuhB,8BAAT,CAAwCC,QAAxC,EAAkDxtB,SAAlD,EAA6D;AAC3D,QAAMytB,WAAW,GAAGztB,SAAS,CAAC7a,QAAV,CAAmBqoC,QAAnB,CAApB;;AACA,MAAI,EAAEC,WAAW,YAAY/nC,GAAzB,CAAJ,EAAmC;AACjC,UAAM68B,4BAA4B,CAACiL,QAAD,EAAWC,WAAX,EAAyB,2CAAzB,CAAlC;AACD;;AACD,QAAMC,YAAY,GAAG,EAArB;AACAD,EAAAA,WAAW,CAAC9nC,OAAZ,CAAoB,CAACpC,KAAD,EAAQ2D,GAAR,KAAgB;AAClC,QAAI3D,KAAK,YAAYuC,SAArB,EAAgC;AAC9BvC,MAAAA,KAAK,GAAGA,KAAK,CAACyC,QAAd;AACD;;AACD,QAAI,OAAOkB,GAAP,KAAe,QAAnB,EAA6B;AAC3B,YAAMq7B,4BAA4B,CAACiL,QAAD,EAAWtmC,GAAX,EAAiB,sFAAjB,CAAlC;AACD;;AACD,QAAI,OAAO3D,KAAP,IAAgB,QAApB,EAA8B;AAC5BmqC,MAAAA,YAAY,CAACxmC,GAAD,CAAZ,GAAoB3D,KAApB;AACD,KAFD,MAEO,IAAIA,KAAK,YAAYb,YAArB,EAAmC;AACxCgrC,MAAAA,YAAY,CAACxmC,GAAD,CAAZ,GAAoB,IAAIu9B,gBAAJ,CAAqBlhC,KAAK,CAACX,IAA3B,CAApB;AACD,KAFM,MAEA;AACL,YAAM2/B,4BAA4B,CAACiL,QAAD,EAAWjqC,KAAX,EAAmB,wFAAnB,CAAlC;AACD;AACF,GAdD;AAeA,QAAMoqC,QAAQ,GAAGpJ,iBAAiB,CAACmJ,YAAD,CAAlC;AACA,QAAMx2B,MAAM,GAAGstB,kBAAkB,CAACmJ,QAAD,EAAW3rB,gBAAgB,CAACwrB,QAAD,CAA3B,CAAjC;;AACA,MAAIt2B,MAAM,CAAC7Q,MAAP,GAAgB,CAApB,EAAuB;AACrB,UAAM,IAAIiR,oBAAJ,CAAyBlB,SAAS,CAACw3B,wBAAnC,EAA6DJ,QAA7D,EAAuEt2B,MAAM,CAACzR,GAAP,CAAY8X,KAAD,IAAWA,KAAK,CAACswB,GAA5B,EAAiCp/B,IAAjC,CAAsC,IAAtC,CAAvE,CAAN;AACD;;AACD,SAAOk/B,QAAP;AACD;;AACD,SAASnD,mBAAT,CAA6B75B,OAA7B,EAAsCqP,SAAtC,EAAiDopB,UAAjD,EAA6D9R,QAA7D,EAAuE;AACrE,MAAIqW,QAAJ;;AACA,MAAIrW,QAAQ,IAAIA,QAAQ,CAAChyB,GAAT,CAAa,MAAb,CAAhB,EAAsC;AACpCqoC,IAAAA,QAAQ,GAAGJ,8BAA8B,CAACjW,QAAQ,CAAC/xB,GAAT,CAAa,MAAb,CAAD,EAAuBya,SAAvB,CAAzC;AACD,GAFD,MAEO;AACL2tB,IAAAA,QAAQ,GAAGpJ,iBAAiB,CAAC,EAAD,CAA5B;AACD;;AACDvjC,EAAAA,4BAA4B,CAAC2P,OAAD,EAAU,aAAV,EAAyBy4B,UAAzB,CAA5B,CAAiEzjC,OAAjE,CAAyE,CAAC;AAAEiL,IAAAA,MAAF;AAAUuL,IAAAA;AAAV,GAAD,KAA4B;AACnGA,IAAAA,UAAU,CAACxW,OAAX,CAAoB6Y,SAAD,IAAe;AAChC,UAAIsvB,gBAAgB,GAAGl9B,MAAM,CAACvL,IAA9B;;AACA,UAAImZ,SAAS,CAACpY,IAAV,KAAmB,IAAnB,IAA2BoY,SAAS,CAACpY,IAAV,CAAeC,MAAf,GAAwB,CAAvD,EAA0D;AACxD,YAAImY,SAAS,CAACpY,IAAV,CAAeC,MAAf,KAA0B,CAA9B,EAAiC;AAC/B,gBAAM,IAAIiR,oBAAJ,CAAyBlB,SAAS,CAACmG,qBAAnC,EAA0Dzb,SAAS,CAAC0b,YAAV,CAAuBgC,SAAvB,CAA1D,EAA8F,mDAAkDA,SAAS,CAACpY,IAAV,CAAeC,MAAO,cAAtK,CAAN;AACD;;AACD,cAAML,QAAQ,GAAGga,SAAS,CAAC7a,QAAV,CAAmBqZ,SAAS,CAACpY,IAAV,CAAe,CAAf,CAAnB,CAAjB;;AACA,YAAI,OAAOJ,QAAP,KAAoB,QAAxB,EAAkC;AAChC,gBAAMu8B,4BAA4B,CAACzhC,SAAS,CAAC0b,YAAV,CAAuBgC,SAAvB,CAAD,EAAoCxY,QAApC,EAA+C,0CAA/C,CAAlC;AACD;;AACD8nC,QAAAA,gBAAgB,GAAG9nC,QAAnB;AACD;;AACD2nC,MAAAA,QAAQ,CAACjgC,UAAT,CAAoBogC,gBAApB,IAAwCxJ,2BAA2B,CAAC,MAAD,EAAS1zB,MAAM,CAACvL,IAAhB,CAAnE;AACD,KAbD;AAcD,GAfD;AAgBArE,EAAAA,4BAA4B,CAAC2P,OAAD,EAAU,cAAV,EAA0By4B,UAA1B,CAA5B,CAAkEzjC,OAAlE,CAA0E,CAAC;AAAEiL,IAAAA,MAAF;AAAUuL,IAAAA;AAAV,GAAD,KAA4B;AACpGA,IAAAA,UAAU,CAACxW,OAAX,CAAoB6Y,SAAD,IAAe;AAChC,UAAIuvB,SAAS,GAAGn9B,MAAM,CAACvL,IAAvB;AACA,UAAIe,IAAI,GAAG,EAAX;;AACA,UAAIoY,SAAS,CAACpY,IAAV,KAAmB,IAAnB,IAA2BoY,SAAS,CAACpY,IAAV,CAAeC,MAAf,GAAwB,CAAvD,EAA0D;AACxD,YAAImY,SAAS,CAACpY,IAAV,CAAeC,MAAf,GAAwB,CAA5B,EAA+B;AAC7B,gBAAM,IAAIiR,oBAAJ,CAAyBlB,SAAS,CAACmG,qBAAnC,EAA0DiC,SAAS,CAACpY,IAAV,CAAe,CAAf,CAA1D,EAA8E,8CAA9E,CAAN;AACD;;AACD,cAAMJ,QAAQ,GAAGga,SAAS,CAAC7a,QAAV,CAAmBqZ,SAAS,CAACpY,IAAV,CAAe,CAAf,CAAnB,CAAjB;;AACA,YAAI,OAAOJ,QAAP,KAAoB,QAAxB,EAAkC;AAChC,gBAAMu8B,4BAA4B,CAAC/jB,SAAS,CAACpY,IAAV,CAAe,CAAf,CAAD,EAAoBJ,QAApB,EAA+B,sDAA/B,CAAlC;AACD;;AACD+nC,QAAAA,SAAS,GAAG/nC,QAAZ;;AACA,YAAIwY,SAAS,CAACpY,IAAV,CAAeC,MAAf,KAA0B,CAA9B,EAAiC;AAC/B,gBAAM2G,UAAU,GAAGwR,SAAS,CAACpY,IAAV,CAAe,CAAf,CAAnB;AACA,gBAAM4nC,YAAY,GAAGhuB,SAAS,CAAC7a,QAAV,CAAmBqZ,SAAS,CAACpY,IAAV,CAAe,CAAf,CAAnB,CAArB;;AACA,cAAI,CAACslC,kBAAkB,CAACsC,YAAD,EAAe,oBAAf,EAAqChhC,UAArC,CAAvB,EAAyE;AACvE,kBAAMu1B,4BAA4B,CAAC/jB,SAAS,CAACpY,IAAV,CAAe,CAAf,CAAD,EAAoB4nC,YAApB,EAAmC,wDAAnC,CAAlC;AACD;;AACD5nC,UAAAA,IAAI,GAAG4nC,YAAP;AACD;AACF;;AACDL,MAAAA,QAAQ,CAACM,SAAT,CAAmBF,SAAnB,IAAiC,GAAEn9B,MAAM,CAACvL,IAAK,IAAGe,IAAI,CAACqI,IAAL,CAAU,GAAV,CAAe,GAAjE;AACD,KAtBD;AAuBD,GAxBD;AAyBA,SAAOk/B,QAAP;AACD;;AACD,IAAIjB,WAAW,GAAG,IAAIn2B,GAAJ,CAAQ,CACxB,cADwB,EAExB,iBAFwB,EAGxB,WAHwB,EAIxB,cAJwB,CAAR,CAAlB,C,CAOA;;AACA,SAAS+M,oBAAoB,IAAI4qB,qBAAjC,EAAwDzqB,2BAA2B,IAAI0qB,4BAAvF,EAAqHC,kCAArH,EAAyJC,kCAAzJ,EAA6LC,eAA7L,EAA8MC,eAA9M,EAA+NC,sBAA/N,EAAuP7zB,YAAY,IAAI8zB,aAAvQ,EAAsRzqB,aAAa,IAAI0qB,cAAvS,EAAuTC,kBAAvT,EAA2U3J,gBAAgB,IAAI4J,iBAA/V,EAAkXC,gBAAlX,EAAoYC,aAApY,EAAmZ7zB,eAAe,IAAI8zB,gBAAta,QAA8b,mBAA9b;AACA,OAAOC,IAAP,MAAiB,YAAjB;AACA,IAAIC,cAAc,GAAG,cAAcpqB,cAAd,CAA6B;AAChDliB,EAAAA,WAAW,GAAG;AACZ,UAAM,GAAGwP,SAAT;AACA,SAAK+8B,wBAAL,GAAgC,EAAhC;AACD;;AACDhqB,EAAAA,mBAAmB,CAACO,cAAD,EAAiB;AAClC,QAAI,EAAEA,cAAc,YAAYwpB,cAA5B,CAAJ,EAAiD;AAC/C,aAAO,IAAP;AACD;;AACD,WAAO,KAAP;AACD;;AACD3oB,EAAAA,cAAc,CAACb,cAAD,EAAiB;AAC7B,QAAI,EAAEA,cAAc,YAAYwpB,cAA5B,CAAJ,EAAiD;AAC/C,aAAO,IAAP;AACD;;AACD,QAAIxpB,cAAc,CAACypB,wBAAf,CAAwC7oC,MAAxC,KAAmD,KAAK6oC,wBAAL,CAA8B7oC,MAArF,EAA6F;AAC3F,aAAO,IAAP;AACD;;AACD,SAAK,MAAM8oC,SAAX,IAAwB,KAAKD,wBAA7B,EAAuD;AACrD,YAAME,SAAS,GAAG3pB,cAAc,CAACypB,wBAAf,CAAwCx9B,IAAxC,CAA8C29B,UAAD,IAAgB;AAC7E,eAAOvoB,aAAa,CAACuoB,UAAU,CAAC5e,SAAZ,EAAuB0e,SAAS,CAAC1e,SAAjC,CAApB;AACD,OAFiB,CAAlB;;AAGA,UAAI2e,SAAS,KAAK,KAAK,CAAvB,EAA0B;AACxB,eAAO,IAAP;AACD;;AACD,UAAI,CAACnoB,YAAY,CAACkoB,SAAS,CAACG,cAAX,EAA2BF,SAAS,CAACE,cAArC,EAAqDvoB,gBAArD,CAAjB,EAAyF;AACvF,eAAO,IAAP;AACD;;AACD,UAAI,CAACE,YAAY,CAACkoB,SAAS,CAACI,SAAX,EAAsBH,SAAS,CAACG,SAAhC,EAA2CxoB,gBAA3C,CAAjB,EAA+E;AAC7E,eAAO,IAAP;AACD;AACF;;AACD,WAAO,KAAP;AACD;;AACD5B,EAAAA,sBAAsB,CAACM,cAAD,EAAiB;AACrC,QAAI,EAAEA,cAAc,YAAYwpB,cAA5B,CAAJ,EAAiD;AAC/C,aAAO,IAAP;AACD;;AACD,WAAO,KAAP;AACD;;AACDO,EAAAA,0BAA0B,CAAC/e,SAAD,EAAY6e,cAAZ,EAA4BC,SAA5B,EAAuC;AAC/D,SAAKL,wBAAL,CAA8BzoC,IAA9B,CAAmC;AAAEgqB,MAAAA,SAAF;AAAa6e,MAAAA,cAAb;AAA6BC,MAAAA;AAA7B,KAAnC;AACD;;AA1C+C,CAAlD;AA4CA,IAAIE,wBAAwB,GAAG,MAAM;AACnC9sC,EAAAA,WAAW,CAAC0Y,SAAD,EAAY2E,SAAZ,EAAuBgoB,UAAvB,EAAmCD,YAAnC,EAAiD/E,aAAjD,EAAgE0M,kBAAhE,EAAoFp0B,MAApF,EAA4F8C,UAA5F,EAAwGuxB,cAAxG,EAAwHvQ,0BAAxH,EAAoJ6I,kBAApJ,EAAwKpU,IAAxK,EAA8K;AACvL,SAAKxY,SAAL,GAAiBA,SAAjB;AACA,SAAK2E,SAAL,GAAiBA,SAAjB;AACA,SAAKgoB,UAAL,GAAkBA,UAAlB;AACA,SAAKD,YAAL,GAAoBA,YAApB;AACA,SAAK/E,aAAL,GAAqBA,aAArB;AACA,SAAK0M,kBAAL,GAA0BA,kBAA1B;AACA,SAAKp0B,MAAL,GAAcA,MAAd;AACA,SAAK8C,UAAL,GAAkBA,UAAlB;AACA,SAAKuxB,cAAL,GAAsBA,cAAtB;AACA,SAAKvQ,0BAAL,GAAkCA,0BAAlC;AACA,SAAK6I,kBAAL,GAA0BA,kBAA1B;AACA,SAAKpU,IAAL,GAAYA,IAAZ;AACA,SAAKgD,UAAL,GAAkBvF,iBAAiB,CAACwF,OAApC;AACA,SAAKzxB,IAAL,GAAYoqC,wBAAwB,CAACpqC,IAArC;AACD;;AACDsxB,EAAAA,MAAM,CAAC/zB,IAAD,EAAOuZ,UAAP,EAAmB;AACvB,QAAI,CAACA,UAAL,EAAiB;AACf,aAAO,KAAK,CAAZ;AACD;;AACD,UAAMqC,SAAS,GAAGK,oBAAoB,CAAC1C,UAAD,EAAa,UAAb,EAAyB,KAAKb,MAA9B,CAAtC;;AACA,QAAIkD,SAAS,KAAK,KAAK,CAAvB,EAA0B;AACxB,aAAO;AACL2a,QAAAA,OAAO,EAAE3a,SAAS,CAAC5b,IADd;AAEL4b,QAAAA,SAFK;AAGL8Y,QAAAA,QAAQ,EAAE9Y;AAHL,OAAP;AAKD,KAND,MAMO;AACL,aAAO,KAAK,CAAZ;AACD;AACF;;AACDgW,EAAAA,OAAO,CAAC5xB,IAAD,EAAO4b,SAAP,EAAkB;AACvB,SAAKqV,IAAL,CAAUiB,UAAV,CAAqBxyB,SAAS,CAACstC,eAA/B;AACA,UAAMvqC,IAAI,GAAGzC,IAAI,CAACyC,IAAL,CAAUgG,IAAvB;;AACA,QAAImT,SAAS,CAACpY,IAAV,KAAmB,IAAnB,IAA2BoY,SAAS,CAACpY,IAAV,CAAeC,MAAf,GAAwB,CAAvD,EAA0D;AACxD,YAAM,IAAIiR,oBAAJ,CAAyBlB,SAAS,CAACmG,qBAAnC,EAA0Dzb,SAAS,CAAC0b,YAAV,CAAuBgC,SAAvB,CAA1D,EAA8F,sDAA9F,CAAN;AACD;;AACD,UAAM9d,IAAI,GAAG8d,SAAS,CAACpY,IAAV,CAAeC,MAAf,KAA0B,CAA1B,GAA8B0Y,gBAAgB,CAACP,SAAS,CAACpY,IAAV,CAAe,CAAf,CAAD,CAA9C,GAAoE4oC,IAAI,CAACrI,mBAAL,CAAyB,EAAzB,CAAjF;;AACA,QAAI,CAACqI,IAAI,CAACrjC,yBAAL,CAA+BjL,IAA/B,CAAL,EAA2C;AACzC,YAAM,IAAI4W,oBAAJ,CAAyBlB,SAAS,CAACI,yBAAnC,EAA8D9V,IAA9D,EAAoE,8CAApE,CAAN;AACD;;AACD,UAAMsgB,QAAQ,GAAG7f,oBAAoB,CAACT,IAAD,CAArC;;AACA,QAAIsgB,QAAQ,CAAC1b,GAAT,CAAa,KAAb,CAAJ,EAAyB;AACvB,aAAO,EAAP;AACD;;AACD,UAAMuqC,eAAe,GAAGrwB,gBAAgB,CAAC,CACtCrc,GAAD,IAAS,KAAK2sC,uCAAL,CAA6C3sC,GAAG,CAACP,IAAjD,CAD8B,EAEvC2c,kBAFuC,CAAD,CAAxC;AAIA,UAAM2T,WAAW,GAAG,EAApB;AACA,QAAI6c,eAAe,GAAG,EAAtB;AACA,QAAIlvB,eAAe,GAAG,IAAtB;;AACA,QAAIG,QAAQ,CAAC1b,GAAT,CAAa,cAAb,CAAJ,EAAkC;AAChCub,MAAAA,eAAe,GAAGG,QAAQ,CAACzb,GAAT,CAAa,cAAb,CAAlB;AACA,YAAMyqC,eAAe,GAAG,KAAKhwB,SAAL,CAAe7a,QAAf,CAAwB0b,eAAxB,EAAyCtB,kBAAzC,CAAxB;AACAwwB,MAAAA,eAAe,GAAG,KAAKE,eAAL,CAAqBpvB,eAArB,EAAsCmvB,eAAtC,EAAuD3qC,IAAvD,EAA6D,cAA7D,CAAlB;;AACA,WAAK,MAAMlC,GAAX,IAAkB4sC,eAAlB,EAAmC;AACjC,YAAI5sC,GAAG,CAACP,IAAJ,CAAShB,aAAT,GAAyB8f,iBAA7B,EAAgD;AAC9C,gBAAMwuB,SAAS,GAAG/sC,GAAG,CAAC4d,uBAAJ,CAA4BF,eAA5B,CAAlB;AACAqS,UAAAA,WAAW,CAACzsB,IAAZ,CAAiBkR,cAAc,CAACvB,SAAS,CAAC+5B,4BAAX,EAAyCD,SAAzC,EAAqD,mBAAkB/sC,GAAG,CAACP,IAAJ,CAASyC,IAAT,CAAcgG,IAAK,iEAA1F,EAA4J,CAAC+M,sBAAsB,CAACjV,GAAG,CAACP,IAAJ,CAASyC,IAAV,EAAiB,IAAGlC,GAAG,CAACP,IAAJ,CAASyC,IAAT,CAAcgG,IAAK,qBAAvC,CAAvB,CAA5J,CAA/B;AACD;AACF;AACF;;AACD,QAAI6nB,WAAW,CAAC7sB,MAAZ,GAAqB,CAAzB,EAA4B;AAC1B,aAAO;AAAE6sB,QAAAA;AAAF,OAAP;AACD;;AACD,QAAIkd,UAAU,GAAG,EAAjB;;AACA,QAAIpvB,QAAQ,CAAC1b,GAAT,CAAa,SAAb,CAAJ,EAA6B;AAC3B,YAAM+qC,UAAU,GAAGrvB,QAAQ,CAACzb,GAAT,CAAa,SAAb,CAAnB;AACA,YAAM+qC,WAAW,GAAG,KAAKtwB,SAAL,CAAe7a,QAAf,CAAwBkrC,UAAxB,EAAoCR,eAApC,CAApB;AACAO,MAAAA,UAAU,GAAG,KAAKH,eAAL,CAAqBI,UAArB,EAAiCC,WAAjC,EAA8CjrC,IAA9C,EAAoD,SAApD,CAAb;AACD;;AACD,QAAIkrC,UAAU,GAAG,EAAjB;;AACA,QAAIvvB,QAAQ,CAAC1b,GAAT,CAAa,SAAb,CAAJ,EAA6B;AAC3B,YAAMkrC,UAAU,GAAGxvB,QAAQ,CAACzb,GAAT,CAAa,SAAb,CAAnB;AACA,YAAMkrC,WAAW,GAAG,KAAKzwB,SAAL,CAAe7a,QAAf,CAAwBqrC,UAAxB,EAAoCX,eAApC,CAApB;AACAU,MAAAA,UAAU,GAAG,KAAKN,eAAL,CAAqBO,UAArB,EAAiCC,WAAjC,EAA8CprC,IAA9C,EAAoD,SAApD,CAAb;AACA,WAAKqqC,kBAAL,CAAwB9tB,GAAxB,CAA4Bhf,IAA5B,EAAkC,GAAG2tC,UAArC;AACD;;AACD,QAAIG,aAAa,GAAG,EAApB;;AACA,QAAI1vB,QAAQ,CAAC1b,GAAT,CAAa,WAAb,CAAJ,EAA+B;AAC7B,YAAM2M,IAAI,GAAG+O,QAAQ,CAACzb,GAAT,CAAa,WAAb,CAAb;AACA,YAAMorC,aAAa,GAAG,KAAK3wB,SAAL,CAAe7a,QAAf,CAAwB8M,IAAxB,EAA8BsN,kBAA9B,CAAtB;AACAmxB,MAAAA,aAAa,GAAG,KAAKT,eAAL,CAAqBh+B,IAArB,EAA2B0+B,aAA3B,EAA0CtrC,IAA1C,EAAgD,WAAhD,CAAhB;AACD;;AACD,UAAM6nB,OAAO,GAAG,EAAhB;;AACA,QAAIlM,QAAQ,CAAC1b,GAAT,CAAa,SAAb,CAAJ,EAA6B;AAC3B,YAAMsrC,OAAO,GAAG5vB,QAAQ,CAACzb,GAAT,CAAa,SAAb,CAAhB;AACA,YAAMgB,MAAM,GAAG,KAAKyZ,SAAL,CAAe7a,QAAf,CAAwByrC,OAAxB,CAAf;;AACA,UAAI,CAAClqC,KAAK,CAACC,OAAN,CAAcJ,MAAd,CAAL,EAA4B;AAC1B,cAAMg8B,4BAA4B,CAACqO,OAAD,EAAUrqC,MAAV,EAAmB,mCAAnB,CAAlC;AACD;;AACD,WAAK,MAAMsqC,SAAX,IAAwBtqC,MAAxB,EAAgC;AAC9B,YAAI,EAAEsqC,SAAS,YAAYrvC,SAAvB,CAAJ,EAAuC;AACrC,gBAAM+gC,4BAA4B,CAACqO,OAAD,EAAUrqC,MAAV,EAAkB,8CAAlB,CAAlC;AACD;;AACD,cAAMuqC,GAAG,GAAGD,SAAS,CAACE,aAAV,CAAwBF,SAAS,CAACjuC,IAAV,CAAehB,aAAf,EAAxB,CAAZ;;AACA,YAAIkvC,GAAG,KAAK,IAAR,IAAgBD,SAAS,CAACjyB,kBAAV,KAAiC,eAArD,EAAsE;AACpE,gBAAM2jB,4BAA4B,CAACqO,OAAD,EAAUrqC,MAAV,EAAkB,8CAAlB,CAAlC;AACD;;AACD,gBAAQuqC,GAAG,CAACzlC,IAAZ;AACE,eAAK,wBAAL;AACE6hB,YAAAA,OAAO,CAACzmB,IAAR,CAAa+nC,sBAAb;AACA;;AACF,eAAK,kBAAL;AACEthB,YAAAA,OAAO,CAACzmB,IAAR,CAAaooC,gBAAb;AACA;;AACF;AACE,kBAAMtM,4BAA4B,CAACqO,OAAD,EAAUC,SAAV,EAAsB,IAAGA,SAAS,CAAC73B,SAAU,kCAA7C,CAAlC;AARJ;AAUD;AACF;;AACD,UAAMwsB,EAAE,GAAGxkB,QAAQ,CAAC1b,GAAT,CAAa,IAAb,IAAqB,IAAIypC,gBAAJ,CAAqB/tB,QAAQ,CAACzb,GAAT,CAAa,IAAb,CAArB,CAArB,GAAgE,IAA3E;AACA,UAAM2Y,YAAY,GAAGtb,IAAI,CAAChB,aAAL,EAArB;AACA,QAAIuc,WAAW,GAAGD,YAAlB;AACA,UAAMP,QAAQ,GAAG,KAAKtC,SAAL,CAAe0G,iBAAf,CAAiCnf,IAAjC,CAAjB;;AACA,QAAI+a,QAAQ,KAAK,IAAjB,EAAuB;AACrBQ,MAAAA,WAAW,GAAGR,QAAQ,CAAC/b,aAAT,EAAd;AACD;;AACD,UAAMovC,SAAS,GAAGN,aAAa,CAACjrC,GAAd,CAAmBwrC,UAAD,IAAgB,KAAKC,cAAL,CAAoBD,UAApB,EAAgC/yB,YAAhC,EAA8CC,WAA9C,CAAlC,CAAlB;AACA,UAAMnN,YAAY,GAAG++B,eAAe,CAACtqC,GAAhB,CAAqBG,IAAD,IAAU,KAAKsrC,cAAL,CAAoBtrC,IAApB,EAA0BsY,YAA1B,EAAwCC,WAAxC,CAA9B,CAArB;AACA,UAAM8O,OAAO,GAAGmjB,UAAU,CAAC3qC,GAAX,CAAgB6Z,GAAD,IAAS,KAAK4xB,cAAL,CAAoB5xB,GAApB,EAAyBpB,YAAzB,EAAuCC,WAAvC,CAAxB,CAAhB;AACA,UAAMjZ,OAAO,GAAGqrC,UAAU,CAAC9qC,GAAX,CAAgB0rC,GAAD,IAAS,KAAKD,cAAL,CAAoBC,GAApB,EAAyBjzB,YAAzB,EAAuCC,WAAvC,CAAxB,CAAhB;;AACA,UAAMizB,kBAAkB,GAAIjuC,GAAD,IAASwc,4BAA4B,CAACxc,GAAG,CAACI,KAAL,EAAYX,IAAI,CAACyC,IAAjB,EAAuB6Y,YAAvB,CAAhE;;AACA,UAAMmzB,oBAAoB,GAAGL,SAAS,CAACx7B,IAAV,CAAe47B,kBAAf,KAAsCpgC,YAAY,CAACwE,IAAb,CAAkB47B,kBAAlB,CAAtC,IAA+EnkB,OAAO,CAACzX,IAAR,CAAa47B,kBAAb,CAA/E,IAAmHlsC,OAAO,CAACsQ,IAAR,CAAa47B,kBAAb,CAAhJ;AACA,UAAM5gC,IAAI,GAAGqR,iBAAiB,CAAC,KAAKxG,SAAN,EAAiBzY,IAAjB,CAA9B;AACA,UAAMwgB,YAAY,GAAG,IAAI2rB,gBAAJ,CAAqB,KAAK1zB,SAAL,CAAe4vB,sBAAf,CAAsCroC,IAAtC,CAArB,CAArB;AACA,UAAM0uC,YAAY,GAAG,IAAIvC,gBAAJ,CAAqB,KAAK1zB,SAAL,CAAeoqB,sBAAf,CAAsC7iC,IAAtC,CAArB,CAArB;AACA,UAAM2uC,gBAAgB,GAAG;AACvB/gC,MAAAA,IADuB;AAEvB4S,MAAAA,YAFuB;AAGvBkuB,MAAAA,YAHuB;AAIvBN,MAAAA,SAJuB;AAKvBhgC,MAAAA,YALuB;AAMvB9L,MAAAA,OANuB;AAOvB+nB,MAAAA,OAPuB;AAQvBokB,MAAAA,oBARuB;AASvB7L,MAAAA,EATuB;AAUvBgM,MAAAA,UAAU,EAAE,KAVW;AAWvBtkB,MAAAA,OAAO,EAAE;AAXc,KAAzB;AAaA,UAAM/L,YAAY,GAAGH,QAAQ,CAAC1b,GAAT,CAAa,WAAb,IAA4B0b,QAAQ,CAACzb,GAAT,CAAa,WAAb,CAA5B,GAAwD,IAA7E;AACA,UAAMksC,gBAAgB,GAAGtwB,YAAY,KAAK,IAAjB,GAAwB,IAAI4tB,gBAAJ,CAAqB,KAAK3P,0BAAL,GAAkC5e,+BAA+B,CAACW,YAAD,CAAjE,GAAkFA,YAAvG,CAAxB,GAA+I,IAAxK;AACA,UAAMuwB,eAAe,GAAG,EAAxB;;AACA,QAAI1wB,QAAQ,CAAC1b,GAAT,CAAa,SAAb,CAAJ,EAA6B;AAC3BosC,MAAAA,eAAe,CAACjrC,IAAhB,CAAqB,IAAIsoC,gBAAJ,CAAqB/tB,QAAQ,CAACzb,GAAT,CAAa,SAAb,CAArB,CAArB;AACD;;AACD,UAAMosC,gBAAgB,GAAG;AACvBtsC,MAAAA,IADuB;AAEvBmL,MAAAA,IAFuB;AAGvB4S,MAAAA,YAHuB;AAIvBhC,MAAAA,SAAS,EAAEqwB,gBAJY;AAKvBxkB,MAAAA,OAAO,EAAEykB;AALc,KAAzB;AAOA,UAAME,eAAe,GAAG;AACtBvsC,MAAAA,IADsB;AAEtBmL,MAAAA,IAFsB;AAGtB4S,MAAAA,YAHsB;AAItBC,MAAAA,iBAAiB,EAAE,CAJG;AAKtB9H,MAAAA,IAAI,EAAE8B,+BAA+B,CAACza,IAAD,EAAO,KAAKyY,SAAZ,EAAuB,KAAKC,MAA5B,CALf;AAMtBvU,MAAAA,MAAM,EAAE2nC,cAAc,CAACmD;AAND,KAAxB;AAQA,WAAO;AACLhf,MAAAA,QAAQ,EAAE;AACR2S,QAAAA,EADQ;AAERtY,QAAAA,OAFQ;AAGRzX,QAAAA,GAAG,EAAE87B,gBAHG;AAIRO,QAAAA,GAAG,EAAEH,gBAJG;AAKR5uB,QAAAA,GAAG,EAAE6uB,eALG;AAMR5gC,QAAAA,YAAY,EAAE++B,eANN;AAORlvB,QAAAA,eAPQ;AAQRoM,QAAAA,OAAO,EAAEmjB,UARD;AASRlrC,QAAAA,OAAO,EAAEqrC,UATD;AAURnvB,QAAAA,SAAS,EAAED,YAVH;AAWRsnB,QAAAA,yBAAyB,EAAEtnB,YAAY,GAAGD,gCAAgC,CAACC,YAAD,EAAe,KAAK9F,SAApB,EAA+B,KAAK2E,SAApC,CAAnC,GAAoF,IAXnH;AAYR0oB,QAAAA,aAAa,EAAErD,oBAAoB,CAACziC,IAAD,EAAO,KAAKyY,SAAZ,EAAuB,KAAKC,MAA5B,EAAoC,KAAK8jB,0BAAzC,CAZ3B;AAaR2S,QAAAA,iBAAiB,EAAEnvC,IAAI,CAACyC,IAAL,CAAUgG;AAbrB;AADL,KAAP;AAiBD;;AACD2C,EAAAA,MAAM,CAACpL,IAAD,EAAO;AACX,WAAO,IAAIqsC,cAAJ,CAAmBrsC,IAAnB,CAAP;AACD;;AACDyzB,EAAAA,QAAQ,CAACzzB,IAAD,EAAOiwB,QAAP,EAAiB;AACvB,SAAKkV,YAAL,CAAkBzY,wBAAlB,CAA2C;AACzCnsB,MAAAA,GAAG,EAAE,IAAI3B,SAAJ,CAAcoB,IAAd,CADoC;AAEzCsqB,MAAAA,OAAO,EAAE2F,QAAQ,CAAC3F,OAFuB;AAGzClc,MAAAA,YAAY,EAAE6hB,QAAQ,CAAC7hB,YAHkB;AAIzCic,MAAAA,OAAO,EAAE4F,QAAQ,CAAC5F,OAJuB;AAKzC/nB,MAAAA,OAAO,EAAE2tB,QAAQ,CAAC3tB,OALuB;AAMzC2b,MAAAA,eAAe,EAAEgS,QAAQ,CAAChS;AANe,KAA3C;;AAQA,QAAI,KAAK8uB,cAAL,KAAwB,IAA5B,EAAkC;AAChC,WAAKA,cAAL,CAAoBqC,KAApB,CAA0BpvC,IAAI,CAAChB,aAAL,EAA1B,EAAgD;AAC9CyD,QAAAA,IAAI,EAAEwtB,QAAQ,CAACkf,iBAD+B;AAE9CE,QAAAA,KAAK,EAAEpf,QAAQ,CAAC2S,EAAT,KAAgB;AAFuB,OAAhD;AAID;;AACD,SAAKyC,kBAAL,CAAwBpY,kBAAxB,CAA2CjtB,IAA3C;AACD;;AACD60B,EAAAA,OAAO,CAAC70B,IAAD,EAAOiwB,QAAP,EAAiB;AACtB,UAAM/iB,KAAK,GAAG,KAAKkzB,aAAL,CAAmBkP,gBAAnB,CAAoCtvC,IAApC,CAAd;AACA,UAAMswB,WAAW,GAAG,EAApB;AACA,UAAMif,gBAAgB,GAAG,KAAKnP,aAAL,CAAmBoP,sBAAnB,CAA0CxvC,IAA1C,CAAzB;;AACA,QAAIuvC,gBAAgB,KAAK,IAAzB,EAA+B;AAC7Bjf,MAAAA,WAAW,CAACzsB,IAAZ,CAAiB,GAAG0rC,gBAApB;AACD;;AACD,QAAItf,QAAQ,CAAC4V,yBAAT,KAAuC,IAA3C,EAAiD;AAC/C,YAAMG,mBAAmB,GAAGjG,sBAAsB,CAAC9P,QAAQ,CAAC4V,yBAAV,EAAqC5V,QAAQ,CAACzR,SAA9C,EAAyD,KAAK6mB,kBAA9D,CAAlD;AACA/U,MAAAA,WAAW,CAACzsB,IAAZ,CAAiB,GAAGmiC,mBAApB;AACD;;AACD,UAAMhoB,IAAI,GAAG;AACX8wB,MAAAA,eAAe,EAAE;AADN,KAAb;;AAGA,QAAI5hC,KAAK,KAAK,IAAV,IAAkB,CAACA,KAAK,CAACyuB,WAAN,CAAkB5Q,UAAzC,EAAqD;AACnD,YAAM7iB,OAAO,GAAGlJ,aAAa,CAACgB,IAAD,CAA7B;;AACA,WAAK,MAAMyvC,SAAX,IAAwBxf,QAAQ,CAAC3tB,OAAjC,EAA0C;AACxC,YAAIotC,UAAU,CAACD,SAAS,CAACzvC,IAAX,EAAiBkN,KAAK,CAACyuB,WAAvB,CAAd,EAAmD;AACjD3d,UAAAA,IAAI,CAAC8wB,eAAL,CAAqBjrC,IAArB,CAA0B,KAAK2X,UAAL,CAAgBC,IAAhB,CAAqBg0B,SAArB,EAAgCvnC,OAAhC,EAAyCkC,UAAnE;AACD;AACF;;AACD,WAAK,MAAMpH,IAAX,IAAmBitB,QAAQ,CAAC7hB,YAA5B,EAA0C;AACxC,cAAMsmB,QAAQ,GAAG,KAAK0Q,UAAL,CAAgB7b,oBAAhB,CAAqCvmB,IAArC,CAAjB;;AACA,YAAI0xB,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,CAAC/J,QAAT,KAAsB,IAA/C,EAAqD;AACnD,gBAAM,IAAIjW,oBAAJ,CAAyBlB,SAAS,CAACm0B,0BAAnC,EAA+D3kC,IAAI,CAAChD,IAApE,EAA2E,aAAYgD,IAAI,CAAChD,IAAL,CAAUyC,IAAV,CAAegG,IAAK,kCAA3G,CAAN;AACD;AACF;AACF;;AACD,QAAI6nB,WAAW,CAAC7sB,MAAZ,GAAqB,CAAzB,EAA4B;AAC1B,aAAO;AAAE6sB,QAAAA;AAAF,OAAP;AACD;;AACD,QAAIpjB,KAAK,KAAK,IAAV,IAAkBA,KAAK,CAACyuB,WAAN,CAAkB5Q,UAApC,IAAkD7d,KAAK,CAACyiC,QAAN,CAAe5kB,UAAjE,IAA+E7d,KAAK,CAAC6nB,SAAN,KAAoB,IAAvG,EAA6G;AAC3G,aAAO;AAAE/W,QAAAA;AAAF,OAAP;AACD,KAFD,MAEO;AACL,aAAO;AACLA,QAAAA,IADK;AAEL+W,QAAAA,SAAS,EAAE7nB,KAAK,CAAC6nB;AAFZ,OAAP;AAID;AACF;;AACDkB,EAAAA,WAAW,CAACj2B,IAAD,EAAO;AAAEkvC,IAAAA,GAAF;AAAOr8B,IAAAA,GAAP;AAAYsN,IAAAA,GAAZ;AAAiB2lB,IAAAA,aAAjB;AAAgC13B,IAAAA;AAAhC,GAAP,EAAuD;AAAE0gC,IAAAA;AAAF,GAAvD,EAA4E;AACrF,UAAMc,SAAS,GAAG3N,wBAAwB,CAAC9hB,GAAD,CAA1C;AACA,UAAM0vB,aAAa,GAAGnE,eAAe,CAAC,KAAKoE,oBAAL,CAA0BZ,GAA1B,EAA+BJ,eAA/B,CAAD,CAArC;AACA,UAAM/kB,WAAW,GAAG4hB,eAAe,CAAC94B,GAAD,CAAnC;AACA,UAAM0J,UAAU,GAAGwN,WAAW,CAACxN,UAA/B;AACA,UAAMmY,QAAQ,GAAGoR,aAAa,KAAK,IAAlB,GAAyBwF,qBAAqB,CAACxF,aAAD,CAA9C,GAAgE,IAAjF;AACA,SAAKiK,uBAAL,CAA6BxzB,UAA7B,EAAyCmY,QAAzC;AACA,SAAKsb,6BAAL,CAAmCzzB,UAAnC,EAA+Cvc,IAA/C,EAAqDoO,YAArD;AACA,WAAO,KAAKu9B,eAAL,CAAqBiE,SAArB,EAAgCC,aAAhC,EAA+C9lB,WAA/C,CAAP;AACD;;AACDiM,EAAAA,cAAc,CAACh2B,IAAD,EAAO;AAAEkvC,IAAAA,GAAF;AAAO/uB,IAAAA,GAAP;AAAYtN,IAAAA,GAAZ;AAAiBizB,IAAAA;AAAjB,GAAP,EAAyC;AAAEgJ,IAAAA;AAAF,GAAzC,EAA8D;AAC1E,UAAMc,SAAS,GAAG1N,qBAAqB,CAAC/hB,GAAD,CAAvC;AACA,UAAM8vB,WAAW,GAAGzE,kCAAkC,CAAC,KAAKsE,oBAAL,CAA0BZ,GAA1B,EAA+BJ,eAA/B,CAAD,CAAtD;AACA,UAAM/kB,WAAW,GAAG0hB,kCAAkC,CAAC54B,GAAD,CAAtD;AACA,UAAM6hB,QAAQ,GAAGoR,aAAa,KAAK,IAAlB,GAAyByF,4BAA4B,CAACzF,aAAD,CAArD,GAAuE,IAAxF;AACA,SAAKiK,uBAAL,CAA6BhmB,WAAW,CAACxN,UAAzC,EAAqDmY,QAArD;AACA,WAAO,KAAKiX,eAAL,CAAqBiE,SAArB,EAAgCK,WAAhC,EAA6ClmB,WAA7C,CAAP;AACD;;AACD+lB,EAAAA,oBAAoB,CAACZ,GAAD,EAAMJ,eAAN,EAAuB;AACzC,WAAOlvC,aAAa,CAACC,cAAc,CAAC,EAAD,EAAKqvC,GAAL,CAAf,EAA0B;AAAE7kB,MAAAA,OAAO,EAAE,CAAC,GAAG6kB,GAAG,CAAC7kB,OAAR,EAAiB,GAAGykB,eAApB;AAAX,KAA1B,CAApB;AACD;;AACDiB,EAAAA,uBAAuB,CAACG,kBAAD,EAAqBxb,QAArB,EAA+B;AACpD,QAAIA,QAAQ,KAAK,IAAjB,EAAuB;AACrBwb,MAAAA,kBAAkB,CAAC1+B,OAAnB,CAA2BkjB,QAAQ,CAACyR,MAAT,EAA3B;AACD;AACF;;AACD6J,EAAAA,6BAA6B,CAACE,kBAAD,EAAqBlwC,IAArB,EAA2BoO,YAA3B,EAAyC;AACpE,UAAMlG,OAAO,GAAGlJ,aAAa,CAACgB,IAAD,CAA7B;;AACA,SAAK,MAAMgD,IAAX,IAAmBoL,YAAnB,EAAiC;AAC/B,YAAM+hC,WAAW,GAAG,KAAK/P,aAAL,CAAmBgQ,cAAnB,CAAkCptC,IAAI,CAAChD,IAAvC,CAApB;;AACA,UAAImwC,WAAW,KAAK,IAApB,EAA0B;AACxB,cAAM7jB,UAAU,GAAG6jB,WAAW,CAAC7jB,UAAZ,CAAuBzpB,GAAvB,CAA4ByjC,SAAD,IAAe,KAAK9qB,UAAL,CAAgBC,IAAhB,CAAqB6qB,SAArB,EAAgCp+B,OAAhC,EAAyCkC,UAAnF,CAAnB;AACA,cAAMoiB,KAAK,GAAG2jB,WAAW,CAAC3jB,KAAZ,CAAkB3pB,GAAlB,CAAuBwtC,IAAD,IAAU,KAAK70B,UAAL,CAAgBC,IAAhB,CAAqB40B,IAArB,EAA2BnoC,OAA3B,EAAoCkC,UAApE,CAAd;AACA,cAAMkmC,cAAc,GAAG,IAAItE,iBAAJ,CAAsB1f,UAAtB,CAAvB;AACA,cAAMikB,UAAU,GAAG,IAAIvE,iBAAJ,CAAsBxf,KAAtB,CAAnB;AACA,cAAMgkB,QAAQ,GAAG,KAAKh1B,UAAL,CAAgBC,IAAhB,CAAqBzY,IAArB,EAA2BkF,OAA3B,EAAoCkC,UAArD;AACA,cAAMqmC,iBAAiB,GAAG,IAAI5E,aAAJ,CAAkBK,aAAa,CAACuE,iBAAhC,CAA1B;AACA,cAAMC,QAAQ,GAAG,IAAI3E,kBAAJ,CAAuB0E,iBAAvB,EAA0C,CAACD,QAAD,EAAWF,cAAX,EAA2BC,UAA3B,CAA1C,CAAjB;AACAL,QAAAA,kBAAkB,CAACrsC,IAAnB,CAAwB6sC,QAAQ,CAACvK,MAAT,EAAxB;AACD;AACF;AACF;;AACDwF,EAAAA,eAAe,CAACiE,SAAD,EAAYK,WAAZ,EAAyBlmB,WAAzB,EAAsC;AACnD,UAAMna,GAAG,GAAG,CACVggC,SADU,EAEV;AACEntC,MAAAA,IAAI,EAAE,WADR;AAEEyI,MAAAA,WAAW,EAAE6e,WAAW,CAAC3f,UAF3B;AAGEmS,MAAAA,UAAU,EAAEwN,WAAW,CAACxN,UAH1B;AAIE3O,MAAAA,IAAI,EAAEmc,WAAW,CAACnc;AAJpB,KAFU,EAQV;AACEnL,MAAAA,IAAI,EAAE,WADR;AAEEyI,MAAAA,WAAW,EAAE+kC,WAAW,CAAC7lC,UAF3B;AAGEmS,MAAAA,UAAU,EAAE0zB,WAAW,CAAC1zB,UAH1B;AAIE3O,MAAAA,IAAI,EAAEqiC,WAAW,CAACriC;AAJpB,KARU,CAAZ;AAeA,WAAOgC,GAAP;AACD;;AACD0+B,EAAAA,cAAc,CAACp0B,QAAD,EAAWoB,YAAX,EAAyBC,WAAzB,EAAsC;AAClD,QAAIrB,QAAQ,CAACy2B,oBAAb,EAAmC;AACjC,aAAOv1B,aAAa,CAAClB,QAAD,EAAWA,QAAX,EAAqBoB,YAArB,EAAmCA,YAAnC,EAAiD,KAAKE,UAAtD,CAApB;AACD,KAFD,MAEO;AACL,UAAIH,OAAO,GAAGnB,QAAd;AACA,UAAIa,QAAQ,GAAG,KAAKtC,SAAL,CAAe0G,iBAAf,CAAiC9D,OAAO,CAACrb,IAAzC,CAAf;;AACA,UAAI+a,QAAQ,KAAK,IAAb,IAAqBzc,uBAAuB,CAACyc,QAAD,CAAhD,EAA4D;AAC1DM,QAAAA,OAAO,GAAG,IAAIzc,SAAJ,CAAcmc,QAAd,CAAV;AACD;;AACD,aAAOK,aAAa,CAAClB,QAAD,EAAWmB,OAAX,EAAoBC,YAApB,EAAkCC,WAAlC,EAA+C,KAAKC,UAApD,CAApB;AACD;AACF;;AACD0xB,EAAAA,uCAAuC,CAACltC,IAAD,EAAO;AAC5C,UAAM4N,IAAI,GAAG5N,IAAI,CAAC4N,IAAL,IAAa,IAA1B;AACA,WAAOA,IAAI,KAAK,KAAKgjC,2BAAL,CAAiChjC,IAAjC,EAAuC5N,IAAvC,KAAgD,KAAK6wC,6BAAL,CAAmCjjC,IAAnC,CAArD,CAAX;AACD;;AACDgjC,EAAAA,2BAA2B,CAAChjC,IAAD,EAAO5N,IAAP,EAAa;AACtC,QAAI,CAACosC,IAAI,CAACpiB,mBAAL,CAAyBpc,IAAzB,CAAL,EAAqC;AACnC,aAAO,IAAP;AACD;;AACD,UAAMkjC,QAAQ,GAAGljC,IAAI,KAAKw+B,IAAI,CAACnjC,YAAL,CAAkB2E,IAAI,CAACkjC,QAAvB,KAAoCljC,IAAI,CAACkjC,QAAzC,IAAqD1E,IAAI,CAAC2E,eAAL,CAAqBnjC,IAAI,CAACkjC,QAA1B,KAAuCljC,IAAI,CAACkjC,QAAL,CAAc3/B,KAA/G,CAAJ,IAA6H,IAA9I;;AACA,QAAI2/B,QAAQ,KAAK,IAAjB,EAAuB;AACrB,aAAO,IAAP;AACD;;AACD,UAAMlO,EAAE,GAAG,KAAKnqB,SAAL,CAAexM,qBAAf,CAAqC6kC,QAArC,CAAX;;AACA,QAAIlO,EAAE,KAAK,IAAP,IAAeA,EAAE,CAACngC,IAAH,KAAY,qBAA/B,EAAsD;AACpD,aAAO,IAAP;AACD;;AACD,QAAI,CAAC,KAAKiW,MAAN,IAAgBkqB,EAAE,CAACj+B,IAAH,KAAY,eAAhC,EAAiD;AAC/C,aAAO,IAAP;AACD;;AACD,QAAIiJ,IAAI,CAACqc,aAAL,KAAuB,KAAK,CAA5B,IAAiCrc,IAAI,CAACqc,aAAL,CAAmBxmB,MAAnB,KAA8B,CAAnE,EAAsE;AACpE,YAAMgO,MAAM,GAAG26B,IAAI,CAACh6B,mBAAL,CAAyBpS,IAAzB,KAAkCosC,IAAI,CAACtnB,kBAAL,CAAwB9kB,IAAI,CAACyR,MAA7B,CAAlC,GAAyEzR,IAAI,CAACyR,MAA9E,GAAuF,IAAtG;AACA,YAAMsK,UAAU,GAAG,CAACtK,MAAM,IAAIA,MAAM,CAAChP,IAAjB,GAAwBgP,MAAM,CAAChP,IAAP,CAAYuuC,OAAZ,KAAwB,GAAhD,GAAsD,EAAvD,KAA8DhxC,IAAI,CAACyC,IAAL,GAAYzC,IAAI,CAACyC,IAAL,CAAUuuC,OAAV,EAAZ,GAAkC,WAAhG,CAAnB;AACA,YAAM,IAAIt8B,oBAAJ,CAAyBlB,SAAS,CAACy9B,8CAAnC,EAAmFrjC,IAAnF,EAA0F,GAAEmO,UAAW,uOAAvG,CAAN;AACD;;AACD,UAAMnY,GAAG,GAAGgK,IAAI,CAACqc,aAAL,CAAmB,CAAnB,CAAZ;AACA,WAAOxrB,mBAAmB,CAACmF,GAAD,CAA1B;AACD;;AACDitC,EAAAA,6BAA6B,CAACjjC,IAAD,EAAO;AAClC,QAAI,CAACw+B,IAAI,CAAC8E,sBAAL,CAA4BtjC,IAA5B,CAAL,EAAwC;AACtC,aAAO,IAAP;AACD;;AACD,SAAK,MAAMujC,CAAX,IAAgBvjC,IAAI,CAAC0d,KAArB,EAA4B;AAC1B,UAAI8gB,IAAI,CAAC5kB,iBAAL,CAAuB2pB,CAAvB,CAAJ,EAA+B;AAC7B,aAAK,MAAMC,CAAX,IAAgBD,CAAC,CAACpjC,OAAlB,EAA2B;AACzB,gBAAMsjC,YAAY,GAAGjF,IAAI,CAAC3kB,mBAAL,CAAyB2pB,CAAzB,KAA+BhF,IAAI,CAACnjC,YAAL,CAAkBmoC,CAAC,CAAC3uC,IAApB,CAA/B,IAA4D2uC,CAAC,CAAC3uC,IAAF,CAAOgG,IAAP,KAAgB,UAA5E,IAA0F2oC,CAAC,CAACxjC,IAA5F,IAAoG,IAAzH;AACA,gBAAM0jC,kBAAkB,GAAGD,YAAY,IAAI5yC,mBAAmB,CAAC4yC,YAAD,CAA9D;;AACA,cAAIC,kBAAJ,EAAwB;AACtB,mBAAOA,kBAAP;AACD;AACF;AACF;AACF;;AACD,WAAO,IAAP;AACD;;AACDC,EAAAA,2BAA2B,CAAChxC,GAAD,EAAM;AAC/B,WAAO,KAAKkY,SAAL,CAAenO,OAAf,CAAuB/J,GAAG,CAACP,IAA3B,CAAP;AACD;;AACDqtC,EAAAA,eAAe,CAACh+B,IAAD,EAAOmiC,YAAP,EAAqBC,SAArB,EAAgCC,SAAhC,EAA2C;AACxD,UAAMC,OAAO,GAAG,EAAhB;;AACA,QAAI,CAAC7tC,KAAK,CAACC,OAAN,CAAcytC,YAAd,CAAL,EAAkC;AAChC,YAAM7R,4BAA4B,CAACtwB,IAAD,EAAOmiC,YAAP,EAAsB,4CAA2CE,SAAU,OAAMD,SAAU,EAA3F,CAAlC;AACD;;AACDD,IAAAA,YAAY,CAACzuC,OAAb,CAAqB,CAAC6uC,KAAD,EAAQ74B,GAAR,KAAgB;AACnC,UAAI64B,KAAK,YAAY9uC,GAAjB,IAAwB8uC,KAAK,CAAClvC,GAAN,CAAU,UAAV,CAA5B,EAAmD;AACjDkvC,QAAAA,KAAK,GAAGA,KAAK,CAACjvC,GAAN,CAAU,UAAV,CAAR;AACD;;AACD,UAAImB,KAAK,CAACC,OAAN,CAAc6tC,KAAd,CAAJ,EAA0B;AACxBD,QAAAA,OAAO,CAAC9tC,IAAR,CAAa,GAAG,KAAKwpC,eAAL,CAAqBh+B,IAArB,EAA2BuiC,KAA3B,EAAkCH,SAAlC,EAA6CC,SAA7C,CAAhB;AACD,OAFD,MAEO,IAAIE,KAAK,YAAYhzC,SAArB,EAAgC;AACrC,YAAI,CAAC,KAAK2yC,2BAAL,CAAiCK,KAAjC,CAAL,EAA8C;AAC5C,gBAAMjS,4BAA4B,CAACiS,KAAK,CAAC5xC,IAAP,EAAa4xC,KAAb,EAAqB,qBAAoB74B,GAAI,oBAAmB24B,SAAU,OAAMD,SAAU,iBAA1F,CAAlC;AACD;;AACDE,QAAAA,OAAO,CAAC9tC,IAAR,CAAa+tC,KAAb;AACD,OALM,MAKA;AACL,cAAMjS,4BAA4B,CAACtwB,IAAD,EAAOuiC,KAAP,EAAe,qBAAoB74B,GAAI,oBAAmB24B,SAAU,OAAMD,SAAU,qBAApF,CAAlC;AACD;AACF,KAdD;AAeA,WAAOE,OAAP;AACD;;AA7XkC,CAArC;;AA+XA,SAASjC,UAAT,CAAoB1vC,IAApB,EAA0B27B,WAA1B,EAAuC;AACrC,SAAO,CAACA,WAAW,CAACrP,UAAZ,CAAuB1Z,IAAvB,CAA6B0zB,SAAD,IAAeA,SAAS,CAAC/lC,GAAV,CAAcP,IAAd,KAAuBA,IAAlE,CAAD,IAA4E,CAAC27B,WAAW,CAACnP,KAAZ,CAAkB5Z,IAAlB,CAAwBy9B,IAAD,IAAUA,IAAI,CAAC9vC,GAAL,CAASP,IAAT,KAAkBA,IAAnD,CAApF;AACD,C,CAED;;;AACA,IAAI6xC,SAAS,GAAG,IAAI/uC,GAAJ,EAAhB;AACA,IAAIgvC,WAAW,GAAG,EAAlB;AACA,IAAIC,eAAe,GAAG,cAAcnN,eAAd,CAA8B;AAClD7kC,EAAAA,WAAW,GAAG;AACZ,UAAM,GAAGwP,SAAT;AACA,SAAKm9B,cAAL,GAAsB,EAAtB;AACA,SAAKC,SAAL,GAAiB,EAAjB;AACA,SAAKqF,gBAAL,GAAwB,KAAxB;AACD;;AACDtuB,EAAAA,cAAc,CAACb,cAAD,EAAiBovB,iBAAjB,EAAoC;AAChD,QAAI,EAAEpvB,cAAc,YAAYkvB,eAA5B,CAAJ,EAAkD;AAChD,aAAO,IAAP;AACD;;AACD,UAAMG,kBAAkB,GAAG,CAAC9sB,OAAD,EAAUC,QAAV,KAAuBlB,gBAAgB,CAACiB,OAAD,EAAUC,QAAV,CAAhB,IAAuC,CAAC4sB,iBAAiB,CAACvvC,GAAlB,CAAsB0iB,OAAO,CAACha,MAA9B,CAA1F;;AACA,WAAO,KAAK4mC,gBAAL,KAA0BnvB,cAAc,CAACmvB,gBAAzC,IAA6D,CAAC3tB,YAAY,CAAC,KAAKqoB,cAAN,EAAsB7pB,cAAc,CAAC6pB,cAArC,EAAqDwF,kBAArD,CAA1E,IAAsJ,CAAC7tB,YAAY,CAAC,KAAKsoB,SAAN,EAAiB9pB,cAAc,CAAC8pB,SAAhC,EAA2CuF,kBAA3C,CAA1K;AACD;;AACDvuB,EAAAA,wBAAwB,CAACd,cAAD,EAAiBsvB,oBAAjB,EAAuC;AAC7D,QAAI,EAAEtvB,cAAc,YAAYkvB,eAA5B,CAAJ,EAAkD;AAChD,aAAO,IAAP;AACD;;AACD,UAAMK,0BAA0B,GAAIhnC,MAAD,IAAY;AAC7C,UAAIinC,aAAa,GAAGjnC,MAApB;;AACA,aAAOinC,aAAa,YAAYzN,eAAhC,EAAiD;AAC/C,YAAIuN,oBAAoB,CAACzvC,GAArB,CAAyB2vC,aAAzB,CAAJ,EAA6C;AAC3C,iBAAO,IAAP;AACD;;AACDA,QAAAA,aAAa,GAAGA,aAAa,CAAC90B,SAA9B;AACD;;AACD,aAAO,KAAP;AACD,KATD;;AAUA,UAAM+0B,qBAAqB,GAAG,CAACltB,OAAD,EAAUC,QAAV,KAAuBlB,gBAAgB,CAACiB,OAAD,EAAUC,QAAV,CAAhB,IAAuC,CAAC+sB,0BAA0B,CAAChtB,OAAO,CAACha,MAAT,CAAvH;;AACA,UAAMmnC,gBAAgB,GAAG,CAACntB,OAAD,EAAUC,QAAV,KAAuBlB,gBAAgB,CAACiB,OAAD,EAAUC,QAAV,CAAhB,IAAuC,CAAC8sB,oBAAoB,CAACzvC,GAArB,CAAyB0iB,OAAO,CAACha,MAAjC,CAAxF;;AACA,WAAO,CAACiZ,YAAY,CAAC,KAAKqoB,cAAN,EAAsB7pB,cAAc,CAAC6pB,cAArC,EAAqD4F,qBAArD,CAAb,IAA4F,CAACjuB,YAAY,CAAC,KAAKsoB,SAAN,EAAiB9pB,cAAc,CAAC8pB,SAAhC,EAA2C4F,gBAA3C,CAAhH;AACD;;AA/BiD,CAApD;AAiCA,IAAIC,yBAAyB,GAAG,MAAM;AACpCzyC,EAAAA,WAAW,CAAC0Y,SAAD,EAAY2E,SAAZ,EAAuB+nB,YAAvB,EAAqCC,UAArC,EAAiDqN,WAAjD,EAA8DrS,aAA9D,EAA6EsS,sBAA7E,EAAqGC,gBAArG,EAAuHj6B,MAAvH,EAA+Hk6B,cAA/H,EAA+IC,QAA/I,EAAyJC,0BAAzJ,EAAqLC,kBAArL,EAAyMC,+BAAzM,EAA0OC,eAA1O,EAA2PC,8BAA3P,EAA2RC,cAA3R,EAA2SC,aAA3S,EAA0TC,qBAA1T,EAAiV73B,UAAjV,EAA6V83B,UAA7V,EAAyWjO,kBAAzW,EAA6X/T,uBAA7X,EAAsZkL,0BAAtZ,EAAkbvL,IAAlb,EAAwb;AACjc,SAAKxY,SAAL,GAAiBA,SAAjB;AACA,SAAK2E,SAAL,GAAiBA,SAAjB;AACA,SAAK+nB,YAAL,GAAoBA,YAApB;AACA,SAAKC,UAAL,GAAkBA,UAAlB;AACA,SAAKqN,WAAL,GAAmBA,WAAnB;AACA,SAAKrS,aAAL,GAAqBA,aAArB;AACA,SAAKsS,sBAAL,GAA8BA,sBAA9B;AACA,SAAKC,gBAAL,GAAwBA,gBAAxB;AACA,SAAKj6B,MAAL,GAAcA,MAAd;AACA,SAAKk6B,cAAL,GAAsBA,cAAtB;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACA,SAAKC,0BAAL,GAAkCA,0BAAlC;AACA,SAAKC,kBAAL,GAA0BA,kBAA1B;AACA,SAAKC,+BAAL,GAAuCA,+BAAvC;AACA,SAAKC,eAAL,GAAuBA,eAAvB;AACA,SAAKC,8BAAL,GAAsCA,8BAAtC;AACA,SAAKC,cAAL,GAAsBA,cAAtB;AACA,SAAKC,aAAL,GAAqBA,aAArB;AACA,SAAKC,qBAAL,GAA6BA,qBAA7B;AACA,SAAK73B,UAAL,GAAkBA,UAAlB;AACA,SAAK83B,UAAL,GAAkBA,UAAlB;AACA,SAAKjO,kBAAL,GAA0BA,kBAA1B;AACA,SAAK/T,uBAAL,GAA+BA,uBAA/B;AACA,SAAKkL,0BAAL,GAAkCA,0BAAlC;AACA,SAAKvL,IAAL,GAAYA,IAAZ;AACA,SAAKsiB,YAAL,GAAoB,IAAIzwC,GAAJ,EAApB;AACA,SAAK0wC,qBAAL,GAA6B,IAAItyB,wBAAJ,EAA7B;AACA,SAAKuyB,uBAAL,GAA+B,IAAI3wC,GAAJ,EAA/B;AACA,SAAK4wC,qBAAL,GAA6B,IAAI5wC,GAAJ,EAA7B;AACA,SAAKmxB,UAAL,GAAkBvF,iBAAiB,CAACwF,OAApC;AACA,SAAKzxB,IAAL,GAAY+vC,yBAAyB,CAAC/vC,IAAtC;AACD;;AACDsxB,EAAAA,MAAM,CAAC/zB,IAAD,EAAOuZ,UAAP,EAAmB;AACvB,QAAI,CAACA,UAAL,EAAiB;AACf,aAAO,KAAK,CAAZ;AACD;;AACD,UAAMqC,SAAS,GAAGK,oBAAoB,CAAC1C,UAAD,EAAa,WAAb,EAA0B,KAAKb,MAA/B,CAAtC;;AACA,QAAIkD,SAAS,KAAK,KAAK,CAAvB,EAA0B;AACxB,aAAO;AACL2a,QAAAA,OAAO,EAAE3a,SAAS,CAAC5b,IADd;AAEL4b,QAAAA,SAFK;AAGL8Y,QAAAA,QAAQ,EAAE9Y;AAHL,OAAP;AAKD,KAND,MAMO;AACL,aAAO,KAAK,CAAZ;AACD;AACF;;AACDkW,EAAAA,UAAU,CAAC9xB,IAAD,EAAO4b,SAAP,EAAkB;AAC1B,QAAI,CAAC,KAAKg3B,cAAL,CAAoBe,UAAzB,EAAqC;AACnC,aAAO,KAAK,CAAZ;AACD;;AACD,UAAM71C,IAAI,GAAG,KAAK81C,eAAL,CAAqBh4B,SAArB,CAAb;;AACA,UAAMiS,SAAS,GAAGtvB,oBAAoB,CAACT,IAAD,CAAtC;AACA,UAAM+1C,cAAc,GAAG7zC,IAAI,CAAChB,aAAL,GAAqBkU,QAA5C;;AACA,UAAM4gC,eAAe,GAAIvlB,QAAD,IAAc;AACpC,UAAI;AACF,cAAMwlB,WAAW,GAAG,KAAKnB,cAAL,CAAoB/d,OAApB,CAA4BtG,QAA5B,EAAsCslB,cAAtC,CAApB;AACA,eAAO,KAAKjB,cAAL,CAAoBoB,OAApB,CAA4BD,WAA5B,EAAyC;AAAEnmC,UAAAA,IAAI,EAAE,OAAR;AAAiBimC,UAAAA;AAAjB,SAAzC,CAAP;AACD,OAHD,CAGE,MAAM;AACN,eAAO,KAAK,CAAZ;AACD;AACF,KAPD;;AAQA,UAAMI,iCAAiC,GAAG,KAAKC,wBAAL,CAA8Bl0C,IAA9B,EAAoC4b,SAApC,EAA+CiS,SAA/C,EAA0DgmB,cAA1D,EAA0EjhB,IAA1E,CAAgFlF,QAAD,IAAc;AACrI,UAAIA,QAAQ,KAAK,IAAjB,EAAuB;AACrB,eAAO,KAAK,CAAZ;AACD;;AACD,aAAOgF,OAAO,CAACC,GAAR,CAAYjF,QAAQ,CAACymB,SAAT,CAAmBtxC,GAAnB,CAAwB0rB,QAAD,IAAculB,eAAe,CAACvlB,QAAD,CAApD,CAAZ,EAA6EqE,IAA7E,CAAkF,MAAM,KAAK,CAA7F,CAAP;AACD,KALyC,CAA1C;;AAMA,UAAMwhB,kBAAkB,GAAG,KAAKC,0BAAL,CAAgCxmB,SAAhC,CAA3B;;AACA,QAAIymB,YAAJ;;AACA,QAAIzmB,SAAS,CAACnrB,GAAV,CAAc,QAAd,CAAJ,EAA6B;AAC3B,YAAM6xC,SAAS,GAAGxK,oBAAoB,CAAClc,SAAD,EAAY,QAAZ,EAAsB,KAAKzQ,SAA3B,CAAtC;;AACA,UAAIm3B,SAAS,KAAK,IAAlB,EAAwB;AACtB,aAAKb,qBAAL,CAA2BzwC,GAA3B,CAA+BjD,IAA/B,EAAqC,IAArC;AACD,OAFD,MAEO;AACLs0C,QAAAA,YAAY,GAAG5hB,OAAO,CAACC,GAAR,CAAY4hB,SAAS,CAAC1xC,GAAV,CAAekrB,KAAD,IAAW,KAAK6kB,cAAL,CAAoB4B,gBAApB,CAAqCzmB,KAArC,EAA4C;AAAEngB,UAAAA,IAAI,EAAE,OAAR;AAAiBimC,UAAAA;AAAjB,SAA5C,CAAzB,CAAZ,EAAsHjhB,IAAtH,CAA4H5E,MAAD,IAAY;AACpJ,eAAK0lB,qBAAL,CAA2BzwC,GAA3B,CAA+BjD,IAA/B,EAAqCguB,MAArC;AACD,SAFc,CAAf;AAGD;AACF,KATD,MASO;AACL,WAAK0lB,qBAAL,CAA2BzwC,GAA3B,CAA+BjD,IAA/B,EAAqC,IAArC;AACD;;AACD,WAAO0yB,OAAO,CAACC,GAAR,CAAY,CACjBshB,iCADiB,EAEjBK,YAFiB,EAGjB,GAAGF,kBAAkB,CAACvxC,GAAnB,CAAwB0rB,QAAD,IAAculB,eAAe,CAACvlB,QAAQ,CAACxwB,GAAV,CAApD,CAHc,CAAZ,EAIJ60B,IAJI,CAIC,MAAM,KAAK,CAJZ,CAAP;AAKD;;AACDhB,EAAAA,OAAO,CAAC5xB,IAAD,EAAO4b,SAAP,EAAkB4P,KAAK,GAAGoD,YAAY,CAAC6W,IAAvC,EAA6C;AAClD,QAAI1vB,EAAJ,EAAQC,EAAR;;AACA,SAAKib,IAAL,CAAUiB,UAAV,CAAqBxyB,SAAS,CAAC+0C,gBAA/B;AACA,UAAMZ,cAAc,GAAG7zC,IAAI,CAAChB,aAAL,GAAqBkU,QAA5C;AACA,SAAKqgC,YAAL,CAAkBlY,MAAlB,CAAyBzf,SAAzB;AACA,QAAI0U,WAAJ;AACA,QAAIvF,UAAU,GAAG,KAAjB;AACA,UAAM4a,eAAe,GAAGC,wBAAwB,CAAC5lC,IAAD,EAAO4b,SAAP,EAAkB,KAAKnD,SAAvB,EAAkC,KAAK2E,SAAvC,EAAkD,KAAK1E,MAAvD,EAA+D8S,KAA/D,EAAsE,KAAKgR,0BAA3E,EAAuG,KAAKgX,qBAAL,CAA2BkB,8BAA3B,EAAvG,CAAhD;;AACA,QAAI/O,eAAe,KAAK,KAAK,CAA7B,EAAgC;AAC9B,aAAO,EAAP;AACD;;AACD,UAAM;AAAE/pB,MAAAA,SAAS,EAAEiS,SAAb;AAAwB6G,MAAAA,QAAxB;AAAkC7M,MAAAA,MAAlC;AAA0C4C,MAAAA;AAA1C,QAAsDkb,eAA5D;AACA,UAAMgP,aAAa,GAAG,CAAC5+B,EAAE,GAAG,KAAK6+B,iBAAL,CAAuB/mB,SAAvB,EAAkC,eAAlC,EAAmD,mBAAnD,CAAN,KAAkF,IAAlF,GAAyF9X,EAAzF,GAA8F8L,iBAAiB,CAACgzB,QAAtI;;AACA,UAAMC,eAAe,GAAG,KAAKF,iBAAL,CAAuB/mB,SAAvB,EAAkC,iBAAlC,EAAqD,yBAArD,CAAxB;;AACA,QAAIknB,UAAU,GAAG,IAAjB;;AACA,QAAIlnB,SAAS,CAACnrB,GAAV,CAAc,YAAd,CAAJ,EAAiC;AAC/BqyC,MAAAA,UAAU,GAAG,IAAIjzB,gBAAJ,CAAqB+L,SAAS,CAAClrB,GAAV,CAAc,YAAd,CAArB,CAAb;AACD;;AACD,UAAMqyC,uBAAuB,GAAG,KAAKnC,QAAL,CAAc5I,MAAd,CAAqB,CAAC5kB,QAAD,EAAW4vB,OAAX,KAAuB;AAC1E,YAAMC,SAAS,GAAGz1C,QAAQ,CAACF,YAAY,CAAC01C,OAAD,CAAb,EAAwB11C,YAAY,CAACs0C,cAAD,CAApC,CAA1B;;AACA,UAAIxuB,QAAQ,KAAK,KAAK,CAAlB,IAAuB6vB,SAAS,CAACzxC,MAAV,GAAmB4hB,QAAQ,CAAC5hB,MAAvD,EAA+D;AAC7D,eAAOyxC,SAAP;AACD,OAFD,MAEO;AACL,eAAO7vB,QAAP;AACD;AACF,KAP+B,EAO7B,KAAK,CAPwB,CAAhC;AAQA,QAAI8vB,6BAA6B,GAAG,IAApC;AACA,QAAItP,yBAAyB,GAAG,IAAhC;AACA,QAAIuP,oBAAoB,GAAG,IAA3B;;AACA,QAAIvnB,SAAS,CAACnrB,GAAV,CAAc,eAAd,CAAJ,EAAoC;AAClC,YAAM2yC,aAAa,GAAGxnB,SAAS,CAAClrB,GAAV,CAAc,eAAd,CAAtB;AACAwyC,MAAAA,6BAA6B,GAAG72B,gCAAgC,CAAC+2B,aAAD,EAAgB,KAAK58B,SAArB,EAAgC,KAAK2E,SAArC,CAAhE;AACAg4B,MAAAA,oBAAoB,GAAG,IAAItzB,gBAAJ,CAAqB,KAAK0a,0BAAL,GAAkC5e,+BAA+B,CAACy3B,aAAD,CAAjE,GAAmFA,aAAxG,CAAvB;AACD;;AACD,QAAIxnB,SAAS,CAACnrB,GAAV,CAAc,WAAd,CAAJ,EAAgC;AAC9BmjC,MAAAA,yBAAyB,GAAGvnB,gCAAgC,CAACuP,SAAS,CAAClrB,GAAV,CAAc,WAAd,CAAD,EAA6B,KAAK8V,SAAlC,EAA6C,KAAK2E,SAAlD,CAA5D;AACD;;AACD,QAAIsQ,QAAJ;;AACA,QAAI,KAAK+lB,uBAAL,CAA6B/wC,GAA7B,CAAiC1C,IAAjC,CAAJ,EAA4C;AAC1C,YAAMs1C,WAAW,GAAG,KAAK7B,uBAAL,CAA6B9wC,GAA7B,CAAiC3C,IAAjC,CAApB;AACA,WAAKyzC,uBAAL,CAA6BpY,MAA7B,CAAoCr7B,IAApC;AACA0tB,MAAAA,QAAQ,GAAG4nB,WAAX;AACD,KAJD,MAIO;AACL,YAAMC,YAAY,GAAG,KAAKC,wBAAL,CAA8B55B,SAA9B,EAAyCiS,SAAzC,EAAoDgmB,cAApD,CAArB;AACAnmB,MAAAA,QAAQ,GAAG,KAAK+nB,eAAL,CAAqBz1C,IAArB,EAA2Bu1C,YAA3B,CAAX;AACD;;AACD,UAAMrnB,gBAAgB,GAAGR,QAAQ,CAACR,WAAT,CAAqBwoB,QAArB,GAAgC;AAAEtkC,MAAAA,IAAI,EAAE,IAAR;AAAchH,MAAAA,UAAU,EAAEyjB,SAAS,CAAClrB,GAAV,CAAc,UAAd;AAA1B,KAAhC,GAAwF;AAC/GyO,MAAAA,IAAI,EAAE7R,YAAY,CAACmuB,QAAQ,CAACR,WAAT,CAAqByoB,mBAAtB,CAD6F;AAE/GvrC,MAAAA,UAAU,EAAEsjB,QAAQ,CAACkoB,aAAT,CAAuB51C;AAF4E,KAAjH;AAIA,QAAIguB,MAAM,GAAG,EAAb;;AACA,UAAM6nB,cAAc,GAAG,KAAKC,sBAAL,CAA4BjoB,SAA5B,EAAuCgmB,cAAvC,CAAvB;;AACA,UAAMM,SAAS,GAAG,CAChB,GAAG,KAAKE,0BAAL,CAAgCxmB,SAAhC,CADa,EAEhB,GAAG,KAAKkoB,yBAAL,CAA+BroB,QAA/B,CAFa,CAAlB;;AAIA,SAAK,MAAMa,QAAX,IAAuB4lB,SAAvB,EAAkC;AAChC,UAAI;AACF,cAAMJ,WAAW,GAAG,KAAKnB,cAAL,CAAoB/d,OAApB,CAA4BtG,QAAQ,CAACxwB,GAArC,EAA0C81C,cAA1C,CAApB;AACA,cAAMmC,WAAW,GAAG,KAAKpD,cAAL,CAAoBqD,IAApB,CAAyBlC,WAAzB,CAApB;AACA/lB,QAAAA,MAAM,CAACnqB,IAAP,CAAYmyC,WAAZ;;AACA,YAAI,KAAK1C,UAAL,KAAoB,IAAxB,EAA8B;AAC5B,eAAKA,UAAL,CAAgB4C,qBAAhB,CAAsCl2C,IAAI,CAAChB,aAAL,EAAtC,EAA4DO,YAAY,CAACw0C,WAAD,CAAxE;AACD;AACF,OAPD,CAOE,MAAM;AACN,YAAIzjB,WAAW,KAAK,KAAK,CAAzB,EAA4B;AAC1BA,UAAAA,WAAW,GAAG,EAAd;AACD;;AACD,cAAM6lB,YAAY,GAAG5nB,QAAQ,CAAClqB,MAAT,KAAoB,CAApB,GAAwB,CAAxB,GAA4B,CAAjD;AACAisB,QAAAA,WAAW,CAACzsB,IAAZ,CAAiB,KAAKuyC,yBAAL,CAA+B7nB,QAAQ,CAACxwB,GAAxC,EAA6CwwB,QAAQ,CAAC3U,YAAtD,EAAoEu8B,YAApE,EAAkFrhC,YAAlF,EAAjB;AACD;AACF;;AACD,QAAI6/B,aAAa,KAAK9yB,iBAAiB,CAACw0B,SAApC,IAAiD3hB,QAAQ,CAAC/J,QAAT,KAAsB,IAA3E,EAAiF;AAC/E,YAAM2rB,aAAa,GAAGC,mCAAmC,CAAC7hB,QAAQ,CAAC/J,QAAV,CAAzD;;AACA,UAAI2rB,aAAa,KAAK,IAAtB,EAA4B;AAC1B,YAAIhmB,WAAW,KAAK,KAAK,CAAzB,EAA4B;AAC1BA,UAAAA,WAAW,GAAG,EAAd;AACD;;AACDA,QAAAA,WAAW,CAACzsB,IAAZ,CAAiBkR,cAAc,CAACvB,SAAS,CAACU,qCAAX,EAAkD2Z,SAAS,CAAClrB,GAAV,CAAc,UAAd,CAAlD,EAA6E2zC,aAA7E,CAA/B;AACD;AACF;;AACD,QAAIhC,YAAY,GAAG,IAAnB;;AACA,QAAI,KAAKZ,qBAAL,CAA2BhxC,GAA3B,CAA+B1C,IAA/B,CAAJ,EAA0C;AACxCs0C,MAAAA,YAAY,GAAG,KAAKZ,qBAAL,CAA2B/wC,GAA3B,CAA+B3C,IAA/B,CAAf;AACA,WAAK0zC,qBAAL,CAA2BrY,MAA3B,CAAkCr7B,IAAlC;;AACA,UAAIs0C,YAAY,KAAK,IAArB,EAA2B;AACzBtmB,QAAAA,MAAM,CAACnqB,IAAP,CAAY,GAAGywC,YAAf;AACD;AACF,KAND,MAMO;AACL,UAAI,KAAK1B,cAAL,CAAoB4D,aAAxB,EAAuC;AACrC,cAAM,IAAI/wC,KAAJ,CAAU,8DAAV,CAAN;AACD;;AACD,UAAIooB,SAAS,CAACnrB,GAAV,CAAc,QAAd,CAAJ,EAA6B;AAC3B,cAAM6xC,SAAS,GAAGxK,oBAAoB,CAAClc,SAAD,EAAY,QAAZ,EAAsB,KAAKzQ,SAA3B,CAAtC;;AACA,YAAIm3B,SAAS,KAAK,IAAlB,EAAwB;AACtBD,UAAAA,YAAY,GAAG,CAAC,GAAGC,SAAJ,CAAf;AACAvmB,UAAAA,MAAM,CAACnqB,IAAP,CAAY,GAAG0wC,SAAf;AACD;AACF;AACF;;AACD,QAAI7mB,QAAQ,CAACM,MAAT,CAAgBvqB,MAAhB,GAAyB,CAA7B,EAAgC;AAC9BuqB,MAAAA,MAAM,CAACnqB,IAAP,CAAY,GAAG6pB,QAAQ,CAACM,MAAxB;AACD;;AACD,UAAMyoB,MAAM,GAAG;AACbxmB,MAAAA,QAAQ,EAAE;AACR1S,QAAAA,SAAS,EAAEJ,aAAa,CAACnd,IAAD,EAAO,KAAKyY,SAAZ,EAAuB,KAAK2E,SAA5B,CADhB;AAERyK,QAAAA,MAFQ;AAGR4C,QAAAA,OAHQ;AAIR3sB,QAAAA,IAAI,EAAE8B,aAAa,CAACC,cAAc,CAAC,EAAD,EAAK60B,QAAL,CAAf,EAA+B;AAChDhH,UAAAA,QAAQ,EAAE;AACRgpB,YAAAA,KAAK,EAAEhpB,QAAQ,CAACgpB,KADR;AAERC,YAAAA,kBAAkB,EAAEjpB,QAAQ,CAACipB;AAFrB,WADsC;AAKhDhC,UAAAA,aALgD;AAMhDiC,UAAAA,aAAa,EAAE,CAAC5gC,EAAE,GAAG0X,QAAQ,CAACmpB,mBAAf,KAAuC,IAAvC,GAA8C7gC,EAA9C,GAAmDiL,4BANlB;AAOhD+M,UAAAA,MAPgD;AAQhD+mB,UAAAA,UARgD;AAShDM,UAAAA,aAAa,EAAED,oBATiC;AAUhDrC,UAAAA,kBAAkB,EAAE,KAAKA,kBAVuB;AAWhDiC,UAAAA;AAXgD,SAA/B,CAJX;AAiBRnQ,QAAAA,aAAa,EAAEjd,6BAA6B,CAAC5nB,IAAD,EAAO6nB,MAAP,EAAe,KAAKpP,SAApB,CAjBpC;AAkBRqtB,QAAAA,aAAa,EAAErD,oBAAoB,CAACziC,IAAD,EAAO,KAAKyY,SAAZ,EAAuB,KAAKC,MAA5B,EAAoC,KAAK8jB,0BAAzC,EAAsE/iB,GAAD,IAAS,KAAKq9B,oCAAL,CAA0Cr9B,GAA1C,EAA+CoU,SAA/C,EAA0DG,MAA1D,EAAkEN,QAAlE,CAA9E,CAlB3B;AAmBRA,QAAAA,QAnBQ;AAoBRmY,QAAAA,yBApBQ;AAqBRsP,QAAAA,6BArBQ;AAsBRb,QAAAA,YAtBQ;AAuBRH,QAAAA,SAvBQ;AAwBRvmB,QAAAA,SAAS,EAAE;AACTI,UAAAA,MAAM,EAAE6nB,cADC;AAETnoB,UAAAA,QAAQ,EAAEQ;AAFD,SAxBH;AA4BRnD,QAAAA;AA5BQ,OADG;AA+BbuF,MAAAA;AA/Ba,KAAf;;AAiCA,QAAIwkB,eAAe,KAAK,IAAxB,EAA8B;AAC5B2B,MAAAA,MAAM,CAACxmB,QAAP,CAAgBnyB,IAAhB,CAAqBg3C,eAArB,GAAuCA,eAAvC;AACD;;AACD,WAAO2B,MAAP;AACD;;AACDrrC,EAAAA,MAAM,CAACpL,IAAD,EAAOiwB,QAAP,EAAiB;AACrB,UAAMlL,cAAc,GAAGF,6BAA6B,CAAC7kB,IAAD,CAApD;AACA,WAAO,IAAI+xC,eAAJ,CAAoB/xC,IAApB,EAA0BiwB,QAAQ,CAACnyB,IAAT,CAAc6sB,QAAxC,EAAkDsF,QAAQ,CAACpI,MAA3D,EAAmEoI,QAAQ,CAACxF,OAA5E,EAAqFwF,QAAQ,CAACnyB,IAAT,CAAc8sB,QAAnG,EAA6GqF,QAAQ,CAAC4U,aAAtH,EAAqI9f,cAArI,CAAP;AACD;;AACD0O,EAAAA,QAAQ,CAACzzB,IAAD,EAAOiwB,QAAP,EAAiB;AACvB,UAAM1vB,GAAG,GAAG,IAAI3B,SAAJ,CAAcoB,IAAd,CAAZ;AACA,SAAKmlC,YAAL,CAAkB1Y,yBAAlB,CAA4C7sB,aAAa,CAACC,cAAc,CAAC;AACvE+N,MAAAA,IAAI,EAAE2X,QAAQ,CAACmF,SADwD;AAEvEnqB,MAAAA,GAFuE;AAGvEkC,MAAAA,IAAI,EAAEzC,IAAI,CAACyC,IAAL,CAAUgG,IAHuD;AAIvEkiB,MAAAA,QAAQ,EAAEsF,QAAQ,CAACnyB,IAAT,CAAc6sB,QAJ+C;AAKvEC,MAAAA,QAAQ,EAAEqF,QAAQ,CAACnyB,IAAT,CAAc8sB,QAL+C;AAMvE/C,MAAAA,MAAM,EAAEoI,QAAQ,CAACpI,MANsD;AAOvE4C,MAAAA,OAAO,EAAEwF,QAAQ,CAACxF,OAPqD;AAQvEI,MAAAA,OAAO,EAAEoF,QAAQ,CAACnyB,IAAT,CAAc+sB,OAAd,CAAsBhoB,GAAtB,CAA2BkjC,KAAD,IAAWA,KAAK,CAACp0B,YAA3C,CAR8D;AASvE4Y,MAAAA,WAAW,EAAE,IAT0D;AAUvEhN,MAAAA,SAAS,EAAE0S,QAAQ,CAAC1S;AAVmD,KAAD,EAWrE0S,QAAQ,CAAC4U,aAX4D,CAAf,EAW7B;AAC1B9Z,MAAAA,UAAU,EAAEkF,QAAQ,CAAClF,UADK;AAE1BP,MAAAA,YAAY,EAAE;AAFY,KAX6B,CAAzD;AAeA,SAAKmoB,gBAAL,CAAsBhlB,iBAAtB,CAAwCsC,QAAQ,CAACrC,SAAjD,EAA4D5tB,IAA5D;AACA,SAAKqlC,kBAAL,CAAwBpY,kBAAxB,CAA2CjtB,IAA3C;AACD;;AACDsQ,EAAAA,KAAK,CAACpI,OAAD,EAAUlI,IAAV,EAAgBiwB,QAAhB,EAA0B;AAC7B,QAAIA,QAAQ,CAAClF,UAAT,IAAuB,CAAC,KAAKkoB,eAAjC,EAAkD;AAChD,aAAO,IAAP;AACD;;AACD,UAAM/lC,KAAK,GAAG,KAAKulC,WAAL,CAAiBsE,oBAAjB,CAAsC/2C,IAAtC,CAAd;AACA,UAAM2qB,QAAQ,GAAGsF,QAAQ,CAACnyB,IAAT,CAAc6sB,QAA/B;AACA,UAAMqsB,OAAO,GAAG,IAAIp1B,eAAJ,EAAhB;;AACA,QAAI1U,KAAK,KAAK,IAAd,EAAoB;AAClB,UAAI,CAACA,KAAK,CAACyuB,WAAN,CAAkB5Q,UAAlB,IAAgC7d,KAAK,CAACyiC,QAAN,CAAe5kB,UAAhD,KAA+D,CAAC,KAAKkoB,eAAzE,EAA0F;AACxF,eAAO,IAAP;AACD;;AACD,WAAK,MAAM3M,SAAX,IAAwBp5B,KAAK,CAACyuB,WAAN,CAAkBrP,UAA1C,EAAsD;AACpD,YAAIga,SAAS,CAAC3b,QAAV,KAAuB,IAA3B,EAAiC;AAC/BqsB,UAAAA,OAAO,CAACC,cAAR,CAAuBj2B,WAAW,CAACk2B,KAAZ,CAAkB5Q,SAAS,CAAC3b,QAA5B,CAAvB,EAA8D2b,SAA9D;AACD;AACF;AACF;;AACD,UAAM6Q,MAAM,GAAG,IAAIx1B,cAAJ,CAAmBq1B,OAAnB,CAAf;AACA,UAAMI,aAAa,GAAGD,MAAM,CAACE,IAAP,CAAY;AAAE3pB,MAAAA,QAAQ,EAAEuC,QAAQ,CAACvC,QAAT,CAAkB4pB;AAA9B,KAAZ,CAAtB;AACApvC,IAAAA,OAAO,CAACqvC,YAAR,CAAqB;AACnBrqB,MAAAA,WAAW,EAAEltB,IADM;AAEnB2qB,MAAAA,QAFmB;AAGnBysB,MAAAA,aAHmB;AAInBI,MAAAA,YAAY,EAAE;AACZ9B,QAAAA,QAAQ,EAAEzlB,QAAQ,CAACvC,QAAT,CAAkBR,WAAlB,CAA8BwoB,QAD5B;AAEZtgC,QAAAA,IAAI,EAAE6a,QAAQ,CAACvC,QAAT,CAAkBtY;AAFZ;AAJK,KAArB;AASD;;AACDggB,EAAAA,SAAS,CAACC,GAAD,EAAMr1B,IAAN,EAAYlC,IAAZ,EAAkB;AACzB,QAAI,KAAK40C,sBAAL,KAAgC,IAAhC,IAAwC,CAAC3wB,IAAI,CAAC+C,kBAAL,CAAwB9kB,IAAxB,CAA7C,EAA4E;AAC1E;AACD;;AACD,QAAIlC,IAAI,CAACitB,UAAL,IAAmB,CAAC,KAAKkoB,eAA7B,EAA8C;AAC5C;AACD;;AACD,UAAM/lC,KAAK,GAAG,KAAKwlC,sBAAL,CAA4B+E,iBAA5B,CAA8Cz3C,IAA9C,CAAd;;AACA,QAAIkN,KAAK,CAAC6d,UAAN,IAAoB,CAAC,KAAKkoB,eAA9B,EAA+C;AAC7C;AACD;;AACD,UAAMkE,MAAM,GAAG,IAAIx1B,cAAJ,CAAmBzU,KAAK,CAAC8pC,OAAzB,CAAf;AACA3hB,IAAAA,GAAG,CAACqiB,WAAJ,CAAgB,IAAI94C,SAAJ,CAAcoB,IAAd,CAAhB,EAAqCm3C,MAArC,EAA6Cr5C,IAAI,CAAC4vB,QAAL,CAAc4pB,SAA3D,EAAsEpqC,KAAK,CAACsf,KAA5E,EAAmFtf,KAAK,CAACod,OAAzF,EAAkGxsB,IAAI,CAAC4vB,QAAL,CAAckoB,aAAhH,EAA+H93C,IAAI,CAAC4vB,QAAL,CAActY,IAA7I,EAAmJtX,IAAI,CAAC4vB,QAAL,CAAcpZ,MAAjK;AACD;;AACDghB,EAAAA,qBAAqB,CAACzH,SAAD,EAAY0H,uBAAZ,EAAqC;AACxD,WAAOA,uBAAuB,CAACoiB,0BAAxB,CAAmD9pB,SAAnD,CAAP;AACD;;AACDgH,EAAAA,OAAO,CAAC70B,IAAD,EAAOiwB,QAAP,EAAiB7kB,MAAjB,EAAyB;AAC9B,QAAI,KAAKkmB,uBAAL,KAAiC,IAAjC,IAAyCrB,QAAQ,CAAC1S,SAAT,YAA8B3e,SAA3E,EAAsF;AACpFwM,MAAAA,MAAM,CAACmS,SAAP,GAAmB,KAAK+T,uBAAL,CAA6BzN,SAA7B,CAAuCoM,QAAQ,CAAC1S,SAAT,CAAmBvd,IAA1D,CAAnB;AACD;;AACD,QAAIiwB,QAAQ,CAAClF,UAAT,IAAuB,CAAC,KAAKkoB,eAAjC,EAAkD;AAChD,aAAO,EAAP;AACD;;AACD,UAAM/qC,OAAO,GAAGlI,IAAI,CAAChB,aAAL,EAAhB;AACA,UAAMkO,KAAK,GAAG,KAAKulC,WAAL,CAAiBsE,oBAAjB,CAAsC/2C,IAAtC,CAAd;AACA,QAAI00B,QAAQ,GAAGzE,QAAQ,CAACnyB,IAAxB;AACA,UAAMkgB,IAAI,GAAG;AACXsO,MAAAA,UAAU,EAAEwlB,WADD;AAEXtlB,MAAAA,KAAK,EAAEqlB,SAFI;AAGX+F,MAAAA,uBAAuB,EAAE;AAHd,KAAb;;AAKA,QAAI1qC,KAAK,KAAK,IAAV,KAAmB,CAACA,KAAK,CAACyuB,WAAN,CAAkB5Q,UAAnB,IAAiC,KAAKkoB,eAAzD,CAAJ,EAA+E;AAC7E,YAAM+D,OAAO,GAAG,IAAIp1B,eAAJ,EAAhB;;AACA,WAAK,MAAMiK,GAAX,IAAkB3e,KAAK,CAACyuB,WAAN,CAAkBrP,UAApC,EAAgD;AAC9C,YAAIT,GAAG,CAAClB,QAAJ,KAAiB,IAArB,EAA2B;AACzBqsB,UAAAA,OAAO,CAACC,cAAR,CAAuBj2B,WAAW,CAACk2B,KAAZ,CAAkBrrB,GAAG,CAAClB,QAAtB,CAAvB,EAAwDkB,GAAxD;AACD;AACF;;AACD,YAAMW,KAAK,GAAG,IAAI1pB,GAAJ,EAAd;;AACA,WAAK,MAAMutC,IAAX,IAAmBnjC,KAAK,CAACyuB,WAAN,CAAkBnP,KAArC,EAA4C;AAC1CA,QAAAA,KAAK,CAACvpB,GAAN,CAAUotC,IAAI,CAAC5tC,IAAf,EAAqB4tC,IAAI,CAAC9vC,GAA1B;AACD;;AACD,YAAM42C,MAAM,GAAG,IAAIx1B,cAAJ,CAAmBq1B,OAAnB,CAAf;AACA,YAAMa,KAAK,GAAGV,MAAM,CAACE,IAAP,CAAY;AAAE3pB,QAAAA,QAAQ,EAAEgH,QAAQ,CAAChH,QAAT,CAAkBgpB;AAA9B,OAAZ,CAAd;AACA,YAAMhK,cAAc,GAAGmL,KAAK,CAACC,iBAAN,GAA0Bj1C,GAA1B,CAA+ByjC,SAAD,IAAe;AAClE,cAAM14B,IAAI,GAAG,KAAK4N,UAAL,CAAgBC,IAAhB,CAAqB6qB,SAAS,CAAC/lC,GAA/B,EAAoC2H,OAApC,CAAb;AACA,eAAO;AACL3H,UAAAA,GAAG,EAAE+lC,SAAS,CAAC/lC,GADV;AAELqN,UAAAA,IAAI,EAAEA,IAAI,CAACxD,UAFN;AAGL2tC,UAAAA,YAAY,EAAEnqC,IAAI,CAACmqC,YAHd;AAILptB,UAAAA,QAAQ,EAAE2b,SAAS,CAAC3b,QAJf;AAKL9C,UAAAA,MAAM,EAAEye,SAAS,CAACze,MAAV,CAAiBrB,aALpB;AAMLiE,UAAAA,OAAO,EAAE6b,SAAS,CAAC7b,OAAV,CAAkBjE,aANtB;AAOLoE,UAAAA,QAAQ,EAAE0b,SAAS,CAAC1b,QAPf;AAQLL,UAAAA,WAAW,EAAE+b,SAAS,CAAC/b;AARlB,SAAP;AAUD,OAZsB,CAAvB;AAaA,YAAMoiB,SAAS,GAAG,EAAlB;;AACA,WAAK,MAAMqL,QAAX,IAAuBH,KAAK,CAACI,YAAN,EAAvB,EAA6C;AAC3C,YAAI,CAACzrB,KAAK,CAAC9pB,GAAN,CAAUs1C,QAAV,CAAL,EAA0B;AACxB;AACD;;AACD,cAAM3H,IAAI,GAAG7jB,KAAK,CAAC7pB,GAAN,CAAUq1C,QAAV,CAAb;AACA,cAAMpqC,IAAI,GAAG,KAAK4N,UAAL,CAAgBC,IAAhB,CAAqB40B,IAArB,EAA2BnoC,OAA3B,CAAb;AACAykC,QAAAA,SAAS,CAAC9oC,IAAV,CAAe;AACbtD,UAAAA,GAAG,EAAE8vC,IADQ;AAEb2H,UAAAA,QAFa;AAGb5tC,UAAAA,UAAU,EAAEwD,IAAI,CAACxD,UAHJ;AAIb2tC,UAAAA,YAAY,EAAEnqC,IAAI,CAACmqC;AAJN,SAAf;AAMD;;AACD,UAAI,KAAKzmB,uBAAL,KAAiC,IAArC,EAA2C;AACzClmB,QAAAA,MAAM,CAACshC,cAAP,GAAwBA,cAAc,CAAC7pC,GAAf,CAAoBgpB,GAAD,IAAS,KAAKyF,uBAAL,CAA6B1N,oBAA7B,CAAkDiI,GAAG,CAACtrB,GAAJ,CAAQP,IAA1D,EAAgE6rB,GAAG,CAACje,IAApE,CAA5B,CAAxB;AACAxC,QAAAA,MAAM,CAACuhC,SAAP,GAAmBA,SAAS,CAAC9pC,GAAV,CAAewtC,IAAD,IAAU,KAAK/e,uBAAL,CAA6B1N,oBAA7B,CAAkDysB,IAAI,CAAC9vC,GAAL,CAASP,IAA3D,EAAiEqwC,IAAI,CAACjmC,UAAtE,CAAxB,CAAnB;AACD;;AACD,YAAM8tC,oBAAoB,GAAG,IAAIp1C,GAAJ,EAA7B;;AACA,WAAK,MAAMq1C,aAAX,IAA4BzL,cAA5B,EAA4C;AAC1C,cAAM0L,KAAK,GAAG,KAAKC,qBAAL,CAA2BF,aAAa,CAACJ,YAAzC,EAAuDI,aAAa,CAACvqC,IAArE,EAA2E1F,OAA3E,CAAd;;AACA,YAAIkwC,KAAK,KAAK,IAAd,EAAoB;AAClBF,UAAAA,oBAAoB,CAACj1C,GAArB,CAAyBk1C,aAAzB,EAAwCC,KAAxC;AACD;AACF;;AACD,YAAME,eAAe,GAAG,IAAIx1C,GAAJ,EAAxB;;AACA,WAAK,MAAMy1C,QAAX,IAAuB5L,SAAvB,EAAkC;AAChC,cAAMyL,KAAK,GAAG,KAAKC,qBAAL,CAA2BE,QAAQ,CAACR,YAApC,EAAkDQ,QAAQ,CAACnuC,UAA3D,EAAuElC,OAAvE,CAAd;;AACA,YAAIkwC,KAAK,KAAK,IAAd,EAAoB;AAClBE,UAAAA,eAAe,CAACr1C,GAAhB,CAAoBs1C,QAApB,EAA8BH,KAA9B;AACD;AACF;;AACD,YAAMI,aAAa,GAAGN,oBAAoB,CAACzzB,IAArB,KAA8B,CAA9B,IAAmC6zB,eAAe,CAAC7zB,IAAhB,KAAyB,CAAlF;;AACA,UAAI,CAAC+zB,aAAL,EAAoB;AAClB,aAAK,MAAM;AAAE5qC,UAAAA,IAAF;AAAQmqC,UAAAA;AAAR,SAAX,IAAqCrL,cAArC,EAAqD;AACnD,eAAK+L,sBAAL,CAA4BV,YAA5B,EAA0CnqC,IAA1C,EAAgD1F,OAAhD;AACD;;AACD,aAAK,MAAM;AAAEkC,UAAAA,UAAF;AAAc2tC,UAAAA;AAAd,SAAX,IAA2CpL,SAA3C,EAAsD;AACpD,eAAK8L,sBAAL,CAA4BV,YAA5B,EAA0C3tC,UAA1C,EAAsDlC,OAAtD;AACD;;AACD,cAAMwwC,+BAA+B,GAAGhM,cAAc,CAAC95B,IAAf,CAAqBiZ,GAAD,IAAS9O,4BAA4B,CAAC8O,GAAG,CAACje,IAAL,EAAW5N,IAAI,CAACyC,IAAhB,EAAsByF,OAAtB,CAAzD,KAA4FykC,SAAS,CAAC/5B,IAAV,CAAgBy9B,IAAD,IAAUtzB,4BAA4B,CAACszB,IAAI,CAACjmC,UAAN,EAAkBpK,IAAI,CAACyC,IAAvB,EAA6ByF,OAA7B,CAArD,CAApI;AACA8V,QAAAA,IAAI,CAACsO,UAAL,GAAkBogB,cAAlB;AACA1uB,QAAAA,IAAI,CAACwO,KAAL,GAAa,IAAI1pB,GAAJ,CAAQ6pC,SAAS,CAAC9pC,GAAV,CAAewtC,IAAD,IAAU,CAACA,IAAI,CAAC2H,QAAN,EAAgB3H,IAAI,CAACjmC,UAArB,CAAxB,CAAR,CAAb;AACA4T,QAAAA,IAAI,CAAC45B,uBAAL,GAA+Bc,+BAA+B,GAAG,CAAH,GAAO,CAArE;AACD,OAXD,MAWO;AACL,YAAI,KAAKrF,qBAAL,KAA+B,CAAnC,EAAsC;AACpC,eAAKjT,aAAL,CAAmBuY,uBAAnB,CAA2C34C,IAA3C,EAAiD0sC,cAAc,CAAC7pC,GAAf,CAAoBgpB,GAAD,IAASA,GAAG,CAACtrB,GAAhC,CAAjD,EAAuFosC,SAAS,CAAC9pC,GAAV,CAAewtC,IAAD,IAAUA,IAAI,CAAC9vC,GAA7B,CAAvF;AACA6K,UAAAA,MAAM,CAAC4mC,gBAAP,GAA0B,IAA1B;;AACA,cAAI,KAAK1gB,uBAAL,KAAiC,IAArC,EAA2C;AACzC,kBAAMsnB,YAAY,GAAG,KAAKtnB,uBAAL,CAA6BzN,SAA7B,CAAuC3W,KAAK,CAACkR,QAA7C,CAArB;;AACA,gBAAI,EAAEw6B,YAAY,YAAYvM,cAA1B,CAAJ,EAA+C;AAC7C,oBAAM,IAAI5mC,KAAJ,CAAW,4BAA2ByH,KAAK,CAACkR,QAAN,CAAe3b,IAAK,2BAA1D,CAAN;AACD;;AACDm2C,YAAAA,YAAY,CAAChM,0BAAb,CAAwCxhC,MAAxC,EAAgDA,MAAM,CAACshC,cAAvD,EAAuEthC,MAAM,CAACuhC,SAA9E;AACD;AACF,SAVD,MAUO;AACL,gBAAMkM,eAAe,GAAG,EAAxB;;AACA,eAAK,MAAM,CAAChtB,GAAD,EAAMusB,KAAN,CAAX,IAA2BF,oBAA3B,EAAiD;AAC/CW,YAAAA,eAAe,CAACh1C,IAAhB,CAAqBi1C,oBAAoB,CAACjtB,GAAG,CAACtrB,GAAL,EAAUsrB,GAAG,CAACtB,WAAJ,GAAkB,WAAlB,GAAgC,WAA1C,EAAuD6tB,KAAvD,CAAzC;AACD;;AACD,eAAK,MAAM,CAAC/H,IAAD,EAAO+H,KAAP,CAAX,IAA4BE,eAA5B,EAA6C;AAC3CO,YAAAA,eAAe,CAACh1C,IAAhB,CAAqBi1C,oBAAoB,CAACzI,IAAI,CAAC9vC,GAAN,EAAW,MAAX,EAAmB63C,KAAnB,CAAzC;AACD;;AACD,gBAAM,IAAI1jC,oBAAJ,CAAyBlB,SAAS,CAACK,qBAAnC,EAA0D7T,IAA1D,EAAgE,6IAAhE,EAA+M64C,eAA/M,CAAN;AACD;AACF;AACF;;AACD,UAAMvoB,WAAW,GAAG,EAApB;;AACA,QAAIL,QAAQ,CAAC4V,yBAAT,KAAuC,IAAvC,IAA+C5V,QAAQ,CAACnyB,IAAT,CAAc0gB,SAAd,YAAmCsD,gBAAtF,EAAwG;AACtG,YAAMkkB,mBAAmB,GAAGjG,sBAAsB,CAAC9P,QAAQ,CAAC4V,yBAAV,EAAqC5V,QAAQ,CAACnyB,IAAT,CAAc0gB,SAAd,CAAwBxe,IAA7D,EAAmE,KAAKqlC,kBAAxE,CAAlD;AACA/U,MAAAA,WAAW,CAACzsB,IAAZ,CAAiB,GAAGmiC,mBAApB;AACD;;AACD,QAAI/V,QAAQ,CAACklB,6BAAT,KAA2C,IAA3C,IAAmDllB,QAAQ,CAACnyB,IAAT,CAAcu3C,aAAd,YAAuCvzB,gBAA9F,EAAgH;AAC9G,YAAMi3B,uBAAuB,GAAGhZ,sBAAsB,CAAC9P,QAAQ,CAACklB,6BAAV,EAAyCllB,QAAQ,CAACnyB,IAAT,CAAcu3C,aAAd,CAA4Br1C,IAArE,EAA2E,KAAKqlC,kBAAhF,CAAtD;AACA/U,MAAAA,WAAW,CAACzsB,IAAZ,CAAiB,GAAGk1C,uBAApB;AACD;;AACD,UAAM9S,oBAAoB,GAAG9F,uBAAuB,CAACngC,IAAD,EAAO,KAAKolC,UAAZ,EAAwB,KAAKhoB,SAA7B,EAAwC,KAAK3E,SAA7C,EAAwD,KAAK2nB,aAA7D,EAA4E,WAA5E,CAApD;;AACA,QAAI6F,oBAAoB,KAAK,IAA7B,EAAmC;AACjC3V,MAAAA,WAAW,CAACzsB,IAAZ,CAAiB,GAAGoiC,oBAApB;AACD;;AACD,QAAI3V,WAAW,CAAC7sB,MAAZ,GAAqB,CAAzB,EAA4B;AAC1B,aAAO;AAAE6sB,QAAAA;AAAF,OAAP;AACD;;AACD,WAAO;AAAEtS,MAAAA;AAAF,KAAP;AACD;;AACDwX,EAAAA,KAAK,CAACH,GAAD,EAAMr1B,IAAN,EAAYiwB,QAAZ,EAAsB;AACzB,QAAIla,EAAJ;;AACAsf,IAAAA,GAAG,CAAC2jB,kBAAJ,CAAuB/oB,QAAQ,CAACvC,QAAT,CAAkB+Z,OAAzC,EAAkDxX,QAAQ,CAACvC,QAAT,CAAkBR,WAAlB,CAA8ByoB,mBAAhF,EAAqG,CAAC5/B,EAAE,GAAGka,QAAQ,CAACvC,QAAT,CAAkBmpB,mBAAxB,KAAgD,IAAhD,GAAuD9gC,EAAvD,GAA4DkL,4BAAjK;AACD;;AACDyU,EAAAA,eAAe,CAAC11B,IAAD,EAAOiwB,QAAP,EAAiB;AAC9B,UAAM4jB,cAAc,GAAG7zC,IAAI,CAAChB,aAAL,GAAqBkU,QAA5C;AACA,UAAMqiC,YAAY,GAAGtlB,QAAQ,CAACvC,QAAT,CAAkBR,WAAvC;;AACA,QAAI,CAACqoB,YAAY,CAACG,QAAlB,EAA4B;AAC1BzlB,MAAAA,QAAQ,CAACvC,QAAT,GAAoB,KAAK+nB,eAAL,CAAqBz1C,IAArB,EAA2Bu1C,YAA3B,CAApB;AACD;;AACD,QAAIvnB,MAAM,GAAG,EAAb;;AACA,QAAIiC,QAAQ,CAACkkB,SAAT,KAAuB,IAA3B,EAAiC;AAC/B,WAAK,MAAM5lB,QAAX,IAAuB0B,QAAQ,CAACkkB,SAAhC,EAA2C;AACzC,YAAI;AACF,gBAAM8E,gBAAgB,GAAG,KAAKrG,cAAL,CAAoB/d,OAApB,CAA4BtG,QAAQ,CAACxwB,GAArC,EAA0C81C,cAA1C,CAAzB;AACA,gBAAMqF,SAAS,GAAG,KAAKtG,cAAL,CAAoBqD,IAApB,CAAyBgD,gBAAzB,CAAlB;AACAjrB,UAAAA,MAAM,CAACnqB,IAAP,CAAYq1C,SAAZ;AACD,SAJD,CAIE,OAAOC,CAAP,EAAU,CACX;AACF;AACF;;AACD,QAAIlpB,QAAQ,CAACqkB,YAAT,KAA0B,IAA9B,EAAoC;AAClC,WAAK,MAAM4E,SAAX,IAAwBjpB,QAAQ,CAACqkB,YAAjC,EAA+C;AAC7CtmB,QAAAA,MAAM,CAACnqB,IAAP,CAAYq1C,SAAZ;AACD;AACF;;AACD,SAAK,MAAMA,SAAX,IAAwBjpB,QAAQ,CAACvC,QAAT,CAAkBM,MAA1C,EAAkD;AAChDA,MAAAA,MAAM,CAACnqB,IAAP,CAAYq1C,SAAZ;AACD;;AACDjpB,IAAAA,QAAQ,CAACnyB,IAAT,CAAckwB,MAAd,GAAuBA,MAAvB;AACD;;AACDiI,EAAAA,WAAW,CAACj2B,IAAD,EAAOiwB,QAAP,EAAiBC,UAAjB,EAA6BgW,IAA7B,EAAmC;AAC5C,QAAIjW,QAAQ,CAACvC,QAAT,CAAkBpZ,MAAlB,KAA6B,IAA7B,IAAqC2b,QAAQ,CAACvC,QAAT,CAAkBpZ,MAAlB,CAAyB7Q,MAAzB,GAAkC,CAA3E,EAA8E;AAC5E,aAAO,EAAP;AACD;;AACD,UAAM3F,IAAI,GAAG+B,cAAc,CAACA,cAAc,CAAC,EAAD,EAAKowB,QAAQ,CAACnyB,IAAd,CAAf,EAAoCoyB,UAApC,CAA3B;;AACA,UAAM/P,GAAG,GAAG8hB,wBAAwB,CAAC1hB,iBAAiB,CAACziB,IAAD,EAAOujB,cAAc,CAAC+3B,SAAtB,CAAlB,CAApC;AACA,UAAMh5B,GAAG,GAAGQ,4BAA4B,CAAC9iB,IAAD,EAAOooC,IAAP,EAAa1kB,kBAAkB,EAA/B,CAAxC;AACA,UAAMskB,aAAa,GAAG7V,QAAQ,CAAC6V,aAAT,KAA2B,IAA3B,GAAkCnlB,qBAAqB,CAACsP,QAAQ,CAAC6V,aAAV,CAArB,CAA8CK,MAA9C,EAAlC,GAA2F,IAAjH;AACA,WAAOjmB,cAAc,CAACC,GAAD,EAAMC,GAAN,EAAW0lB,aAAX,EAA0B,WAA1B,CAArB;AACD;;AACD9P,EAAAA,cAAc,CAACh2B,IAAD,EAAOiwB,QAAP,EAAiBC,UAAjB,EAA6B;AACzC,QAAID,QAAQ,CAACvC,QAAT,CAAkBpZ,MAAlB,KAA6B,IAA7B,IAAqC2b,QAAQ,CAACvC,QAAT,CAAkBpZ,MAAlB,CAAyB7Q,MAAzB,GAAkC,CAA3E,EAA8E;AAC5E,aAAO,EAAP;AACD;;AACD,UAAM41C,YAAY,GAAG;AACnB5R,MAAAA,OAAO,EAAExX,QAAQ,CAACvC,QAAT,CAAkB+Z,OADR;AAEnB6R,MAAAA,SAAS,EAAErpB,QAAQ,CAACvC,QAAT,CAAkBR,WAAlB,CAA8ByoB,mBAFtB;AAGnBD,MAAAA,QAAQ,EAAEzlB,QAAQ,CAACvC,QAAT,CAAkBR,WAAlB,CAA8BwoB,QAHrB;AAInB6D,MAAAA,+BAA+B,EAAEtpB,QAAQ,CAACvC,QAAT,CAAkBkoB,aAAlB,CAAgChoC,IAAhC,KAAyC,QAAzC,GAAoD,IAAIkU,gBAAJ,CAAqBmO,QAAQ,CAACvC,QAAT,CAAkBkoB,aAAlB,CAAgC51C,IAArD,CAApD,GAAiH;AAJ/H,KAArB;;AAMA,UAAMlC,IAAI,GAAG+B,cAAc,CAACA,cAAc,CAAC,EAAD,EAAKowB,QAAQ,CAACnyB,IAAd,CAAf,EAAoCoyB,UAApC,CAA3B;;AACA,UAAM/P,GAAG,GAAG+hB,qBAAqB,CAAC3hB,iBAAiB,CAACziB,IAAD,EAAOujB,cAAc,CAAC+3B,SAAtB,CAAlB,CAAjC;AACA,UAAMh5B,GAAG,GAAGW,mCAAmC,CAACjjB,IAAD,EAAOmyB,QAAQ,CAACvC,QAAhB,EAA0B2rB,YAA1B,CAA/C;AACA,UAAMvT,aAAa,GAAG7V,QAAQ,CAAC6V,aAAT,KAA2B,IAA3B,GAAkChlB,4BAA4B,CAACmP,QAAQ,CAAC6V,aAAV,CAA5B,CAAqDK,MAArD,EAAlC,GAAkG,IAAxH;AACA,WAAOjmB,cAAc,CAACC,GAAD,EAAMC,GAAN,EAAW0lB,aAAX,EAA0B,WAA1B,CAArB;AACD;;AACDgR,EAAAA,oCAAoC,CAACr9B,GAAD,EAAMoU,SAAN,EAAiBG,MAAjB,EAAyBN,QAAzB,EAAmC;AACrE,QAAIjU,GAAG,CAAChX,IAAJ,KAAa,WAAjB,EAA8B;AAC5B,aAAOgX,GAAP;AACD;;AACD,QAAI,CAACoU,SAAS,CAACnrB,GAAV,CAAc,aAAd,CAAD,IAAiC,CAACmrB,SAAS,CAACnrB,GAAV,CAAc,WAAd,CAAtC,EAAkE;AAChE,aAAO+W,GAAP;AACD;;AACD,UAAMib,QAAQ,GAAG,IAAI5xB,GAAJ,CAAQ+qB,SAAR,CAAjB;;AACA,QAAI6G,QAAQ,CAAChyB,GAAT,CAAa,aAAb,CAAJ,EAAiC;AAC/BgyB,MAAAA,QAAQ,CAAC2G,MAAT,CAAgB,aAAhB;AACA3G,MAAAA,QAAQ,CAACzxB,GAAT,CAAa,UAAb,EAAyB8e,IAAI,CAACsN,mBAAL,CAAyB3B,QAAQ,CAAC+Z,OAAlC,CAAzB;AACD;;AACD,QAAI/S,QAAQ,CAAChyB,GAAT,CAAa,WAAb,CAAJ,EAA+B;AAC7BgyB,MAAAA,QAAQ,CAAC2G,MAAT,CAAgB,WAAhB;AACA3G,MAAAA,QAAQ,CAACzxB,GAAT,CAAa,QAAb,EAAuB8e,IAAI,CAACqhB,kBAAL,CAAwBpV,MAAM,CAACnrB,GAAP,CAAY22C,CAAD,IAAOz3B,IAAI,CAACsN,mBAAL,CAAyBmqB,CAAzB,CAAlB,CAAxB,CAAvB;AACD;;AACD,UAAMC,iBAAiB,GAAG,EAA1B;;AACA,SAAK,MAAM,CAACh3C,IAAD,EAAO9B,KAAP,CAAX,IAA4B+zB,QAAQ,CAACze,OAAT,EAA5B,EAAgD;AAC9CwjC,MAAAA,iBAAiB,CAAC51C,IAAlB,CAAuBke,IAAI,CAACsiB,wBAAL,CAA8B5hC,IAA9B,EAAoC9B,KAApC,CAAvB;AACD;;AACD,WAAOf,aAAa,CAACC,cAAc,CAAC,EAAD,EAAK4Z,GAAL,CAAf,EAA0B;AAAEjW,MAAAA,IAAI,EAAE,CAACue,IAAI,CAACgiB,mBAAL,CAAyB0V,iBAAzB,CAAD;AAAR,KAA1B,CAApB;AACD;;AACD7F,EAAAA,eAAe,CAACh4B,SAAD,EAAY;AACzB,QAAI,KAAK23B,YAAL,CAAkB7wC,GAAlB,CAAsBkZ,SAAtB,CAAJ,EAAsC;AACpC,aAAO,KAAK23B,YAAL,CAAkB5wC,GAAlB,CAAsBiZ,SAAtB,CAAP;AACD;;AACD,QAAIA,SAAS,CAACpY,IAAV,KAAmB,IAAnB,IAA2BoY,SAAS,CAACpY,IAAV,CAAeC,MAAf,KAA0B,CAAzD,EAA4D;AAC1D,YAAM,IAAIiR,oBAAJ,CAAyBlB,SAAS,CAACmG,qBAAnC,EAA0Dzb,SAAS,CAAC0b,YAAV,CAAuBgC,SAAvB,CAA1D,EAA8F,uDAA9F,CAAN;AACD;;AACD,UAAM9d,IAAI,GAAGqe,gBAAgB,CAACP,SAAS,CAACpY,IAAV,CAAe,CAAf,CAAD,CAA7B;;AACA,QAAI,CAACue,IAAI,CAAChZ,yBAAL,CAA+BjL,IAA/B,CAAL,EAA2C;AACzC,YAAM,IAAI4W,oBAAJ,CAAyBlB,SAAS,CAACI,yBAAnC,EAA8D9V,IAA9D,EAAqE,qCAArE,CAAN;AACD;;AACD,SAAKy1C,YAAL,CAAkBtwC,GAAlB,CAAsB2Y,SAAtB,EAAiC9d,IAAjC;AACA,WAAOA,IAAP;AACD;;AACD82C,EAAAA,iBAAiB,CAAC/mB,SAAD,EAAYnF,KAAZ,EAAmBgxB,cAAnB,EAAmC;AAClD,QAAIt2C,QAAQ,GAAG,IAAf;;AACA,QAAIyqB,SAAS,CAACnrB,GAAV,CAAcgmB,KAAd,CAAJ,EAA0B;AACxB,YAAMrZ,IAAI,GAAGwe,SAAS,CAAClrB,GAAV,CAAc+lB,KAAd,CAAb;AACA,YAAM/nB,KAAK,GAAG,KAAKyc,SAAL,CAAe7a,QAAf,CAAwB8M,IAAxB,CAAd;;AACA,UAAI1O,KAAK,YAAYuC,SAAjB,IAA8B2Y,sBAAsB,CAAClb,KAAK,CAACwC,OAAP,EAAgBu2C,cAAhB,CAAxD,EAAyF;AACvFt2C,QAAAA,QAAQ,GAAGzC,KAAK,CAACyC,QAAjB;AACD,OAFD,MAEO;AACL,cAAMu8B,4BAA4B,CAACtwB,IAAD,EAAO1O,KAAP,EAAe,GAAE+nB,KAAM,wBAAuBgxB,cAAe,0BAA7D,CAAlC;AACD;AACF;;AACD,WAAOt2C,QAAP;AACD;;AACDixC,EAAAA,0BAA0B,CAACxmB,SAAD,EAAY;AACpC,QAAI,CAACA,SAAS,CAACnrB,GAAV,CAAc,WAAd,CAAL,EAAiC;AAC/B,aAAO,EAAP;AACD;;AACD,WAAO,KAAKi3C,+BAAL,CAAqC9rB,SAAS,CAAClrB,GAAV,CAAc,WAAd,CAArC,CAAP;AACD;;AACDg3C,EAAAA,+BAA+B,CAACC,aAAD,EAAgB;AAC7C,UAAMzF,SAAS,GAAG,EAAlB;;AACA,QAAIpyB,IAAI,CAAClY,wBAAL,CAA8B+vC,aAA9B,CAAJ,EAAkD;AAChD,WAAK,MAAMC,YAAX,IAA2BD,aAAa,CAAClvC,QAAzC,EAAmD;AACjD,YAAIqX,IAAI,CAACnX,eAAL,CAAqBivC,YAArB,CAAJ,EAAwC;AACtC1F,UAAAA,SAAS,CAACtwC,IAAV,CAAe,GAAG,KAAK81C,+BAAL,CAAqCE,YAAY,CAACzvC,UAAlD,CAAlB;AACD,SAFD,MAEO;AACL,gBAAMmkB,QAAQ,GAAG,KAAKnR,SAAL,CAAe7a,QAAf,CAAwBs3C,YAAxB,CAAjB;;AACA,cAAI,OAAOtrB,QAAP,KAAoB,QAAxB,EAAkC;AAChC,kBAAMoR,4BAA4B,CAACka,YAAD,EAAetrB,QAAf,EAAyB,2BAAzB,CAAlC;AACD;;AACD4lB,UAAAA,SAAS,CAACtwC,IAAV,CAAe;AACb9F,YAAAA,GAAG,EAAEwwB,QADQ;AAEblqB,YAAAA,MAAM,EAAE,CAFK;AAGbuV,YAAAA,YAAY,EAAEigC;AAHD,WAAf;AAKD;AACF;AACF,KAhBD,MAgBO;AACL,YAAMC,kBAAkB,GAAG,KAAK18B,SAAL,CAAe7a,QAAf,CAAwBq3C,aAAxB,CAA3B;;AACA,UAAI,CAACG,aAAa,CAACD,kBAAD,CAAlB,EAAwC;AACtC,cAAMna,4BAA4B,CAACia,aAAD,EAAgBE,kBAAhB,EAAoC,uCAApC,CAAlC;AACD;;AACD,WAAK,MAAMvrB,QAAX,IAAuBurB,kBAAvB,EAA2C;AACzC3F,QAAAA,SAAS,CAACtwC,IAAV,CAAe;AACb9F,UAAAA,GAAG,EAAEwwB,QADQ;AAEblqB,UAAAA,MAAM,EAAE,CAFK;AAGbuV,UAAAA,YAAY,EAAEggC;AAHD,SAAf;AAKD;AACF;;AACD,WAAOzF,SAAP;AACD;;AACD2B,EAAAA,sBAAsB,CAACjoB,SAAD,EAAYgmB,cAAZ,EAA4B;AAChD,UAAM7lB,MAAM,GAAG,IAAIra,GAAJ,EAAf;;AACA,aAASqmC,qBAAT,CAA+BxvC,KAA/B,EAAsC;AACpC,aAAOA,KAAK,CAACE,QAAN,CAAe8O,MAAf,CAAuB2/B,CAAD,IAAOp3B,IAAI,CAACjI,mBAAL,CAAyBq/B,CAAzB,CAA7B,CAAP;AACD;;AACD,UAAMS,aAAa,GAAG/rB,SAAS,CAAClrB,GAAV,CAAc,WAAd,CAAtB;;AACA,QAAIi3C,aAAa,KAAK,KAAK,CAAvB,IAA4B73B,IAAI,CAAClY,wBAAL,CAA8B+vC,aAA9B,CAAhC,EAA8E;AAC5E,WAAK,MAAMxvC,UAAX,IAAyB4vC,qBAAqB,CAACJ,aAAD,CAA9C,EAA+D;AAC7D,YAAI;AACF,gBAAM7F,WAAW,GAAG,KAAKnB,cAAL,CAAoB/d,OAApB,CAA4BzqB,UAAU,CAAC3B,IAAvC,EAA6CorC,cAA7C,CAApB;AACA7lB,UAAAA,MAAM,CAAChP,GAAP,CAAW;AAAE5N,YAAAA,IAAI,EAAE7R,YAAY,CAACw0C,WAAD,CAApB;AAAmC3pC,YAAAA;AAAnC,WAAX;AACD,SAHD,CAGE,MAAM,CACP;AACF;AACF;;AACD,UAAM6vC,UAAU,GAAGpsB,SAAS,CAAClrB,GAAV,CAAc,QAAd,CAAnB;;AACA,QAAIs3C,UAAU,KAAK,KAAK,CAApB,IAAyBl4B,IAAI,CAAClY,wBAAL,CAA8BowC,UAA9B,CAA7B,EAAwE;AACtE,WAAK,MAAM7vC,UAAX,IAAyB4vC,qBAAqB,CAACC,UAAD,CAA9C,EAA4D;AAC1DjsB,QAAAA,MAAM,CAAChP,GAAP,CAAW;AAAE5N,UAAAA,IAAI,EAAE,IAAR;AAAchH,UAAAA;AAAd,SAAX;AACD;AACF;;AACD,WAAO4jB,MAAP;AACD;;AACDkmB,EAAAA,wBAAwB,CAACl0C,IAAD,EAAO4b,SAAP,EAAkBiS,SAAlB,EAA6BgmB,cAA7B,EAA6C;AACnE,QAAIhmB,SAAS,CAACnrB,GAAV,CAAc,aAAd,CAAJ,EAAkC;AAChC,YAAMw3C,eAAe,GAAGrsB,SAAS,CAAClrB,GAAV,CAAc,aAAd,CAAxB;AACA,YAAMw3C,WAAW,GAAG,KAAK/8B,SAAL,CAAe7a,QAAf,CAAwB23C,eAAxB,CAApB;;AACA,UAAI,OAAOC,WAAP,KAAuB,QAA3B,EAAqC;AACnC,cAAMxa,4BAA4B,CAACua,eAAD,EAAkBC,WAAlB,EAA+B,8BAA/B,CAAlC;AACD;;AACD,UAAI;AACF,cAAMpG,WAAW,GAAG,KAAKnB,cAAL,CAAoB/d,OAApB,CAA4BslB,WAA5B,EAAyCtG,cAAzC,CAApB;AACA,cAAMuG,eAAe,GAAG,KAAKxH,cAAL,CAAoBoB,OAApB,CAA4BD,WAA5B,EAAyC;AAAEnmC,UAAAA,IAAI,EAAE,UAAR;AAAoBimC,UAAAA;AAApB,SAAzC,CAAxB;;AACA,YAAIuG,eAAe,KAAK,KAAK,CAA7B,EAAgC;AAC9B,iBAAOA,eAAe,CAACxnB,IAAhB,CAAqB,MAAM;AAChC,kBAAM2iB,YAAY,GAAG,KAAKC,wBAAL,CAA8B55B,SAA9B,EAAyCiS,SAAzC,EAAoDgmB,cAApD,CAArB;AACA,kBAAMnmB,QAAQ,GAAG,KAAK+nB,eAAL,CAAqBz1C,IAArB,EAA2Bu1C,YAA3B,CAAjB;AACA,iBAAK9B,uBAAL,CAA6BxwC,GAA7B,CAAiCjD,IAAjC,EAAuC0tB,QAAvC;AACA,mBAAOA,QAAP;AACD,WALM,CAAP;AAMD,SAPD,MAOO;AACL,iBAAOgF,OAAO,CAACmC,OAAR,CAAgB,IAAhB,CAAP;AACD;AACF,OAbD,CAaE,OAAOskB,CAAP,EAAU;AACV,cAAM,KAAK/C,yBAAL,CAA+B+D,WAA/B,EAA4CD,eAA5C,EAA6D,CAA7D,CAAN;AACD;AACF,KAtBD,MAsBO;AACL,YAAM3E,YAAY,GAAG,KAAKC,wBAAL,CAA8B55B,SAA9B,EAAyCiS,SAAzC,EAAoDgmB,cAApD,CAArB;AACA,YAAMnmB,QAAQ,GAAG,KAAK+nB,eAAL,CAAqBz1C,IAArB,EAA2Bu1C,YAA3B,CAAjB;AACA,WAAK9B,uBAAL,CAA6BxwC,GAA7B,CAAiCjD,IAAjC,EAAuC0tB,QAAvC;AACA,aAAOgF,OAAO,CAACmC,OAAR,CAAgBnH,QAAhB,CAAP;AACD;AACF;;AACD+nB,EAAAA,eAAe,CAACz1C,IAAD,EAAO0tB,QAAP,EAAiB;AAC9B,QAAIA,QAAQ,CAACgoB,QAAb,EAAuB;AACrB,UAAI2E,SAAJ;AACA,UAAIC,gBAAgB,GAAG,IAAvB;AACA,UAAIC,eAAJ;AACA,UAAI3E,aAAJ;AACA,UAAI4E,aAAa,GAAG,KAApB;AACA,UAAIC,YAAJ;;AACA,UAAI14B,IAAI,CAACvZ,eAAL,CAAqBklB,QAAQ,CAACtjB,UAA9B,KAA6C2X,IAAI,CAACrZ,+BAAL,CAAqCglB,QAAQ,CAACtjB,UAA9C,CAAjD,EAA4G;AAC1GkwC,QAAAA,gBAAgB,GAAGI,gBAAgB,CAAChtB,QAAQ,CAACtjB,UAAV,CAAnC;AACAiwC,QAAAA,SAAS,GAAG3sB,QAAQ,CAACtjB,UAAT,CAAoBpL,aAApB,GAAoCyJ,IAAhD;AACA8xC,QAAAA,eAAe,GAAG7sB,QAAQ,CAACtjB,UAAT,CAAoB3B,IAAtC;AACA+xC,QAAAA,aAAa,GAAG,IAAhB;AACA5E,QAAAA,aAAa,GAAG;AACdhoC,UAAAA,IAAI,EAAE,QADQ;AAEd5N,UAAAA,IAAI,EAAE0tB,QAAQ,CAACtjB;AAFD,SAAhB;AAIAqwC,QAAAA,YAAY,GAAG/sB,QAAQ,CAACioB,mBAAxB;AACD,OAVD,MAUO;AACL,cAAMgF,gBAAgB,GAAG,KAAKv9B,SAAL,CAAe7a,QAAf,CAAwBmrB,QAAQ,CAACtjB,UAAjC,CAAzB;;AACA,YAAI,OAAOuwC,gBAAP,KAA4B,QAAhC,EAA0C;AACxC,gBAAMhb,4BAA4B,CAACjS,QAAQ,CAACtjB,UAAV,EAAsBuwC,gBAAtB,EAAwC,2BAAxC,CAAlC;AACD;;AACDN,QAAAA,SAAS,GAAGM,gBAAZ;AACAJ,QAAAA,eAAe,GAAGI,gBAAlB;AACA/E,QAAAA,aAAa,GAAG;AACdhoC,UAAAA,IAAI,EAAE,UADQ;AAEd5N,UAAAA,IAAI,EAAE0tB,QAAQ,CAACtjB,UAFD;AAGdwwC,UAAAA,cAAc,EAAE56C,IAHF;AAId0tB,UAAAA,QAAQ,EAAE6sB;AAJI,SAAhB;AAMAE,QAAAA,YAAY,GAAG,IAAf;AACD;;AACD,aAAO76C,aAAa,CAACC,cAAc,CAAC,EAAD,EAAK,KAAKg7C,cAAL,CAAoBntB,QAApB,EAA8B2sB,SAA9B,EAAyCC,gBAAzC,EAA2DE,aAA3D,EAA0EC,YAA1E,CAAL,CAAf,EAA8G;AAChIhT,QAAAA,OAAO,EAAE8S,eADuH;AAEhI3E,QAAAA,aAFgI;AAGhI1oB,QAAAA,WAAW,EAAEQ;AAHmH,OAA9G,CAApB;AAKD,KArCD,MAqCO;AACL,YAAM6sB,eAAe,GAAG,KAAK3H,cAAL,CAAoBqD,IAApB,CAAyBvoB,QAAQ,CAACioB,mBAAlC,CAAxB;;AACA,UAAI,KAAKrC,UAAL,KAAoB,IAAxB,EAA8B;AAC5B,aAAKA,UAAL,CAAgB4C,qBAAhB,CAAsCl2C,IAAI,CAAChB,aAAL,EAAtC,EAA4DO,YAAY,CAACmuB,QAAQ,CAACioB,mBAAV,CAAxE;AACD;;AACD,aAAO/1C,aAAa,CAACC,cAAc,CAAC,EAAD,EAAK,KAAKg7C,cAAL,CAAoBntB,QAApB,EAA8B6sB,eAA9B,EAA+C,IAA/C,EAAqD,KAArD,EAA4D7sB,QAAQ,CAACioB,mBAArE,CAAL,CAAf,EAAgH;AAClIlO,QAAAA,OAAO,EAAE8S,eADyH;AAElI3E,QAAAA,aAAa,EAAE;AACbhoC,UAAAA,IAAI,EAAE,UADO;AAEbgtC,UAAAA,cAAc,EAAE56C,IAFH;AAGbA,UAAAA,IAAI,EAAE0tB,QAAQ,CAACotB,qBAHF;AAIbptB,UAAAA,QAAQ,EAAE6sB,eAJG;AAKbJ,UAAAA,WAAW,EAAEzsB,QAAQ,CAACioB;AALT,SAFmH;AASlIzoB,QAAAA,WAAW,EAAEQ;AATqH,OAAhH,CAApB;AAWD;AACF;;AACDmtB,EAAAA,cAAc,CAACntB,QAAD,EAAW2sB,SAAX,EAAsBC,gBAAtB,EAAwCE,aAAxC,EAAuDC,YAAvD,EAAqE;AACjF,UAAMvH,8BAA8B,GAAGsH,aAAa,IAAI,KAAKtH,8BAA7D;AACA,UAAM6H,cAAc,GAAGr5B,aAAa,CAAC24B,SAAD,EAAYI,YAAY,IAAI,IAAhB,GAAuBA,YAAvB,GAAsC,EAAlD,EAAsD;AACxFO,MAAAA,mBAAmB,EAAEttB,QAAQ,CAACstB,mBAD0D;AAExFnE,MAAAA,mBAAmB,EAAEnpB,QAAQ,CAACmpB,mBAF0D;AAGxFoE,MAAAA,KAAK,EAAEX,gBAAgB,IAAI,IAApB,GAA2BA,gBAA3B,GAA8C,KAAK,CAH8B;AAIxFE,MAAAA,aAJwF;AAKxFxH,MAAAA,+BAA+B,EAAE,KAAKA,+BALkD;AAMxFE,MAAAA,8BANwF;AAOxFgI,MAAAA,kCAAkC,EAAE,KAAKjI;AAP+C,KAAtD,CAApC;AASA,UAAM;AAAEyD,MAAAA,KAAK,EAAEY;AAAT,QAAuB51B,aAAa,CAAC24B,SAAD,EAAYI,YAAY,IAAI,IAAhB,GAAuBA,YAAvB,GAAsC,EAAlD,EAAsD;AAC9FO,MAAAA,mBAAmB,EAAE,IADyE;AAE9FG,MAAAA,mBAAmB,EAAE,IAFyE;AAG9FtE,MAAAA,mBAAmB,EAAEnpB,QAAQ,CAACmpB,mBAHgE;AAI9FoE,MAAAA,KAAK,EAAEX,gBAAgB,IAAI,IAApB,GAA2BA,gBAA3B,GAA8C,KAAK,CAJoC;AAK9FE,MAAAA,aAL8F;AAM9FxH,MAAAA,+BAA+B,EAAE,KAAKA,+BANwD;AAO9FE,MAAAA,8BAP8F;AAQ9FkI,MAAAA,kBAAkB,EAAE,EAR0E;AAS9FF,MAAAA,kCAAkC,EAAE,KAAKjI;AATqD,KAAtD,CAA1C;AAWA,WAAOrzC,aAAa,CAACC,cAAc,CAAC,EAAD,EAAKk7C,cAAL,CAAf,EAAqC;AACvDzD,MAAAA,SADuD;AAEvDliC,MAAAA,IAAI,EAAE,IAAIqM,gBAAJ,CAAqB44B,SAArB,EAAgCI,YAAY,IAAI,IAAhB,GAAuBA,YAAvB,GAAsC,EAAtE;AAFiD,KAArC,CAApB;AAID;;AACDjF,EAAAA,wBAAwB,CAAC55B,SAAD,EAAYiS,SAAZ,EAAuBgmB,cAAvB,EAAuC;AAC7D,QAAImH,mBAAmB,GAAG,KAAKlI,0BAA/B;;AACA,QAAIjlB,SAAS,CAACnrB,GAAV,CAAc,qBAAd,CAAJ,EAA0C;AACxC,YAAM2M,IAAI,GAAGwe,SAAS,CAAClrB,GAAV,CAAc,qBAAd,CAAb;AACA,YAAMhC,KAAK,GAAG,KAAKyc,SAAL,CAAe7a,QAAf,CAAwB8M,IAAxB,CAAd;;AACA,UAAI,OAAO1O,KAAP,KAAiB,SAArB,EAAgC;AAC9B,cAAMg/B,4BAA4B,CAACtwB,IAAD,EAAO1O,KAAP,EAAc,uCAAd,CAAlC;AACD;;AACDq6C,MAAAA,mBAAmB,GAAGr6C,KAAtB;AACD;;AACD,QAAIk2C,mBAAmB,GAAG51B,4BAA1B;;AACA,QAAI4M,SAAS,CAACnrB,GAAV,CAAc,eAAd,CAAJ,EAAoC;AAClC,YAAM2M,IAAI,GAAGwe,SAAS,CAAClrB,GAAV,CAAc,eAAd,CAAb;AACA,YAAMhC,KAAK,GAAG,KAAKyc,SAAL,CAAe7a,QAAf,CAAwB8M,IAAxB,CAAd;;AACA,UAAI,CAACvL,KAAK,CAACC,OAAN,CAAcpD,KAAd,CAAD,IAAyBA,KAAK,CAAC8C,MAAN,KAAiB,CAA1C,IAA+C,CAAC9C,KAAK,CAACs6B,KAAN,CAAatwB,OAAD,IAAa,OAAOA,OAAP,KAAmB,QAA5C,CAApD,EAA2G;AACzG,cAAMg1B,4BAA4B,CAACtwB,IAAD,EAAO1O,KAAP,EAAc,+DAAd,CAAlC;AACD;;AACDk2C,MAAAA,mBAAmB,GAAGv1B,mBAAmB,CAAC+5B,SAApB,CAA8B16C,KAA9B,CAAtB;AACD;;AACD,QAAIktB,SAAS,CAACnrB,GAAV,CAAc,aAAd,CAAJ,EAAkC;AAChC,YAAMw3C,eAAe,GAAGrsB,SAAS,CAAClrB,GAAV,CAAc,aAAd,CAAxB;AACA,YAAMw3C,WAAW,GAAG,KAAK/8B,SAAL,CAAe7a,QAAf,CAAwB23C,eAAxB,CAApB;;AACA,UAAI,OAAOC,WAAP,KAAuB,QAA3B,EAAqC;AACnC,cAAMxa,4BAA4B,CAACua,eAAD,EAAkBC,WAAlB,EAA+B,8BAA/B,CAAlC;AACD;;AACD,UAAI;AACF,cAAMpG,WAAW,GAAG,KAAKnB,cAAL,CAAoB/d,OAApB,CAA4BslB,WAA5B,EAAyCtG,cAAzC,CAApB;AACA,eAAO;AACL6B,UAAAA,QAAQ,EAAE,KADL;AAELmB,UAAAA,mBAFK;AAGLmE,UAAAA,mBAHK;AAILb,UAAAA,WAJK;AAKLW,UAAAA,qBAAqB,EAAEZ,eALlB;AAMLvE,UAAAA,mBAAmB,EAAE5B;AANhB,SAAP;AAQD,OAVD,CAUE,OAAOoF,CAAP,EAAU;AACV,cAAM,KAAK/C,yBAAL,CAA+B+D,WAA/B,EAA4CD,eAA5C,EAA6D,CAA7D,CAAN;AACD;AACF,KAnBD,MAmBO,IAAIrsB,SAAS,CAACnrB,GAAV,CAAc,UAAd,CAAJ,EAA+B;AACpC,aAAO;AACLgzC,QAAAA,QAAQ,EAAE,IADL;AAELmB,QAAAA,mBAFK;AAGLmE,QAAAA,mBAHK;AAIL5wC,QAAAA,UAAU,EAAEyjB,SAAS,CAAClrB,GAAV,CAAc,UAAd,CAJP;AAKLw3C,QAAAA,WAAW,EAAEtG,cALR;AAML8B,QAAAA,mBAAmB,EAAE9B;AANhB,OAAP;AAQD,KATM,MASA;AACL,YAAM,IAAIn/B,oBAAJ,CAAyBlB,SAAS,CAAC8nC,0BAAnC,EAA+Dp9C,SAAS,CAAC0b,YAAV,CAAuBgC,SAAvB,CAA/D,EAAkG,iCAAlG,CAAN;AACD;AACF;;AACD2/B,EAAAA,oBAAoB,CAACxD,YAAD,EAAe1oC,IAAf,EAAqBmsC,MAArB,EAA6B;AAC/C,QAAIzD,YAAY,KAAK,SAArB,EAAgC;AAC9B,aAAOA,YAAP;AACD;;AACD,QAAI,EAAE1oC,IAAI,YAAY8R,aAAlB,CAAJ,EAAsC;AACpC,aAAO,IAAP;AACD;;AACD,WAAO,KAAKgyB,cAAL,CAAoBsI,aAApB,CAAkCpsC,IAAI,CAAC1O,KAAL,CAAW0Z,UAA7C,EAAyDmhC,MAAM,CAACtoC,QAAhE,CAAP;AACD;;AACDmlC,EAAAA,qBAAqB,CAACN,YAAD,EAAe1oC,IAAf,EAAqBmsC,MAArB,EAA6B;AAChD,UAAME,QAAQ,GAAG,KAAKH,oBAAL,CAA0BxD,YAA1B,EAAwC1oC,IAAxC,EAA8CmsC,MAA9C,CAAjB;;AACA,QAAIE,QAAQ,KAAK,IAAjB,EAAuB;AACrB,aAAO,IAAP;AACD;;AACD,WAAO,KAAKtI,aAAL,CAAmBuI,gBAAnB,CAAoCH,MAApC,EAA4CE,QAA5C,CAAP;AACD;;AACDjD,EAAAA,sBAAsB,CAACV,YAAD,EAAe1oC,IAAf,EAAqBmsC,MAArB,EAA6B;AACjD,UAAME,QAAQ,GAAG,KAAKH,oBAAL,CAA0BxD,YAA1B,EAAwC1oC,IAAxC,EAA8CmsC,MAA9C,CAAjB;;AACA,QAAIE,QAAQ,KAAK,IAAjB,EAAuB;AACrB;AACD;;AACD,SAAKtI,aAAL,CAAmBwI,qBAAnB,CAAyCJ,MAAzC,EAAiDE,QAAjD;AACD;;AACDtF,EAAAA,yBAAyB,CAAChhC,IAAD,EAAOwE,YAAP,EAAqBu8B,YAArB,EAAmC;AAC1D,QAAI0F,SAAJ;;AACA,YAAQ1F,YAAR;AACE,WAAK,CAAL;AACE0F,QAAAA,SAAS,GAAI,iCAAgCzmC,IAAK,IAAlD;AACA;;AACF,WAAK,CAAL;AACEymC,QAAAA,SAAS,GAAI,mCAAkCzmC,IAAK,6BAApD;AACA;;AACF,WAAK,CAAL;AACEymC,QAAAA,SAAS,GAAI,mCAAkCzmC,IAAK,IAApD;AACA;AATJ;;AAWA,WAAO,IAAIV,oBAAJ,CAAyBlB,SAAS,CAACsoC,4BAAnC,EAAiEliC,YAAjE,EAA+EiiC,SAA/E,CAAP;AACD;;AACD9F,EAAAA,yBAAyB,CAACroB,QAAD,EAAW;AAClC,QAAIA,QAAQ,CAACymB,SAAT,KAAuB,IAA3B,EAAiC;AAC/B,aAAO,EAAP;AACD;;AACD,UAAMv6B,YAAY,GAAGmiC,kCAAkC,CAACruB,QAAQ,CAACR,WAAV,CAAvD;AACA,WAAOQ,QAAQ,CAACymB,SAAT,CAAmBtxC,GAAnB,CAAwB9E,GAAD,KAAU;AAAEA,MAAAA,GAAF;AAAOsG,MAAAA,MAAM,EAAE,CAAf;AAAkBuV,MAAAA;AAAlB,KAAV,CAAvB,CAAP;AACD;;AAnyBmC,CAAtC;;AAqyBA,SAAS8gC,gBAAT,CAA0BsB,YAA1B,EAAwC;AACtC,QAAMC,QAAQ,GAAGD,YAAY,CAAC1mC,QAAb,KAA0B,CAA3C;AACA,QAAM;AAAEmK,IAAAA,IAAF;AAAQE,IAAAA;AAAR,MAAsBoC,IAAI,CAAClC,6BAAL,CAAmCm8B,YAAY,CAACh9C,aAAb,EAAnC,EAAiEi9C,QAAjE,CAA5B;AACA,SAAO;AACLA,IAAAA,QADK;AAELv8B,IAAAA,SAAS,EAAED,IAFN;AAGLG,IAAAA,QAAQ,EAAED,SAHL;AAILu8B,IAAAA,MAAM,EAAEF,YAAY,CAACx8B,MAAb,KAAwB;AAJ3B,GAAP;AAMD;;AACD,SAASu6B,aAAT,CAAuBoC,aAAvB,EAAsC;AACpC,SAAOr4C,KAAK,CAACC,OAAN,CAAco4C,aAAd,KAAgCA,aAAa,CAAClhB,KAAd,CAAqB/oB,IAAD,IAAU,OAAOA,IAAP,KAAgB,QAA9C,CAAvC;AACD;;AACD,SAAS6pC,kCAAT,CAA4C7uB,WAA5C,EAAyD;AACvD,UAAQA,WAAW,CAACwoB,QAApB;AACE,SAAK,IAAL;AACE,aAAOxoB,WAAW,CAAC9iB,UAAnB;;AACF,SAAK,KAAL;AACE,aAAO8iB,WAAW,CAAC4tB,qBAAnB;AAJJ;AAMD;;AACD,SAAShC,oBAAT,CAA8Bv4C,GAA9B,EAAmCqN,IAAnC,EAAyCwqC,KAAzC,EAAgD;AAC9C,QAAM31C,IAAI,GAAGlC,GAAG,CAAC6V,SAAJ,IAAiB,WAA9B;AACA,QAAMhF,IAAI,GAAGgnC,KAAK,CAACgE,OAAN,GAAgBv5C,GAAhB,CAAqBwc,EAAD,IAAQA,EAAE,CAACnM,QAA/B,EAAyCrH,IAAzC,CAA8C,MAA9C,CAAb;AACA,QAAM8I,OAAO,GAAI,OAAM/G,IAAK,KAAInL,IAAK,mEAArC;AACA,SAAO+S,sBAAsB,CAACjV,GAAG,CAACP,IAAL,EAAW2U,OAAO,GAAGvD,IAArB,CAA7B;AACD;;AACD,SAASmlC,mCAAT,CAA6C5rB,QAA7C,EAAuD;AACrD,MAAIA,QAAQ,CAAC0xB,QAAT,CAAkB,GAAlB,KAA0B1xB,QAAQ,CAAC0xB,QAAT,CAAkB,GAAlB,KAA0B1xB,QAAQ,CAAC0xB,QAAT,CAAkB,GAAlB,CAAxD,EAAgF;AAC9E,WAAO,IAAP;AACD;;AACD,MAAI,CAAC,SAAShmC,IAAT,CAAcsU,QAAd,CAAL,EAA8B;AAC5B,WAAO,qFAAP;AACD;;AACD,MAAI,QAAQtU,IAAR,CAAasU,QAAb,CAAJ,EAA4B;AAC1B,WAAO,2EAAP;AACD;;AACD,MAAI,CAACA,QAAQ,CAAC0xB,QAAT,CAAkB,GAAlB,CAAL,EAA6B;AAC3B,WAAO,sFAAP;AACD;;AACD,SAAO,IAAP;AACD,C,CAED;;;AACA,SAAS37B,oBAAoB,IAAI47B,qBAAjC,EAAwDz7B,2BAA2B,IAAI07B,4BAAvF,EAAqHC,oCAArH,EAA2JC,iBAA3J,EAA8Klb,+BAA+B,IAAImb,gCAAjN,EAAmPt7B,aAAa,IAAIu7B,cAApQ,EAAoR3kC,WAAW,IAAI4kC,YAAnS,EAAiTvkC,eAAe,IAAIwkC,gBAApU,QAA4V,mBAA5V;AACA,OAAOC,IAAP,MAAiB,YAAjB;AACA,IAAIC,0BAA0B,GAAG,MAAM;AACrCh9C,EAAAA,WAAW,CAAC0Y,SAAD,EAAYC,MAAZ,EAAoBskC,cAApB,EAAoC3X,kBAApC,EAAwDpU,IAAxD,EAA8DgsB,oBAAoB,GAAG,IAArF,EAA2F;AACpG,SAAKxkC,SAAL,GAAiBA,SAAjB;AACA,SAAKC,MAAL,GAAcA,MAAd;AACA,SAAKskC,cAAL,GAAsBA,cAAtB;AACA,SAAK3X,kBAAL,GAA0BA,kBAA1B;AACA,SAAKpU,IAAL,GAAYA,IAAZ;AACA,SAAKgsB,oBAAL,GAA4BA,oBAA5B;AACA,SAAKhpB,UAAL,GAAkBvF,iBAAiB,CAACwuB,MAApC;AACA,SAAKz6C,IAAL,GAAYs6C,0BAA0B,CAACt6C,IAAvC;AACD;;AACDsxB,EAAAA,MAAM,CAAC/zB,IAAD,EAAOuZ,UAAP,EAAmB;AACvB,QAAI,CAACA,UAAL,EAAiB;AACf,aAAO,KAAK,CAAZ;AACD;;AACD,UAAMqC,SAAS,GAAGK,oBAAoB,CAAC1C,UAAD,EAAa,YAAb,EAA2B,KAAKb,MAAhC,CAAtC;;AACA,QAAIkD,SAAS,KAAK,KAAK,CAAvB,EAA0B;AACxB,aAAO;AACL2a,QAAAA,OAAO,EAAE3a,SAAS,CAAC5b,IADd;AAEL4b,QAAAA,SAFK;AAGL8Y,QAAAA,QAAQ,EAAE9Y;AAHL,OAAP;AAKD,KAND,MAMO;AACL,aAAO,KAAK,CAAZ;AACD;AACF;;AACDgW,EAAAA,OAAO,CAAC5xB,IAAD,EAAO4b,SAAP,EAAkB;AACvB,SAAKqV,IAAL,CAAUiB,UAAV,CAAqBxyB,SAAS,CAACy9C,iBAA/B;AACA,UAAMr/C,IAAI,GAAGs/C,yBAAyB,CAACp9C,IAAD,EAAO4b,SAAP,EAAkB,KAAKnD,SAAvB,CAAtC;AACA,UAAMc,UAAU,GAAG,KAAKd,SAAL,CAAemb,0BAAf,CAA0C5zB,IAA1C,CAAnB;AACA,WAAO;AACLiwB,MAAAA,QAAQ,EAAE;AACRnyB,QAAAA,IADQ;AAERoqC,QAAAA,QAAQ,EAAEmV,yBAAyB,CAACr9C,IAAD,EAAOlC,IAAP,EAAa8d,SAAb,EAAwB,KAAKnD,SAA7B,EAAwC,KAAKC,MAA7C,EAAqD,KAAKskC,cAA1D,CAF3B;AAGRlX,QAAAA,aAAa,EAAErD,oBAAoB,CAACziC,IAAD,EAAO,KAAKyY,SAAZ,EAAuB,KAAKC,MAA5B,CAH3B;AAIR4kC,QAAAA,YAAY,EAAE,CAAC/jC,UAAD,IAAeA,UAAU,CAAC0hB,KAAX,CAAkB7V,OAAD,IAAa,CAAC1L,aAAa,CAAC0L,OAAD,CAAd,IAA2BA,OAAO,CAAC3iB,IAAR,KAAiB,YAA1E;AAJrB;AADL,KAAP;AAQD;;AACD2I,EAAAA,MAAM,GAAG;AACP,WAAO,IAAP;AACD;;AACDqoB,EAAAA,QAAQ,CAACzzB,IAAD,EAAO;AACb,SAAKqlC,kBAAL,CAAwBpY,kBAAxB,CAA2CjtB,IAA3C;AACD;;AACDi2B,EAAAA,WAAW,CAACj2B,IAAD,EAAOiwB,QAAP,EAAiB;AAC1B,WAAO,KAAK0F,OAAL,CAAasM,wBAAb,EAAwCnkC,IAAD,IAAU2+C,iBAAiB,CAAC3+C,IAAD,EAAO,KAAP,CAAlE,EAAiFw+C,qBAAjF,EAAwGt8C,IAAxG,EAA8GiwB,QAA9G,CAAP;AACD;;AACD+F,EAAAA,cAAc,CAACh2B,IAAD,EAAOiwB,QAAP,EAAiB;AAC7B,WAAO,KAAK0F,OAAL,CAAauM,qBAAb,EAAoCsa,oCAApC,EAA0ED,4BAA1E,EAAwGv8C,IAAxG,EAA8GiwB,QAA9G,CAAP;AACD;;AACD0F,EAAAA,OAAO,CAAC4nB,gBAAD,EAAmBC,mBAAnB,EAAwCC,sBAAxC,EAAgEz9C,IAAhE,EAAsEiwB,QAAtE,EAAgF;AACrF,UAAMia,OAAO,GAAG,EAAhB;;AACA,QAAIja,QAAQ,CAACqtB,YAAb,EAA2B;AACzB,YAAMx/C,IAAI,GAAGmyB,QAAQ,CAACnyB,IAAtB;AACA,YAAM4/C,UAAU,GAAGH,gBAAgB,CAACh9B,iBAAiB,CAAC3gB,aAAa,CAACC,cAAc,CAAC,EAAD,EAAK/B,IAAL,CAAf,EAA2B;AAAE6a,QAAAA,IAAI,EAAEsX,QAAQ,CAACiY;AAAjB,OAA3B,CAAd,EAAuEyU,cAAc,CAACgB,UAAtF,CAAlB,CAAnC;;AACA,UAAI1tB,QAAQ,CAAC6V,aAAT,KAA2B,IAA/B,EAAqC;AACnC4X,QAAAA,UAAU,CAACnhC,UAAX,CAAsB1Y,IAAtB,CAA2B45C,sBAAsB,CAACxtB,QAAQ,CAAC6V,aAAV,CAAtB,CAA+CK,MAA/C,EAA3B;AACD;;AACD+D,MAAAA,OAAO,CAACrmC,IAAR,CAAa65C,UAAb;AACD;;AACD,UAAME,KAAU,GAAG,KAAKnlC,SAAL,CAAe5J,iBAAf,CAAiC7O,IAAjC,EAAuC8O,IAAvC,CAA6Cd,MAAD,IAAYA,MAAM,CAACvL,IAAP,KAAgB,YAAxE,CAAnB;;AACA,QAAIm7C,KAAU,KAAK,KAAK,CAApB,IAAyB,KAAKX,oBAAlC,EAAwD;AACtD,YAAM,IAAIvoC,oBAAJ,CAAyBlB,SAAS,CAACqqC,yBAAnC,EAA8DD,KAAU,CAACziC,QAAX,IAAuByiC,KAAU,CAAC59C,IAAlC,IAA0CA,IAAxG,EAA8G,yGAA9G,CAAN;AACD;;AACD,QAAI49C,KAAU,KAAK,KAAK,CAAxB,EAA2B;AACzB,YAAMhuC,GAAG,GAAG4tC,mBAAmB,CAACvtB,QAAQ,CAACnyB,IAAV,CAA/B;AACAosC,MAAAA,OAAO,CAACrmC,IAAR,CAAa;AAAEpB,QAAAA,IAAI,EAAE,YAAR;AAAsByI,QAAAA,WAAW,EAAE0E,GAAG,CAACxF,UAAvC;AAAmDmS,QAAAA,UAAU,EAAE3M,GAAG,CAAC2M,UAAnE;AAA+E3O,QAAAA,IAAI,EAAEgC,GAAG,CAAChC;AAAzF,OAAb;AACD;;AACD,WAAOs8B,OAAP;AACD;;AAtEoC,CAAvC;;AAwEA,SAASkT,yBAAT,CAAmC5kC,KAAnC,EAA0CoD,SAA1C,EAAqDnD,SAArD,EAAgE;AAC9D,QAAMhW,IAAI,GAAG+V,KAAK,CAAC/V,IAAN,CAAWgG,IAAxB;AACA,QAAMmF,IAAI,GAAGqR,iBAAiB,CAACxG,SAAD,EAAYD,KAAZ,CAA9B;AACA,QAAMgI,YAAY,GAAG,IAAIq8B,gBAAJ,CAAqBpkC,SAAS,CAAC4vB,sBAAV,CAAiC7vB,KAAjC,CAArB,CAArB;AACA,QAAMiI,iBAAiB,GAAGhI,SAAS,CAACoQ,sBAAV,CAAiCrQ,KAAjC,KAA2C,CAArE;;AACA,MAAIoD,SAAS,CAACpY,IAAV,KAAmB,IAAvB,EAA6B;AAC3B,UAAM,IAAIkR,oBAAJ,CAAyBlB,SAAS,CAACsqC,oBAAnC,EAAyD5/C,SAAS,CAAC0b,YAAV,CAAuBgC,SAAvB,CAAzD,EAA4F,4BAA5F,CAAN;AACD;;AACD,MAAIA,SAAS,CAACpY,IAAV,CAAeC,MAAf,KAA0B,CAA9B,EAAiC;AAC/B,WAAO;AACLhB,MAAAA,IADK;AAELmL,MAAAA,IAFK;AAGL6S,MAAAA,iBAHK;AAILD,MAAAA,YAJK;AAKLu9B,MAAAA,UAAU,EAAErB,gCAAgC,CAAC,IAAIE,YAAJ,CAAiB,IAAjB,CAAD,EAAyB,CAAzB;AALvC,KAAP;AAOD,GARD,MAQO,IAAIhhC,SAAS,CAACpY,IAAV,CAAeC,MAAf,KAA0B,CAA9B,EAAiC;AACtC,UAAMu6C,QAAQ,GAAGpiC,SAAS,CAACpY,IAAV,CAAe,CAAf,CAAjB;;AACA,QAAI,CAACs5C,IAAI,CAAC/zC,yBAAL,CAA+Bi1C,QAA/B,CAAL,EAA+C;AAC7C,YAAM,IAAItpC,oBAAJ,CAAyBlB,SAAS,CAACI,yBAAnC,EAA8DoqC,QAA9D,EAAyE,gDAAzE,CAAN;AACD;;AACD,UAAMlgD,IAAI,GAAGS,oBAAoB,CAACy/C,QAAD,CAAjC;AACA,UAAMD,UAAU,GAAGjgD,IAAI,CAAC4E,GAAL,CAAS,YAAT,IAAyBu7C,qBAAqB,CAACngD,IAAI,CAAC6E,GAAL,CAAS,YAAT,CAAD,EAAyB8V,SAAzB,CAA9C,GAAoFikC,gCAAgC,CAAC,IAAIE,YAAJ,CAAiB,IAAjB,CAAD,EAAyB,CAAzB,CAAvI;AACA,QAAIjkC,IAAI,GAAG,KAAK,CAAhB;;AACA,QAAI,CAAC7a,IAAI,CAAC4E,GAAL,CAAS,UAAT,KAAwB5E,IAAI,CAAC4E,GAAL,CAAS,YAAT,CAAzB,KAAoD5E,IAAI,CAAC4E,GAAL,CAAS,MAAT,CAAxD,EAA0E;AACxE,YAAMw7C,QAAQ,GAAGpgD,IAAI,CAAC6E,GAAL,CAAS,MAAT,CAAjB;;AACA,UAAI,CAACm6C,IAAI,CAACjzC,wBAAL,CAA8Bq0C,QAA9B,CAAL,EAA8C;AAC5C,cAAM,IAAIxpC,oBAAJ,CAAyBlB,SAAS,CAAC2qC,iBAAnC,EAAsDD,QAAtD,EAAiE,mDAAjE,CAAN;AACD;;AACDvlC,MAAAA,IAAI,GAAGulC,QAAQ,CAACxzC,QAAT,CAAkB7H,GAAlB,CAAuBslC,GAAD,IAASiW,MAAM,CAACjW,GAAD,EAAM1vB,SAAN,CAArC,CAAP;AACD;;AACD,UAAM9U,MAAM,GAAG;AAAElB,MAAAA,IAAF;AAAQmL,MAAAA,IAAR;AAAc6S,MAAAA,iBAAd;AAAiCD,MAAAA,YAAjC;AAA+Cu9B,MAAAA;AAA/C,KAAf;;AACA,QAAIjgD,IAAI,CAAC4E,GAAL,CAAS,UAAT,CAAJ,EAA0B;AACxBiB,MAAAA,MAAM,CAAC06C,QAAP,GAAkBJ,qBAAqB,CAACngD,IAAI,CAAC6E,GAAL,CAAS,UAAT,CAAD,EAAuB8V,SAAvB,CAAvC;AACD,KAFD,MAEO,IAAI3a,IAAI,CAAC4E,GAAL,CAAS,aAAT,CAAJ,EAA6B;AAClCiB,MAAAA,MAAM,CAACkb,WAAP,GAAqBo/B,qBAAqB,CAACngD,IAAI,CAAC6E,GAAL,CAAS,aAAT,CAAD,EAA0B8V,SAA1B,CAA1C;AACD,KAFM,MAEA,IAAI3a,IAAI,CAAC4E,GAAL,CAAS,UAAT,CAAJ,EAA0B;AAC/BiB,MAAAA,MAAM,CAAC26C,QAAP,GAAkBL,qBAAqB,CAACngD,IAAI,CAAC6E,GAAL,CAAS,UAAT,CAAD,EAAuB8V,SAAvB,CAAvC;AACA9U,MAAAA,MAAM,CAACgV,IAAP,GAAcA,IAAd;AACD,KAHM,MAGA,IAAI7a,IAAI,CAAC4E,GAAL,CAAS,YAAT,CAAJ,EAA4B;AACjCiB,MAAAA,MAAM,CAAC46C,UAAP,GAAoB,IAAI1B,gBAAJ,CAAqB/+C,IAAI,CAAC6E,GAAL,CAAS,YAAT,CAArB,CAApB;AACAgB,MAAAA,MAAM,CAACgV,IAAP,GAAcA,IAAd;AACD;;AACD,WAAOhV,MAAP;AACD,GA5BM,MA4BA;AACL,UAAM,IAAI+Q,oBAAJ,CAAyBlB,SAAS,CAACmG,qBAAnC,EAA0DiC,SAAS,CAACpY,IAAV,CAAe,CAAf,CAA1D,EAA6E,mCAA7E,CAAN;AACD;AACF;;AACD,SAASy6C,qBAAT,CAA+B7zC,UAA/B,EAA2CqO,SAA3C,EAAsD;AACpD,QAAM+lC,eAAe,GAAG/hC,mBAAmB,CAACrS,UAAD,EAAaqO,SAAb,CAA3C;AACA,SAAOikC,gCAAgC,CAAC,IAAIG,gBAAJ,CAAqB2B,eAAe,IAAI,IAAnB,GAA0BA,eAA1B,GAA4Cp0C,UAAjE,CAAD,EAA+Eo0C,eAAe,KAAK,IAApB,GAA2B,CAA3B,GAA+B,CAA9G,CAAvC;AACD;;AACD,SAASnB,yBAAT,CAAmC7kC,KAAnC,EAA0C1a,IAA1C,EAAgD8d,SAAhD,EAA2DnD,SAA3D,EAAsEC,MAAtE,EAA8EskC,cAA9E,EAA8F;AAC5F,MAAIphC,SAAS,CAACpY,IAAV,KAAmB,IAAvB,EAA6B;AAC3B,UAAM,IAAIkR,oBAAJ,CAAyBlB,SAAS,CAACsqC,oBAAnC,EAAyD5/C,SAAS,CAAC0b,YAAV,CAAuBgC,SAAvB,CAAzD,EAA4F,4BAA5F,CAAN;AACD;;AACD,MAAIssB,QAAQ,GAAG,IAAf;;AACA,MAAItsB,SAAS,CAACpY,IAAV,CAAeC,MAAf,KAA0B,CAA9B,EAAiC;AAC/B,QAAIu5C,cAAJ,EAAoB;AAClB9U,MAAAA,QAAQ,GAAGztB,+BAA+B,CAACjC,KAAD,EAAQC,SAAR,EAAmBC,MAAnB,CAA1C;AACD,KAFD,MAEO;AACLwvB,MAAAA,QAAQ,GAAG1tB,6BAA6B,CAACjC,0BAA0B,CAACC,KAAD,EAAQC,SAAR,EAAmBC,MAAnB,CAA3B,CAAxC;AACD;;AACD,WAAOwvB,QAAP;AACD,GAPD,MAOO,IAAItsB,SAAS,CAACpY,IAAV,CAAeC,MAAf,KAA0B,CAA9B,EAAiC;AACtC,UAAMwkC,WAAW,GAAG1vB,0BAA0B,CAACC,KAAD,EAAQC,SAAR,EAAmBC,MAAnB,CAA9C;;AACA,QAAIskC,cAAc,IAAIl/C,IAAI,CAACugD,QAAL,KAAkB,KAAK,CAAzC,IAA8CvgD,IAAI,CAAC+gB,WAAL,KAAqB,KAAK,CAAxE,IAA6E/gB,IAAI,CAACwgD,QAAL,KAAkB,KAAK,CAApG,IAAyGxgD,IAAI,CAACygD,UAAL,KAAoB,KAAK,CAAtI,EAAyI;AACvIrW,MAAAA,QAAQ,GAAGxtB,+BAA+B,CAAClC,KAAD,EAAQyvB,WAAR,CAA1C;AACD,KAFD,MAEO;AACLC,MAAAA,QAAQ,GAAG1tB,6BAA6B,CAACytB,WAAD,CAAxC;AACD;AACF;;AACD,SAAOC,QAAP;AACD;;AACD,SAASkW,MAAT,CAAgBjW,GAAhB,EAAqB1vB,SAArB,EAAgC;AAC9B,QAAM3a,IAAI,GAAG;AACXkb,IAAAA,KAAK,EAAE,IAAI6jC,gBAAJ,CAAqB1U,GAArB,CADI;AAEXhvB,IAAAA,iBAAiB,EAAE,IAFR;AAGXrR,IAAAA,IAAI,EAAE,KAHK;AAIXsR,IAAAA,QAAQ,EAAE,KAJC;AAKXC,IAAAA,IAAI,EAAE,KALK;AAMXC,IAAAA,QAAQ,EAAE;AANC,GAAb;;AAQA,WAASmlC,oBAAT,CAA8BhlC,GAA9B,EAAmCilC,UAAnC,EAA+C1lC,KAA/C,EAAsD;AACpD,UAAM3U,MAAM,GAAGq6C,UAAU,CAACzyC,qBAAX,CAAiCwN,GAAjC,CAAf;;AACA,QAAIpV,MAAM,KAAK,IAAX,IAAmBA,MAAM,CAACM,IAAP,KAAgB,eAAvC,EAAwD;AACtD,aAAO,KAAP;AACD;;AACD,YAAQN,MAAM,CAAC5B,IAAf;AACE,WAAK,QAAL;AACE,YAAIuW,KAAK,KAAK,KAAK,CAAnB,EAAsB;AACpBlb,UAAAA,IAAI,CAACkb,KAAL,GAAa,IAAI6jC,gBAAJ,CAAqB7jC,KAArB,CAAb;AACD;;AACD;;AACF,WAAK,UAAL;AACElb,QAAAA,IAAI,CAACsb,QAAL,GAAgB,IAAhB;AACA;;AACF,WAAK,UAAL;AACEtb,QAAAA,IAAI,CAACwb,QAAL,GAAgB,IAAhB;AACA;;AACF,WAAK,MAAL;AACExb,QAAAA,IAAI,CAACub,IAAL,GAAY,IAAZ;AACA;;AACF;AACE,eAAO,KAAP;AAhBJ;;AAkBA,WAAO,IAAP;AACD;;AACD,MAAIyjC,IAAI,CAACjzC,wBAAL,CAA8Bs+B,GAA9B,CAAJ,EAAwC;AACtCA,IAAAA,GAAG,CAACz9B,QAAJ,CAAa3H,OAAb,CAAsB4kB,EAAD,IAAQ;AAC3B,UAAI6O,WAAW,GAAG,KAAlB;;AACA,UAAIsmB,IAAI,CAAC7zC,YAAL,CAAkB0e,EAAlB,CAAJ,EAA2B;AACzB6O,QAAAA,WAAW,GAAGioB,oBAAoB,CAAC92B,EAAD,EAAKlP,SAAL,CAAlC;AACD,OAFD,MAEO,IAAIqkC,IAAI,CAAClT,eAAL,CAAqBjiB,EAArB,KAA4Bm1B,IAAI,CAAC7zC,YAAL,CAAkB0e,EAAE,CAACvd,UAArB,CAAhC,EAAkE;AACvE,cAAM4O,KAAK,GAAG2O,EAAE,CAACpY,SAAH,IAAgBoY,EAAE,CAACpY,SAAH,CAAa9L,MAAb,GAAsB,CAAtC,IAA2CkkB,EAAE,CAACpY,SAAH,CAAa,CAAb,CAA3C,IAA8D,KAAK,CAAjF;AACAinB,QAAAA,WAAW,GAAGioB,oBAAoB,CAAC92B,EAAE,CAACvd,UAAJ,EAAgBqO,SAAhB,EAA2BO,KAA3B,CAAlC;AACD;;AACD,UAAI,CAACwd,WAAL,EAAkB;AAChB14B,QAAAA,IAAI,CAACkb,KAAL,GAAa,IAAI6jC,gBAAJ,CAAqBl1B,EAArB,CAAb;AACD;AACF,KAXD;AAYD;;AACD,SAAO7pB,IAAP;AACD,C,CAED;;;AACA,SAAS4iB,oBAAoB,IAAIi+B,qBAAjC,EAAwD99B,2BAA2B,IAAI+9B,4BAAvF,EAAqHC,8BAArH,EAAqJC,uBAArJ,EAA8K19B,aAAa,IAAI29B,cAA/L,EAA+M1mC,eAAe,IAAI2mC,gBAAlO,QAA0P,mBAA1P;AACA,OAAOC,IAAP,MAAiB,YAAjB;AACA,IAAIC,UAAU,GAAG,cAAcj9B,cAAd,CAA6B;AAC5CliB,EAAAA,WAAW,CAACiD,IAAD,EAAOP,IAAP,EAAa;AACtB,UAAMO,IAAN;AACA,SAAKP,IAAL,GAAYA,IAAZ;AACD;;AACD6f,EAAAA,mBAAmB,CAACO,cAAD,EAAiB;AAClC,QAAI,EAAEA,cAAc,YAAYq8B,UAA5B,CAAJ,EAA6C;AAC3C,aAAO,IAAP;AACD;;AACD,WAAO,KAAKz8C,IAAL,KAAcogB,cAAc,CAACpgB,IAApC;AACD;;AACD8f,EAAAA,sBAAsB,CAACM,cAAD,EAAiB;AACrC,WAAO,KAAKP,mBAAL,CAAyBO,cAAzB,CAAP;AACD;;AAb2C,CAA9C;AAeA,IAAIs8B,oBAAoB,GAAG,MAAM;AAC/Bp/C,EAAAA,WAAW,CAAC0Y,SAAD,EAAY2E,SAAZ,EAAuB+nB,YAAvB,EAAqC/E,aAArC,EAAoDiF,kBAApD,EAAwE3sB,MAAxE,EAAgFuY,IAAhF,EAAsF;AAC/F,SAAKxY,SAAL,GAAiBA,SAAjB;AACA,SAAK2E,SAAL,GAAiBA,SAAjB;AACA,SAAK+nB,YAAL,GAAoBA,YAApB;AACA,SAAK/E,aAAL,GAAqBA,aAArB;AACA,SAAKiF,kBAAL,GAA0BA,kBAA1B;AACA,SAAK3sB,MAAL,GAAcA,MAAd;AACA,SAAKuY,IAAL,GAAYA,IAAZ;AACA,SAAKgD,UAAL,GAAkBvF,iBAAiB,CAACwF,OAApC;AACA,SAAKzxB,IAAL,GAAY08C,oBAAoB,CAAC18C,IAAjC;AACD;;AACDsxB,EAAAA,MAAM,CAAC/zB,IAAD,EAAOuZ,UAAP,EAAmB;AACvB,QAAI,CAACA,UAAL,EAAiB;AACf,aAAO,KAAK,CAAZ;AACD;;AACD,UAAMqC,SAAS,GAAGK,oBAAoB,CAAC1C,UAAD,EAAa,MAAb,EAAqB,KAAKb,MAA1B,CAAtC;;AACA,QAAIkD,SAAS,KAAK,KAAK,CAAvB,EAA0B;AACxB,aAAO;AACL2a,QAAAA,OAAO,EAAE3a,SAAS,CAAC5b,IADd;AAEL4b,QAAAA,SAFK;AAGL8Y,QAAAA,QAAQ,EAAE9Y;AAHL,OAAP;AAKD,KAND,MAMO;AACL,aAAO,KAAK,CAAZ;AACD;AACF;;AACDgW,EAAAA,OAAO,CAACpZ,KAAD,EAAQoD,SAAR,EAAmB;AACxB,SAAKqV,IAAL,CAAUiB,UAAV,CAAqBxyB,SAAS,CAAC0/C,WAA/B;AACA,UAAM38C,IAAI,GAAG+V,KAAK,CAAC/V,IAAN,CAAWgG,IAAxB;AACA,UAAMmF,IAAI,GAAGqR,iBAAiB,CAAC,KAAKxG,SAAN,EAAiBD,KAAjB,CAA9B;AACA,UAAMgI,YAAY,GAAG,IAAIw+B,gBAAJ,CAAqB,KAAKvmC,SAAL,CAAe4vB,sBAAf,CAAsC7vB,KAAtC,CAArB,CAArB;;AACA,QAAIoD,SAAS,CAACpY,IAAV,KAAmB,IAAvB,EAA6B;AAC3B,YAAM,IAAIkR,oBAAJ,CAAyBlB,SAAS,CAACsqC,oBAAnC,EAAyD5/C,SAAS,CAAC0b,YAAV,CAAuBgC,SAAvB,CAAzD,EAA6F,sBAA7F,CAAN;AACD;;AACD,QAAIA,SAAS,CAACpY,IAAV,CAAeC,MAAf,KAA0B,CAA9B,EAAiC;AAC/B,YAAM,IAAIiR,oBAAJ,CAAyBlB,SAAS,CAACmG,qBAAnC,EAA0Dzb,SAAS,CAAC0b,YAAV,CAAuBgC,SAAvB,CAA1D,EAA6F,sCAA7F,CAAN;AACD;;AACD,UAAM9d,IAAI,GAAGqe,gBAAgB,CAACP,SAAS,CAACpY,IAAV,CAAe,CAAf,CAAD,CAA7B;;AACA,QAAI,CAACy7C,IAAI,CAACl2C,yBAAL,CAA+BjL,IAA/B,CAAL,EAA2C;AACzC,YAAM,IAAI4W,oBAAJ,CAAyBlB,SAAS,CAACI,yBAAnC,EAA8D9V,IAA9D,EAAoE,oCAApE,CAAN;AACD;;AACD,UAAMuyC,IAAI,GAAG9xC,oBAAoB,CAACT,IAAD,CAAjC;;AACA,QAAI,CAACuyC,IAAI,CAAC3tC,GAAL,CAAS,MAAT,CAAL,EAAuB;AACrB,YAAM,IAAIgS,oBAAJ,CAAyBlB,SAAS,CAAC6rC,iBAAnC,EAAsDvhD,IAAtD,EAA6D,uCAA7D,CAAN;AACD;;AACD,UAAMwhD,YAAY,GAAGjP,IAAI,CAAC1tC,GAAL,CAAS,MAAT,CAArB;AACA,UAAMq1C,QAAQ,GAAG,KAAK56B,SAAL,CAAe7a,QAAf,CAAwB+8C,YAAxB,CAAjB;;AACA,QAAI,OAAOtH,QAAP,KAAoB,QAAxB,EAAkC;AAChC,YAAMrY,4BAA4B,CAAC2f,YAAD,EAAetH,QAAf,EAA0B,6BAA1B,CAAlC;AACD;;AACD,QAAIuH,IAAI,GAAG,IAAX;;AACA,QAAIlP,IAAI,CAAC3tC,GAAL,CAAS,MAAT,CAAJ,EAAsB;AACpB,YAAM2M,IAAI,GAAGghC,IAAI,CAAC1tC,GAAL,CAAS,MAAT,CAAb;AACA,YAAM68C,SAAS,GAAG,KAAKpiC,SAAL,CAAe7a,QAAf,CAAwB8M,IAAxB,CAAlB;;AACA,UAAI,OAAOmwC,SAAP,KAAqB,SAAzB,EAAoC;AAClC,cAAM7f,4BAA4B,CAACtwB,IAAD,EAAOmwC,SAAP,EAAmB,8BAAnB,CAAlC;AACD;;AACDD,MAAAA,IAAI,GAAGC,SAAP;AACD;;AACD,WAAO;AACLvvB,MAAAA,QAAQ,EAAE;AACRnyB,QAAAA,IAAI,EAAE;AACJ2E,UAAAA,IADI;AAEJmL,UAAAA,IAFI;AAGJ4S,UAAAA,YAHI;AAIJC,UAAAA,iBAAiB,EAAE,KAAKhI,SAAL,CAAeoQ,sBAAf,CAAsCrQ,KAAtC,KAAgD,CAJ/D;AAKJw/B,UAAAA,QALI;AAMJr/B,UAAAA,IAAI,EAAE8B,+BAA+B,CAACjC,KAAD,EAAQ,KAAKC,SAAb,EAAwB,KAAKC,MAA7B,CANjC;AAOJ6mC,UAAAA;AAPI,SADE;AAURzZ,QAAAA,aAAa,EAAErD,oBAAoB,CAACjqB,KAAD,EAAQ,KAAKC,SAAb,EAAwB,KAAKC,MAA7B,CAV3B;AAWR4mC,QAAAA;AAXQ;AADL,KAAP;AAeD;;AACDl0C,EAAAA,MAAM,CAACpL,IAAD,EAAOiwB,QAAP,EAAiB;AACrB,WAAO,IAAIivB,UAAJ,CAAel/C,IAAf,EAAqBiwB,QAAQ,CAACnyB,IAAT,CAAc2E,IAAnC,CAAP;AACD;;AACDgxB,EAAAA,QAAQ,CAACzzB,IAAD,EAAOiwB,QAAP,EAAiB;AACvB,UAAM1vB,GAAG,GAAG,IAAI3B,SAAJ,CAAcoB,IAAd,CAAZ;AACA,SAAKmlC,YAAL,CAAkBxY,oBAAlB,CAAuC;AAAE/e,MAAAA,IAAI,EAAE2X,QAAQ,CAACyF,IAAjB;AAAuBzqB,MAAAA,GAAvB;AAA4BkC,MAAAA,IAAI,EAAEwtB,QAAQ,CAACnyB,IAAT,CAAck6C,QAAhD;AAA0D/sB,MAAAA,QAAQ,EAAEgF,QAAQ,CAACqvB;AAA7E,KAAvC;AACA,SAAKja,kBAAL,CAAwBpY,kBAAxB,CAA2CjtB,IAA3C;AACD;;AACD60B,EAAAA,OAAO,CAAC70B,IAAD,EAAO;AACZ,UAAMy/C,iBAAiB,GAAG,KAAKrf,aAAL,CAAmBI,wBAAnB,CAA4CxgC,IAA5C,CAA1B;;AACA,QAAIy/C,iBAAiB,KAAK,IAA1B,EAAgC;AAC9B,aAAO;AACLnvB,QAAAA,WAAW,EAAE,CAACvS,6BAA6B,CAAC/d,IAAD,EAAOy/C,iBAAP,EAA0B,MAA1B,CAA9B;AADR,OAAP;AAGD;;AACD,WAAO,EAAP;AACD;;AACDxpB,EAAAA,WAAW,CAACj2B,IAAD,EAAOiwB,QAAP,EAAiB;AAC1B,UAAM9P,GAAG,GAAG8hB,wBAAwB,CAAC1hB,iBAAiB,CAAC0P,QAAQ,CAACnyB,IAAV,EAAgBihD,cAAc,CAAC/zB,IAA/B,CAAlB,CAApC;AACA,UAAM5K,GAAG,GAAG0+B,uBAAuB,CAAC7uB,QAAQ,CAACnyB,IAAV,CAAnC;AACA,UAAMgoC,aAAa,GAAG7V,QAAQ,CAAC6V,aAAT,KAA2B,IAA3B,GAAkC6Y,qBAAqB,CAAC1uB,QAAQ,CAAC6V,aAAV,CAArB,CAA8CK,MAA9C,EAAlC,GAA2F,IAAjH;AACA,WAAOjmB,cAAc,CAACC,GAAD,EAAMC,GAAN,EAAW0lB,aAAX,EAA0B,YAA1B,CAArB;AACD;;AACD9P,EAAAA,cAAc,CAACh2B,IAAD,EAAOiwB,QAAP,EAAiB;AAC7B,UAAM9P,GAAG,GAAG+hB,qBAAqB,CAAC3hB,iBAAiB,CAAC0P,QAAQ,CAACnyB,IAAV,EAAgBihD,cAAc,CAAC/zB,IAA/B,CAAlB,CAAjC;AACA,UAAM5K,GAAG,GAAGy+B,8BAA8B,CAAC5uB,QAAQ,CAACnyB,IAAV,CAA1C;AACA,UAAMgoC,aAAa,GAAG7V,QAAQ,CAAC6V,aAAT,KAA2B,IAA3B,GAAkC8Y,4BAA4B,CAAC3uB,QAAQ,CAAC6V,aAAV,CAA5B,CAAqDK,MAArD,EAAlC,GAAkG,IAAxH;AACA,WAAOjmB,cAAc,CAACC,GAAD,EAAMC,GAAN,EAAW0lB,aAAX,EAA0B,YAA1B,CAArB;AACD;;AAxG8B,CAAjC,C,CA2GA;;AACA,IAAI4Z,sBAAsB,GAAG,MAAM;AACjC1gC,EAAAA,GAAG,CAAC3a,MAAD,EAAS,GAAGs7C,UAAZ,EAAwB,CAC1B;;AAFgC,CAAnC;AAKA,SACEnsC,SADF,EAEEE,2BAFF,EAGEW,uBAHF,EAIEG,WAJF,EAKEO,cALF,EAMES,sBANF,EAOEE,sBAPF,EAQEE,2BARF,EASEoN,uBATF,EAUEqG,sBAVF,EAWES,iBAXF,EAYE8B,iCAZF,EAaES,qBAbF,EAcEO,wBAdF,EAeEG,uBAfF,EAgBEK,gBAhBF,EAiBEttB,YAjBF,EAkBE+H,iBAlBF,EAmBEuL,gBAnBF,EAoBEob,eApBF,EAqBEI,YArBF,EAsBEG,qBAtBF,EAuBES,UAvBF,EAwBEuB,aAxBF,EAyBEgH,oBAzBF,EA0BEM,2BA1BF,EA2BEqD,mBA3BF,EA4BE/e,kBA5BF,EA6BEQ,aA7BF,EA8BE+nB,yBA9BF,EA+BE2H,wBA/BF,EAgCE2F,yBAhCF,EAiCEuK,0BAjCF,EAkCEoC,oBAlCF,EAmCEO,sBAnCF;AAqCA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["\n      import {createRequire as __cjsCompatRequire} from 'module';\n      const require = __cjsCompatRequire(import.meta.url);\n      const __ESM_IMPORT_META_URL__ = import.meta.url;\n    \nimport {\n  ClassMemberKind,\n  Decorator,\n  KnownDeclaration,\n  filterToMembersWithDecorator,\n  isConcreteDeclaration,\n  isNamedClassDeclaration,\n  reflectObjectLiteral,\n  reflectTypeEntityToDeclaration,\n  typeNodeToValueExpr\n} from \"./chunk-5QEO6HSG.js\";\nimport {\n  ImportFlags,\n  ImportManager,\n  Reference,\n  attachDefaultImportDeclaration,\n  createExportSpecifier,\n  getDefaultImportDeclaration,\n  getSourceFile,\n  identifierOfNode,\n  isDeclaration,\n  nodeDebugInfo,\n  translateExpression,\n  translateStatement,\n  translateType\n} from \"./chunk-C2DR5MYL.js\";\nimport {\n  absoluteFrom,\n  absoluteFromSourceFile,\n  relative\n} from \"./chunk-TI3THPMZ.js\";\nimport {\n  PerfEvent,\n  PerfPhase\n} from \"./chunk-J6CW3T62.js\";\nimport {\n  __spreadProps,\n  __spreadValues\n} from \"./chunk-XA5IZLLC.js\";\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/partial_evaluator/src/dynamic.mjs\nvar DynamicValue = class {\n  constructor(node, reason, code) {\n    this.node = node;\n    this.reason = reason;\n    this.code = code;\n  }\n  static fromDynamicInput(node, input) {\n    return new DynamicValue(node, input, 0);\n  }\n  static fromDynamicString(node) {\n    return new DynamicValue(node, void 0, 1);\n  }\n  static fromExternalReference(node, ref) {\n    return new DynamicValue(node, ref, 2);\n  }\n  static fromUnsupportedSyntax(node) {\n    return new DynamicValue(node, void 0, 3);\n  }\n  static fromUnknownIdentifier(node) {\n    return new DynamicValue(node, void 0, 4);\n  }\n  static fromInvalidExpressionType(node, value) {\n    return new DynamicValue(node, value, 5);\n  }\n  static fromComplexFunctionCall(node, fn) {\n    return new DynamicValue(node, fn, 6);\n  }\n  static fromDynamicType(node) {\n    return new DynamicValue(node, void 0, 7);\n  }\n  static fromUnknown(node) {\n    return new DynamicValue(node, void 0, 8);\n  }\n  isFromDynamicInput() {\n    return this.code === 0;\n  }\n  isFromDynamicString() {\n    return this.code === 1;\n  }\n  isFromExternalReference() {\n    return this.code === 2;\n  }\n  isFromUnsupportedSyntax() {\n    return this.code === 3;\n  }\n  isFromUnknownIdentifier() {\n    return this.code === 4;\n  }\n  isFromInvalidExpressionType() {\n    return this.code === 5;\n  }\n  isFromComplexFunctionCall() {\n    return this.code === 6;\n  }\n  isFromDynamicType() {\n    return this.code === 7;\n  }\n  isFromUnknown() {\n    return this.code === 8;\n  }\n  accept(visitor) {\n    switch (this.code) {\n      case 0:\n        return visitor.visitDynamicInput(this);\n      case 1:\n        return visitor.visitDynamicString(this);\n      case 2:\n        return visitor.visitExternalReference(this);\n      case 3:\n        return visitor.visitUnsupportedSyntax(this);\n      case 4:\n        return visitor.visitUnknownIdentifier(this);\n      case 5:\n        return visitor.visitInvalidExpressionType(this);\n      case 6:\n        return visitor.visitComplexFunctionCall(this);\n      case 7:\n        return visitor.visitDynamicType(this);\n      case 8:\n        return visitor.visitUnknown(this);\n    }\n  }\n};\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/partial_evaluator/src/interpreter.mjs\nimport ts from \"typescript\";\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/partial_evaluator/src/result.mjs\nvar ResolvedModule = class {\n  constructor(exports, evaluate) {\n    this.exports = exports;\n    this.evaluate = evaluate;\n  }\n  getExport(name) {\n    if (!this.exports.has(name)) {\n      return void 0;\n    }\n    return this.evaluate(this.exports.get(name));\n  }\n  getExports() {\n    const map = new Map();\n    this.exports.forEach((decl, name) => {\n      map.set(name, this.evaluate(decl));\n    });\n    return map;\n  }\n};\nvar EnumValue = class {\n  constructor(enumRef, name, resolved) {\n    this.enumRef = enumRef;\n    this.name = name;\n    this.resolved = resolved;\n  }\n};\nvar KnownFn = class {\n};\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/partial_evaluator/src/builtin.mjs\nvar ArraySliceBuiltinFn = class extends KnownFn {\n  constructor(lhs) {\n    super();\n    this.lhs = lhs;\n  }\n  evaluate(node, args) {\n    if (args.length === 0) {\n      return this.lhs;\n    } else {\n      return DynamicValue.fromUnknown(node);\n    }\n  }\n};\nvar ArrayConcatBuiltinFn = class extends KnownFn {\n  constructor(lhs) {\n    super();\n    this.lhs = lhs;\n  }\n  evaluate(node, args) {\n    const result = [...this.lhs];\n    for (const arg of args) {\n      if (arg instanceof DynamicValue) {\n        result.push(DynamicValue.fromDynamicInput(node, arg));\n      } else if (Array.isArray(arg)) {\n        result.push(...arg);\n      } else {\n        result.push(arg);\n      }\n    }\n    return result;\n  }\n};\nvar StringConcatBuiltinFn = class extends KnownFn {\n  constructor(lhs) {\n    super();\n    this.lhs = lhs;\n  }\n  evaluate(node, args) {\n    let result = this.lhs;\n    for (const arg of args) {\n      const resolved = arg instanceof EnumValue ? arg.resolved : arg;\n      if (typeof resolved === \"string\" || typeof resolved === \"number\" || typeof resolved === \"boolean\" || resolved == null) {\n        result = result.concat(resolved);\n      } else {\n        return DynamicValue.fromUnknown(node);\n      }\n    }\n    return result;\n  }\n};\nvar ObjectAssignBuiltinFn = class extends KnownFn {\n  evaluate(node, args) {\n    if (args.length === 0) {\n      return DynamicValue.fromUnsupportedSyntax(node);\n    }\n    for (const arg of args) {\n      if (arg instanceof DynamicValue) {\n        return DynamicValue.fromDynamicInput(node, arg);\n      } else if (!(arg instanceof Map)) {\n        return DynamicValue.fromUnsupportedSyntax(node);\n      }\n    }\n    const [target, ...sources] = args;\n    for (const source of sources) {\n      source.forEach((value, key) => target.set(key, value));\n    }\n    return target;\n  }\n};\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/partial_evaluator/src/ts_helpers.mjs\nvar AssignHelperFn = class extends ObjectAssignBuiltinFn {\n};\nvar SpreadHelperFn = class extends KnownFn {\n  evaluate(node, args) {\n    const result = [];\n    for (const arg of args) {\n      if (arg instanceof DynamicValue) {\n        result.push(DynamicValue.fromDynamicInput(node, arg));\n      } else if (Array.isArray(arg)) {\n        result.push(...arg);\n      } else {\n        result.push(arg);\n      }\n    }\n    return result;\n  }\n};\nvar SpreadArrayHelperFn = class extends KnownFn {\n  evaluate(node, args) {\n    if (args.length !== 2 && args.length !== 3) {\n      return DynamicValue.fromUnknown(node);\n    }\n    const [to, from] = args;\n    if (to instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, to);\n    } else if (from instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, from);\n    }\n    if (!Array.isArray(to)) {\n      return DynamicValue.fromInvalidExpressionType(node, to);\n    } else if (!Array.isArray(from)) {\n      return DynamicValue.fromInvalidExpressionType(node, from);\n    }\n    return to.concat(from);\n  }\n};\nvar ReadHelperFn = class extends KnownFn {\n  evaluate(node, args) {\n    if (args.length !== 1) {\n      return DynamicValue.fromUnknown(node);\n    }\n    const [value] = args;\n    if (value instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, value);\n    }\n    if (!Array.isArray(value)) {\n      return DynamicValue.fromInvalidExpressionType(node, value);\n    }\n    return value;\n  }\n};\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/partial_evaluator/src/known_declaration.mjs\nvar jsGlobalObjectValue = new Map([[\"assign\", new ObjectAssignBuiltinFn()]]);\nvar assignTsHelperFn = new AssignHelperFn();\nvar spreadTsHelperFn = new SpreadHelperFn();\nvar spreadArrayTsHelperFn = new SpreadArrayHelperFn();\nvar readTsHelperFn = new ReadHelperFn();\nfunction resolveKnownDeclaration(decl) {\n  switch (decl) {\n    case KnownDeclaration.JsGlobalObject:\n      return jsGlobalObjectValue;\n    case KnownDeclaration.TsHelperAssign:\n      return assignTsHelperFn;\n    case KnownDeclaration.TsHelperSpread:\n    case KnownDeclaration.TsHelperSpreadArrays:\n      return spreadTsHelperFn;\n    case KnownDeclaration.TsHelperSpreadArray:\n      return spreadArrayTsHelperFn;\n    case KnownDeclaration.TsHelperRead:\n      return readTsHelperFn;\n    default:\n      throw new Error(`Cannot resolve known declaration. Received: ${KnownDeclaration[decl]}.`);\n  }\n}\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/partial_evaluator/src/interpreter.mjs\nfunction literalBinaryOp(op) {\n  return { op, literal: true };\n}\nfunction referenceBinaryOp(op) {\n  return { op, literal: false };\n}\nvar BINARY_OPERATORS = new Map([\n  [ts.SyntaxKind.PlusToken, literalBinaryOp((a, b) => a + b)],\n  [ts.SyntaxKind.MinusToken, literalBinaryOp((a, b) => a - b)],\n  [ts.SyntaxKind.AsteriskToken, literalBinaryOp((a, b) => a * b)],\n  [ts.SyntaxKind.SlashToken, literalBinaryOp((a, b) => a / b)],\n  [ts.SyntaxKind.PercentToken, literalBinaryOp((a, b) => a % b)],\n  [ts.SyntaxKind.AmpersandToken, literalBinaryOp((a, b) => a & b)],\n  [ts.SyntaxKind.BarToken, literalBinaryOp((a, b) => a | b)],\n  [ts.SyntaxKind.CaretToken, literalBinaryOp((a, b) => a ^ b)],\n  [ts.SyntaxKind.LessThanToken, literalBinaryOp((a, b) => a < b)],\n  [ts.SyntaxKind.LessThanEqualsToken, literalBinaryOp((a, b) => a <= b)],\n  [ts.SyntaxKind.GreaterThanToken, literalBinaryOp((a, b) => a > b)],\n  [ts.SyntaxKind.GreaterThanEqualsToken, literalBinaryOp((a, b) => a >= b)],\n  [ts.SyntaxKind.EqualsEqualsToken, literalBinaryOp((a, b) => a == b)],\n  [ts.SyntaxKind.EqualsEqualsEqualsToken, literalBinaryOp((a, b) => a === b)],\n  [ts.SyntaxKind.ExclamationEqualsToken, literalBinaryOp((a, b) => a != b)],\n  [ts.SyntaxKind.ExclamationEqualsEqualsToken, literalBinaryOp((a, b) => a !== b)],\n  [ts.SyntaxKind.LessThanLessThanToken, literalBinaryOp((a, b) => a << b)],\n  [ts.SyntaxKind.GreaterThanGreaterThanToken, literalBinaryOp((a, b) => a >> b)],\n  [ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken, literalBinaryOp((a, b) => a >>> b)],\n  [ts.SyntaxKind.AsteriskAsteriskToken, literalBinaryOp((a, b) => Math.pow(a, b))],\n  [ts.SyntaxKind.AmpersandAmpersandToken, referenceBinaryOp((a, b) => a && b)],\n  [ts.SyntaxKind.BarBarToken, referenceBinaryOp((a, b) => a || b)]\n]);\nvar UNARY_OPERATORS = new Map([\n  [ts.SyntaxKind.TildeToken, (a) => ~a],\n  [ts.SyntaxKind.MinusToken, (a) => -a],\n  [ts.SyntaxKind.PlusToken, (a) => +a],\n  [ts.SyntaxKind.ExclamationToken, (a) => !a]\n]);\nvar StaticInterpreter = class {\n  constructor(host, checker, dependencyTracker) {\n    this.host = host;\n    this.checker = checker;\n    this.dependencyTracker = dependencyTracker;\n  }\n  visit(node, context) {\n    return this.visitExpression(node, context);\n  }\n  visitExpression(node, context) {\n    let result;\n    if (node.kind === ts.SyntaxKind.TrueKeyword) {\n      return true;\n    } else if (node.kind === ts.SyntaxKind.FalseKeyword) {\n      return false;\n    } else if (node.kind === ts.SyntaxKind.NullKeyword) {\n      return null;\n    } else if (ts.isStringLiteral(node)) {\n      return node.text;\n    } else if (ts.isNoSubstitutionTemplateLiteral(node)) {\n      return node.text;\n    } else if (ts.isTemplateExpression(node)) {\n      result = this.visitTemplateExpression(node, context);\n    } else if (ts.isNumericLiteral(node)) {\n      return parseFloat(node.text);\n    } else if (ts.isObjectLiteralExpression(node)) {\n      result = this.visitObjectLiteralExpression(node, context);\n    } else if (ts.isIdentifier(node)) {\n      result = this.visitIdentifier(node, context);\n    } else if (ts.isPropertyAccessExpression(node)) {\n      result = this.visitPropertyAccessExpression(node, context);\n    } else if (ts.isCallExpression(node)) {\n      result = this.visitCallExpression(node, context);\n    } else if (ts.isConditionalExpression(node)) {\n      result = this.visitConditionalExpression(node, context);\n    } else if (ts.isPrefixUnaryExpression(node)) {\n      result = this.visitPrefixUnaryExpression(node, context);\n    } else if (ts.isBinaryExpression(node)) {\n      result = this.visitBinaryExpression(node, context);\n    } else if (ts.isArrayLiteralExpression(node)) {\n      result = this.visitArrayLiteralExpression(node, context);\n    } else if (ts.isParenthesizedExpression(node)) {\n      result = this.visitParenthesizedExpression(node, context);\n    } else if (ts.isElementAccessExpression(node)) {\n      result = this.visitElementAccessExpression(node, context);\n    } else if (ts.isAsExpression(node)) {\n      result = this.visitExpression(node.expression, context);\n    } else if (ts.isNonNullExpression(node)) {\n      result = this.visitExpression(node.expression, context);\n    } else if (this.host.isClass(node)) {\n      result = this.visitDeclaration(node, context);\n    } else {\n      return DynamicValue.fromUnsupportedSyntax(node);\n    }\n    if (result instanceof DynamicValue && result.node !== node) {\n      return DynamicValue.fromDynamicInput(node, result);\n    }\n    return result;\n  }\n  visitArrayLiteralExpression(node, context) {\n    const array = [];\n    for (let i = 0; i < node.elements.length; i++) {\n      const element = node.elements[i];\n      if (ts.isSpreadElement(element)) {\n        array.push(...this.visitSpreadElement(element, context));\n      } else {\n        array.push(this.visitExpression(element, context));\n      }\n    }\n    return array;\n  }\n  visitObjectLiteralExpression(node, context) {\n    const map = new Map();\n    for (let i = 0; i < node.properties.length; i++) {\n      const property = node.properties[i];\n      if (ts.isPropertyAssignment(property)) {\n        const name = this.stringNameFromPropertyName(property.name, context);\n        if (name === void 0) {\n          return DynamicValue.fromDynamicInput(node, DynamicValue.fromDynamicString(property.name));\n        }\n        map.set(name, this.visitExpression(property.initializer, context));\n      } else if (ts.isShorthandPropertyAssignment(property)) {\n        const symbol = this.checker.getShorthandAssignmentValueSymbol(property);\n        if (symbol === void 0 || symbol.valueDeclaration === void 0) {\n          map.set(property.name.text, DynamicValue.fromUnknown(property));\n        } else {\n          map.set(property.name.text, this.visitDeclaration(symbol.valueDeclaration, context));\n        }\n      } else if (ts.isSpreadAssignment(property)) {\n        const spread = this.visitExpression(property.expression, context);\n        if (spread instanceof DynamicValue) {\n          return DynamicValue.fromDynamicInput(node, spread);\n        } else if (spread instanceof Map) {\n          spread.forEach((value, key) => map.set(key, value));\n        } else if (spread instanceof ResolvedModule) {\n          spread.getExports().forEach((value, key) => map.set(key, value));\n        } else {\n          return DynamicValue.fromDynamicInput(node, DynamicValue.fromInvalidExpressionType(property, spread));\n        }\n      } else {\n        return DynamicValue.fromUnknown(node);\n      }\n    }\n    return map;\n  }\n  visitTemplateExpression(node, context) {\n    const pieces = [node.head.text];\n    for (let i = 0; i < node.templateSpans.length; i++) {\n      const span = node.templateSpans[i];\n      const value = literal(this.visit(span.expression, context), () => DynamicValue.fromDynamicString(span.expression));\n      if (value instanceof DynamicValue) {\n        return DynamicValue.fromDynamicInput(node, value);\n      }\n      pieces.push(`${value}`, span.literal.text);\n    }\n    return pieces.join(\"\");\n  }\n  visitIdentifier(node, context) {\n    const decl = this.host.getDeclarationOfIdentifier(node);\n    if (decl === null) {\n      if (node.originalKeywordKind === ts.SyntaxKind.UndefinedKeyword) {\n        return void 0;\n      } else {\n        if (this.dependencyTracker !== null && this.host.getImportOfIdentifier(node) !== null) {\n          this.dependencyTracker.recordDependencyAnalysisFailure(context.originatingFile);\n        }\n        return DynamicValue.fromUnknownIdentifier(node);\n      }\n    }\n    if (decl.known !== null) {\n      return resolveKnownDeclaration(decl.known);\n    } else if (isConcreteDeclaration(decl) && decl.identity !== null && decl.identity.kind === 0) {\n      return this.getResolvedEnum(decl.node, decl.identity.enumMembers, context);\n    }\n    const declContext = __spreadValues(__spreadValues({}, context), joinModuleContext(context, node, decl));\n    const result = this.visitAmbiguousDeclaration(decl, declContext);\n    if (result instanceof Reference) {\n      if (!result.synthetic) {\n        result.addIdentifier(node);\n      }\n    } else if (result instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, result);\n    }\n    return result;\n  }\n  visitDeclaration(node, context) {\n    if (this.dependencyTracker !== null) {\n      this.dependencyTracker.addDependency(context.originatingFile, node.getSourceFile());\n    }\n    if (this.host.isClass(node)) {\n      return this.getReference(node, context);\n    } else if (ts.isVariableDeclaration(node)) {\n      return this.visitVariableDeclaration(node, context);\n    } else if (ts.isParameter(node) && context.scope.has(node)) {\n      return context.scope.get(node);\n    } else if (ts.isExportAssignment(node)) {\n      return this.visitExpression(node.expression, context);\n    } else if (ts.isEnumDeclaration(node)) {\n      return this.visitEnumDeclaration(node, context);\n    } else if (ts.isSourceFile(node)) {\n      return this.visitSourceFile(node, context);\n    } else if (ts.isBindingElement(node)) {\n      return this.visitBindingElement(node, context);\n    } else {\n      return this.getReference(node, context);\n    }\n  }\n  visitVariableDeclaration(node, context) {\n    const value = this.host.getVariableValue(node);\n    if (value !== null) {\n      return this.visitExpression(value, context);\n    } else if (isVariableDeclarationDeclared(node)) {\n      if (node.type !== void 0) {\n        const evaluatedType = this.visitType(node.type, context);\n        if (!(evaluatedType instanceof DynamicValue)) {\n          return evaluatedType;\n        }\n      }\n      return this.getReference(node, context);\n    } else {\n      return void 0;\n    }\n  }\n  visitEnumDeclaration(node, context) {\n    const enumRef = this.getReference(node, context);\n    const map = new Map();\n    node.members.forEach((member) => {\n      const name = this.stringNameFromPropertyName(member.name, context);\n      if (name !== void 0) {\n        const resolved = member.initializer && this.visit(member.initializer, context);\n        map.set(name, new EnumValue(enumRef, name, resolved));\n      }\n    });\n    return map;\n  }\n  visitElementAccessExpression(node, context) {\n    const lhs = this.visitExpression(node.expression, context);\n    if (lhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, lhs);\n    }\n    const rhs = this.visitExpression(node.argumentExpression, context);\n    if (rhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, rhs);\n    }\n    if (typeof rhs !== \"string\" && typeof rhs !== \"number\") {\n      return DynamicValue.fromInvalidExpressionType(node, rhs);\n    }\n    return this.accessHelper(node, lhs, rhs, context);\n  }\n  visitPropertyAccessExpression(node, context) {\n    const lhs = this.visitExpression(node.expression, context);\n    const rhs = node.name.text;\n    if (lhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, lhs);\n    }\n    return this.accessHelper(node, lhs, rhs, context);\n  }\n  visitSourceFile(node, context) {\n    const declarations = this.host.getExportsOfModule(node);\n    if (declarations === null) {\n      return DynamicValue.fromUnknown(node);\n    }\n    return new ResolvedModule(declarations, (decl) => {\n      if (decl.known !== null) {\n        return resolveKnownDeclaration(decl.known);\n      }\n      const declContext = __spreadValues(__spreadValues({}, context), joinModuleContext(context, node, decl));\n      return this.visitAmbiguousDeclaration(decl, declContext);\n    });\n  }\n  visitAmbiguousDeclaration(decl, declContext) {\n    return decl.kind === 1 && decl.implementation !== void 0 && !isDeclaration(decl.implementation) ? this.visitExpression(decl.implementation, declContext) : this.visitDeclaration(decl.node, declContext);\n  }\n  accessHelper(node, lhs, rhs, context) {\n    const strIndex = `${rhs}`;\n    if (lhs instanceof Map) {\n      if (lhs.has(strIndex)) {\n        return lhs.get(strIndex);\n      } else {\n        return void 0;\n      }\n    } else if (lhs instanceof ResolvedModule) {\n      return lhs.getExport(strIndex);\n    } else if (Array.isArray(lhs)) {\n      if (rhs === \"length\") {\n        return lhs.length;\n      } else if (rhs === \"slice\") {\n        return new ArraySliceBuiltinFn(lhs);\n      } else if (rhs === \"concat\") {\n        return new ArrayConcatBuiltinFn(lhs);\n      }\n      if (typeof rhs !== \"number\" || !Number.isInteger(rhs)) {\n        return DynamicValue.fromInvalidExpressionType(node, rhs);\n      }\n      return lhs[rhs];\n    } else if (typeof lhs === \"string\" && rhs === \"concat\") {\n      return new StringConcatBuiltinFn(lhs);\n    } else if (lhs instanceof Reference) {\n      const ref = lhs.node;\n      if (this.host.isClass(ref)) {\n        const module = owningModule(context, lhs.bestGuessOwningModule);\n        let value = void 0;\n        const member = this.host.getMembersOfClass(ref).find((member2) => member2.isStatic && member2.name === strIndex);\n        if (member !== void 0) {\n          if (member.value !== null) {\n            value = this.visitExpression(member.value, context);\n          } else if (member.implementation !== null) {\n            value = new Reference(member.implementation, module);\n          } else if (member.node) {\n            value = new Reference(member.node, module);\n          }\n        }\n        return value;\n      } else if (isDeclaration(ref)) {\n        return DynamicValue.fromDynamicInput(node, DynamicValue.fromExternalReference(ref, lhs));\n      }\n    } else if (lhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, lhs);\n    }\n    return DynamicValue.fromUnknown(node);\n  }\n  visitCallExpression(node, context) {\n    const lhs = this.visitExpression(node.expression, context);\n    if (lhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, lhs);\n    }\n    if (lhs instanceof KnownFn) {\n      return lhs.evaluate(node, this.evaluateFunctionArguments(node, context));\n    }\n    if (!(lhs instanceof Reference)) {\n      return DynamicValue.fromInvalidExpressionType(node.expression, lhs);\n    }\n    const fn = this.host.getDefinitionOfFunction(lhs.node);\n    if (fn === null) {\n      return DynamicValue.fromInvalidExpressionType(node.expression, lhs);\n    }\n    if (!isFunctionOrMethodReference(lhs)) {\n      return DynamicValue.fromInvalidExpressionType(node.expression, lhs);\n    }\n    if (fn.body === null) {\n      let expr = null;\n      if (context.foreignFunctionResolver) {\n        expr = context.foreignFunctionResolver(lhs, node.arguments);\n      }\n      if (expr === null) {\n        return DynamicValue.fromDynamicInput(node, DynamicValue.fromExternalReference(node.expression, lhs));\n      }\n      if (expr.getSourceFile() !== node.expression.getSourceFile() && lhs.bestGuessOwningModule !== null) {\n        context = __spreadProps(__spreadValues({}, context), {\n          absoluteModuleName: lhs.bestGuessOwningModule.specifier,\n          resolutionContext: lhs.bestGuessOwningModule.resolutionContext\n        });\n      }\n      return this.visitFfrExpression(expr, context);\n    }\n    let res = this.visitFunctionBody(node, fn, context);\n    if (res instanceof DynamicValue && context.foreignFunctionResolver !== void 0) {\n      const ffrExpr = context.foreignFunctionResolver(lhs, node.arguments);\n      if (ffrExpr !== null) {\n        const ffrRes = this.visitFfrExpression(ffrExpr, context);\n        if (!(ffrRes instanceof DynamicValue)) {\n          res = ffrRes;\n        }\n      }\n    }\n    return res;\n  }\n  visitFfrExpression(expr, context) {\n    const res = this.visitExpression(expr, context);\n    if (res instanceof Reference) {\n      res.synthetic = true;\n    }\n    return res;\n  }\n  visitFunctionBody(node, fn, context) {\n    if (fn.body === null) {\n      return DynamicValue.fromUnknown(node);\n    } else if (fn.body.length !== 1 || !ts.isReturnStatement(fn.body[0])) {\n      return DynamicValue.fromComplexFunctionCall(node, fn);\n    }\n    const ret = fn.body[0];\n    const args = this.evaluateFunctionArguments(node, context);\n    const newScope = new Map();\n    const calleeContext = __spreadProps(__spreadValues({}, context), { scope: newScope });\n    fn.parameters.forEach((param, index) => {\n      let arg = args[index];\n      if (param.node.dotDotDotToken !== void 0) {\n        arg = args.slice(index);\n      }\n      if (arg === void 0 && param.initializer !== null) {\n        arg = this.visitExpression(param.initializer, calleeContext);\n      }\n      newScope.set(param.node, arg);\n    });\n    return ret.expression !== void 0 ? this.visitExpression(ret.expression, calleeContext) : void 0;\n  }\n  visitConditionalExpression(node, context) {\n    const condition = this.visitExpression(node.condition, context);\n    if (condition instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, condition);\n    }\n    if (condition) {\n      return this.visitExpression(node.whenTrue, context);\n    } else {\n      return this.visitExpression(node.whenFalse, context);\n    }\n  }\n  visitPrefixUnaryExpression(node, context) {\n    const operatorKind = node.operator;\n    if (!UNARY_OPERATORS.has(operatorKind)) {\n      return DynamicValue.fromUnsupportedSyntax(node);\n    }\n    const op = UNARY_OPERATORS.get(operatorKind);\n    const value = this.visitExpression(node.operand, context);\n    if (value instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, value);\n    } else {\n      return op(value);\n    }\n  }\n  visitBinaryExpression(node, context) {\n    const tokenKind = node.operatorToken.kind;\n    if (!BINARY_OPERATORS.has(tokenKind)) {\n      return DynamicValue.fromUnsupportedSyntax(node);\n    }\n    const opRecord = BINARY_OPERATORS.get(tokenKind);\n    let lhs, rhs;\n    if (opRecord.literal) {\n      lhs = literal(this.visitExpression(node.left, context), (value) => DynamicValue.fromInvalidExpressionType(node.left, value));\n      rhs = literal(this.visitExpression(node.right, context), (value) => DynamicValue.fromInvalidExpressionType(node.right, value));\n    } else {\n      lhs = this.visitExpression(node.left, context);\n      rhs = this.visitExpression(node.right, context);\n    }\n    if (lhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, lhs);\n    } else if (rhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, rhs);\n    } else {\n      return opRecord.op(lhs, rhs);\n    }\n  }\n  visitParenthesizedExpression(node, context) {\n    return this.visitExpression(node.expression, context);\n  }\n  evaluateFunctionArguments(node, context) {\n    const args = [];\n    for (const arg of node.arguments) {\n      if (ts.isSpreadElement(arg)) {\n        args.push(...this.visitSpreadElement(arg, context));\n      } else {\n        args.push(this.visitExpression(arg, context));\n      }\n    }\n    return args;\n  }\n  visitSpreadElement(node, context) {\n    const spread = this.visitExpression(node.expression, context);\n    if (spread instanceof DynamicValue) {\n      return [DynamicValue.fromDynamicInput(node, spread)];\n    } else if (!Array.isArray(spread)) {\n      return [DynamicValue.fromInvalidExpressionType(node, spread)];\n    } else {\n      return spread;\n    }\n  }\n  visitBindingElement(node, context) {\n    const path = [];\n    let closestDeclaration = node;\n    while (ts.isBindingElement(closestDeclaration) || ts.isArrayBindingPattern(closestDeclaration) || ts.isObjectBindingPattern(closestDeclaration)) {\n      if (ts.isBindingElement(closestDeclaration)) {\n        path.unshift(closestDeclaration);\n      }\n      closestDeclaration = closestDeclaration.parent;\n    }\n    if (!ts.isVariableDeclaration(closestDeclaration) || closestDeclaration.initializer === void 0) {\n      return DynamicValue.fromUnknown(node);\n    }\n    let value = this.visit(closestDeclaration.initializer, context);\n    for (const element of path) {\n      let key;\n      if (ts.isArrayBindingPattern(element.parent)) {\n        key = element.parent.elements.indexOf(element);\n      } else {\n        const name = element.propertyName || element.name;\n        if (ts.isIdentifier(name)) {\n          key = name.text;\n        } else {\n          return DynamicValue.fromUnknown(element);\n        }\n      }\n      value = this.accessHelper(element, value, key, context);\n      if (value instanceof DynamicValue) {\n        return value;\n      }\n    }\n    return value;\n  }\n  stringNameFromPropertyName(node, context) {\n    if (ts.isIdentifier(node) || ts.isStringLiteral(node) || ts.isNumericLiteral(node)) {\n      return node.text;\n    } else if (ts.isComputedPropertyName(node)) {\n      const literal2 = this.visitExpression(node.expression, context);\n      return typeof literal2 === \"string\" ? literal2 : void 0;\n    } else {\n      return void 0;\n    }\n  }\n  getResolvedEnum(node, enumMembers, context) {\n    const enumRef = this.getReference(node, context);\n    const map = new Map();\n    enumMembers.forEach((member) => {\n      const name = this.stringNameFromPropertyName(member.name, context);\n      if (name !== void 0) {\n        const resolved = this.visit(member.initializer, context);\n        map.set(name, new EnumValue(enumRef, name, resolved));\n      }\n    });\n    return map;\n  }\n  getReference(node, context) {\n    return new Reference(node, owningModule(context));\n  }\n  visitType(node, context) {\n    if (ts.isLiteralTypeNode(node)) {\n      return this.visitExpression(node.literal, context);\n    } else if (ts.isTupleTypeNode(node)) {\n      return this.visitTupleType(node, context);\n    } else if (ts.isNamedTupleMember(node)) {\n      return this.visitType(node.type, context);\n    }\n    return DynamicValue.fromDynamicType(node);\n  }\n  visitTupleType(node, context) {\n    const res = [];\n    for (const elem of node.elements) {\n      res.push(this.visitType(elem, context));\n    }\n    return res;\n  }\n};\nfunction isFunctionOrMethodReference(ref) {\n  return ts.isFunctionDeclaration(ref.node) || ts.isMethodDeclaration(ref.node) || ts.isFunctionExpression(ref.node);\n}\nfunction literal(value, reject) {\n  if (value instanceof EnumValue) {\n    value = value.resolved;\n  }\n  if (value instanceof DynamicValue || value === null || value === void 0 || typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n    return value;\n  }\n  return reject(value);\n}\nfunction isVariableDeclarationDeclared(node) {\n  if (node.parent === void 0 || !ts.isVariableDeclarationList(node.parent)) {\n    return false;\n  }\n  const declList = node.parent;\n  if (declList.parent === void 0 || !ts.isVariableStatement(declList.parent)) {\n    return false;\n  }\n  const varStmt = declList.parent;\n  return varStmt.modifiers !== void 0 && varStmt.modifiers.some((mod) => mod.kind === ts.SyntaxKind.DeclareKeyword);\n}\nvar EMPTY = {};\nfunction joinModuleContext(existing, node, decl) {\n  if (decl.viaModule !== null && decl.viaModule !== existing.absoluteModuleName) {\n    return {\n      absoluteModuleName: decl.viaModule,\n      resolutionContext: node.getSourceFile().fileName\n    };\n  } else {\n    return EMPTY;\n  }\n}\nfunction owningModule(context, override = null) {\n  let specifier = context.absoluteModuleName;\n  if (override !== null) {\n    specifier = override.specifier;\n  }\n  if (specifier !== null) {\n    return {\n      specifier,\n      resolutionContext: context.resolutionContext\n    };\n  } else {\n    return null;\n  }\n}\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/partial_evaluator/src/interface.mjs\nvar PartialEvaluator = class {\n  constructor(host, checker, dependencyTracker) {\n    this.host = host;\n    this.checker = checker;\n    this.dependencyTracker = dependencyTracker;\n  }\n  evaluate(expr, foreignFunctionResolver) {\n    const interpreter = new StaticInterpreter(this.host, this.checker, this.dependencyTracker);\n    const sourceFile = expr.getSourceFile();\n    return interpreter.visit(expr, {\n      originatingFile: sourceFile,\n      absoluteModuleName: null,\n      resolutionContext: sourceFile.fileName,\n      scope: new Map(),\n      foreignFunctionResolver\n    });\n  }\n};\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/partial_evaluator/src/diagnostics.mjs\nimport ts3 from \"typescript\";\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/diagnostics/src/error_code.mjs\nvar ErrorCode;\n(function(ErrorCode2) {\n  ErrorCode2[ErrorCode2[\"DECORATOR_ARG_NOT_LITERAL\"] = 1001] = \"DECORATOR_ARG_NOT_LITERAL\";\n  ErrorCode2[ErrorCode2[\"DECORATOR_ARITY_WRONG\"] = 1002] = \"DECORATOR_ARITY_WRONG\";\n  ErrorCode2[ErrorCode2[\"DECORATOR_NOT_CALLED\"] = 1003] = \"DECORATOR_NOT_CALLED\";\n  ErrorCode2[ErrorCode2[\"DECORATOR_ON_ANONYMOUS_CLASS\"] = 1004] = \"DECORATOR_ON_ANONYMOUS_CLASS\";\n  ErrorCode2[ErrorCode2[\"DECORATOR_UNEXPECTED\"] = 1005] = \"DECORATOR_UNEXPECTED\";\n  ErrorCode2[ErrorCode2[\"DECORATOR_COLLISION\"] = 1006] = \"DECORATOR_COLLISION\";\n  ErrorCode2[ErrorCode2[\"VALUE_HAS_WRONG_TYPE\"] = 1010] = \"VALUE_HAS_WRONG_TYPE\";\n  ErrorCode2[ErrorCode2[\"VALUE_NOT_LITERAL\"] = 1011] = \"VALUE_NOT_LITERAL\";\n  ErrorCode2[ErrorCode2[\"COMPONENT_MISSING_TEMPLATE\"] = 2001] = \"COMPONENT_MISSING_TEMPLATE\";\n  ErrorCode2[ErrorCode2[\"PIPE_MISSING_NAME\"] = 2002] = \"PIPE_MISSING_NAME\";\n  ErrorCode2[ErrorCode2[\"PARAM_MISSING_TOKEN\"] = 2003] = \"PARAM_MISSING_TOKEN\";\n  ErrorCode2[ErrorCode2[\"DIRECTIVE_MISSING_SELECTOR\"] = 2004] = \"DIRECTIVE_MISSING_SELECTOR\";\n  ErrorCode2[ErrorCode2[\"UNDECORATED_PROVIDER\"] = 2005] = \"UNDECORATED_PROVIDER\";\n  ErrorCode2[ErrorCode2[\"DIRECTIVE_INHERITS_UNDECORATED_CTOR\"] = 2006] = \"DIRECTIVE_INHERITS_UNDECORATED_CTOR\";\n  ErrorCode2[ErrorCode2[\"UNDECORATED_CLASS_USING_ANGULAR_FEATURES\"] = 2007] = \"UNDECORATED_CLASS_USING_ANGULAR_FEATURES\";\n  ErrorCode2[ErrorCode2[\"COMPONENT_RESOURCE_NOT_FOUND\"] = 2008] = \"COMPONENT_RESOURCE_NOT_FOUND\";\n  ErrorCode2[ErrorCode2[\"COMPONENT_INVALID_SHADOW_DOM_SELECTOR\"] = 2009] = \"COMPONENT_INVALID_SHADOW_DOM_SELECTOR\";\n  ErrorCode2[ErrorCode2[\"SYMBOL_NOT_EXPORTED\"] = 3001] = \"SYMBOL_NOT_EXPORTED\";\n  ErrorCode2[ErrorCode2[\"SYMBOL_EXPORTED_UNDER_DIFFERENT_NAME\"] = 3002] = \"SYMBOL_EXPORTED_UNDER_DIFFERENT_NAME\";\n  ErrorCode2[ErrorCode2[\"IMPORT_CYCLE_DETECTED\"] = 3003] = \"IMPORT_CYCLE_DETECTED\";\n  ErrorCode2[ErrorCode2[\"CONFIG_FLAT_MODULE_NO_INDEX\"] = 4001] = \"CONFIG_FLAT_MODULE_NO_INDEX\";\n  ErrorCode2[ErrorCode2[\"CONFIG_STRICT_TEMPLATES_IMPLIES_FULL_TEMPLATE_TYPECHECK\"] = 4002] = \"CONFIG_STRICT_TEMPLATES_IMPLIES_FULL_TEMPLATE_TYPECHECK\";\n  ErrorCode2[ErrorCode2[\"HOST_BINDING_PARSE_ERROR\"] = 5001] = \"HOST_BINDING_PARSE_ERROR\";\n  ErrorCode2[ErrorCode2[\"TEMPLATE_PARSE_ERROR\"] = 5002] = \"TEMPLATE_PARSE_ERROR\";\n  ErrorCode2[ErrorCode2[\"NGMODULE_INVALID_DECLARATION\"] = 6001] = \"NGMODULE_INVALID_DECLARATION\";\n  ErrorCode2[ErrorCode2[\"NGMODULE_INVALID_IMPORT\"] = 6002] = \"NGMODULE_INVALID_IMPORT\";\n  ErrorCode2[ErrorCode2[\"NGMODULE_INVALID_EXPORT\"] = 6003] = \"NGMODULE_INVALID_EXPORT\";\n  ErrorCode2[ErrorCode2[\"NGMODULE_INVALID_REEXPORT\"] = 6004] = \"NGMODULE_INVALID_REEXPORT\";\n  ErrorCode2[ErrorCode2[\"NGMODULE_MODULE_WITH_PROVIDERS_MISSING_GENERIC\"] = 6005] = \"NGMODULE_MODULE_WITH_PROVIDERS_MISSING_GENERIC\";\n  ErrorCode2[ErrorCode2[\"NGMODULE_REEXPORT_NAME_COLLISION\"] = 6006] = \"NGMODULE_REEXPORT_NAME_COLLISION\";\n  ErrorCode2[ErrorCode2[\"NGMODULE_DECLARATION_NOT_UNIQUE\"] = 6007] = \"NGMODULE_DECLARATION_NOT_UNIQUE\";\n  ErrorCode2[ErrorCode2[\"NGMODULE_VE_DEPENDENCY_ON_IVY_LIB\"] = 6999] = \"NGMODULE_VE_DEPENDENCY_ON_IVY_LIB\";\n  ErrorCode2[ErrorCode2[\"SCHEMA_INVALID_ELEMENT\"] = 8001] = \"SCHEMA_INVALID_ELEMENT\";\n  ErrorCode2[ErrorCode2[\"SCHEMA_INVALID_ATTRIBUTE\"] = 8002] = \"SCHEMA_INVALID_ATTRIBUTE\";\n  ErrorCode2[ErrorCode2[\"MISSING_REFERENCE_TARGET\"] = 8003] = \"MISSING_REFERENCE_TARGET\";\n  ErrorCode2[ErrorCode2[\"MISSING_PIPE\"] = 8004] = \"MISSING_PIPE\";\n  ErrorCode2[ErrorCode2[\"WRITE_TO_READ_ONLY_VARIABLE\"] = 8005] = \"WRITE_TO_READ_ONLY_VARIABLE\";\n  ErrorCode2[ErrorCode2[\"DUPLICATE_VARIABLE_DECLARATION\"] = 8006] = \"DUPLICATE_VARIABLE_DECLARATION\";\n  ErrorCode2[ErrorCode2[\"SPLIT_TWO_WAY_BINDING\"] = 8007] = \"SPLIT_TWO_WAY_BINDING\";\n  ErrorCode2[ErrorCode2[\"INVALID_BANANA_IN_BOX\"] = 8101] = \"INVALID_BANANA_IN_BOX\";\n  ErrorCode2[ErrorCode2[\"NULLISH_COALESCING_NOT_NULLABLE\"] = 8102] = \"NULLISH_COALESCING_NOT_NULLABLE\";\n  ErrorCode2[ErrorCode2[\"INLINE_TCB_REQUIRED\"] = 8900] = \"INLINE_TCB_REQUIRED\";\n  ErrorCode2[ErrorCode2[\"INLINE_TYPE_CTOR_REQUIRED\"] = 8901] = \"INLINE_TYPE_CTOR_REQUIRED\";\n  ErrorCode2[ErrorCode2[\"INJECTABLE_DUPLICATE_PROV\"] = 9001] = \"INJECTABLE_DUPLICATE_PROV\";\n  ErrorCode2[ErrorCode2[\"SUGGEST_STRICT_TEMPLATES\"] = 10001] = \"SUGGEST_STRICT_TEMPLATES\";\n  ErrorCode2[ErrorCode2[\"SUGGEST_SUBOPTIMAL_TYPE_INFERENCE\"] = 10002] = \"SUGGEST_SUBOPTIMAL_TYPE_INFERENCE\";\n})(ErrorCode || (ErrorCode = {}));\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/diagnostics/src/docs.mjs\nvar COMPILER_ERRORS_WITH_GUIDES = new Set([\n  ErrorCode.DECORATOR_ARG_NOT_LITERAL,\n  ErrorCode.IMPORT_CYCLE_DETECTED,\n  ErrorCode.PARAM_MISSING_TOKEN,\n  ErrorCode.SCHEMA_INVALID_ELEMENT,\n  ErrorCode.SCHEMA_INVALID_ATTRIBUTE,\n  ErrorCode.MISSING_REFERENCE_TARGET,\n  ErrorCode.COMPONENT_INVALID_SHADOW_DOM_SELECTOR\n]);\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/diagnostics/src/error.mjs\nimport ts2 from \"typescript\";\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/diagnostics/src/util.mjs\nvar ERROR_CODE_MATCHER = /(\\u001b\\[\\d+m ?)TS-99(\\d+: ?\\u001b\\[\\d+m)/g;\nfunction replaceTsWithNgInErrors(errors) {\n  return errors.replace(ERROR_CODE_MATCHER, \"$1NG$2\");\n}\nfunction ngErrorCode(code) {\n  return parseInt(\"-99\" + code);\n}\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/diagnostics/src/error.mjs\nvar FatalDiagnosticError = class {\n  constructor(code, node, message, relatedInformation) {\n    this.code = code;\n    this.node = node;\n    this.message = message;\n    this.relatedInformation = relatedInformation;\n    this._isFatalDiagnosticError = true;\n  }\n  toDiagnostic() {\n    return makeDiagnostic(this.code, this.node, this.message, this.relatedInformation);\n  }\n};\nfunction makeDiagnostic(code, node, messageText, relatedInformation) {\n  node = ts2.getOriginalNode(node);\n  return {\n    category: ts2.DiagnosticCategory.Error,\n    code: ngErrorCode(code),\n    file: ts2.getOriginalNode(node).getSourceFile(),\n    start: node.getStart(void 0, false),\n    length: node.getWidth(),\n    messageText,\n    relatedInformation\n  };\n}\nfunction makeRelatedInformation(node, messageText) {\n  node = ts2.getOriginalNode(node);\n  return {\n    category: ts2.DiagnosticCategory.Message,\n    code: 0,\n    file: node.getSourceFile(),\n    start: node.getStart(),\n    length: node.getWidth(),\n    messageText\n  };\n}\nfunction isFatalDiagnosticError(err) {\n  return err._isFatalDiagnosticError === true;\n}\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/diagnostics/src/error_details_base_url.mjs\nvar ERROR_DETAILS_PAGE_BASE_URL = \"https://angular.io/errors\";\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/partial_evaluator/src/diagnostics.mjs\nfunction describeResolvedType(value, maxDepth = 1) {\n  var _a, _b;\n  if (value === null) {\n    return \"null\";\n  } else if (value === void 0) {\n    return \"undefined\";\n  } else if (typeof value === \"number\" || typeof value === \"boolean\" || typeof value === \"string\") {\n    return typeof value;\n  } else if (value instanceof Map) {\n    if (maxDepth === 0) {\n      return \"object\";\n    }\n    const entries = Array.from(value.entries()).map(([key, v]) => {\n      return `${quoteKey(key)}: ${describeResolvedType(v, maxDepth - 1)}`;\n    });\n    return entries.length > 0 ? `{ ${entries.join(\"; \")} }` : \"{}\";\n  } else if (value instanceof ResolvedModule) {\n    return \"(module)\";\n  } else if (value instanceof EnumValue) {\n    return (_a = value.enumRef.debugName) != null ? _a : \"(anonymous)\";\n  } else if (value instanceof Reference) {\n    return (_b = value.debugName) != null ? _b : \"(anonymous)\";\n  } else if (Array.isArray(value)) {\n    if (maxDepth === 0) {\n      return \"Array\";\n    }\n    return `[${value.map((v) => describeResolvedType(v, maxDepth - 1)).join(\", \")}]`;\n  } else if (value instanceof DynamicValue) {\n    return \"(not statically analyzable)\";\n  } else if (value instanceof KnownFn) {\n    return \"Function\";\n  } else {\n    return \"unknown\";\n  }\n}\nfunction quoteKey(key) {\n  if (/^[a-z0-9_]+$/i.test(key)) {\n    return key;\n  } else {\n    return `'${key.replace(/'/g, \"\\\\'\")}'`;\n  }\n}\nfunction traceDynamicValue(node, value) {\n  return value.accept(new TraceDynamicValueVisitor(node));\n}\nvar TraceDynamicValueVisitor = class {\n  constructor(node) {\n    this.node = node;\n    this.currentContainerNode = null;\n  }\n  visitDynamicInput(value) {\n    const trace = value.reason.accept(this);\n    if (this.shouldTrace(value.node)) {\n      const info = makeRelatedInformation(value.node, \"Unable to evaluate this expression statically.\");\n      trace.unshift(info);\n    }\n    return trace;\n  }\n  visitDynamicString(value) {\n    return [makeRelatedInformation(value.node, \"A string value could not be determined statically.\")];\n  }\n  visitExternalReference(value) {\n    const name = value.reason.debugName;\n    const description = name !== null ? `'${name}'` : \"an anonymous declaration\";\n    return [makeRelatedInformation(value.node, `A value for ${description} cannot be determined statically, as it is an external declaration.`)];\n  }\n  visitComplexFunctionCall(value) {\n    return [\n      makeRelatedInformation(value.node, \"Unable to evaluate function call of complex function. A function must have exactly one return statement.\"),\n      makeRelatedInformation(value.reason.node, \"Function is declared here.\")\n    ];\n  }\n  visitInvalidExpressionType(value) {\n    return [makeRelatedInformation(value.node, \"Unable to evaluate an invalid expression.\")];\n  }\n  visitUnknown(value) {\n    return [makeRelatedInformation(value.node, \"Unable to evaluate statically.\")];\n  }\n  visitUnknownIdentifier(value) {\n    return [makeRelatedInformation(value.node, \"Unknown reference.\")];\n  }\n  visitDynamicType(value) {\n    return [makeRelatedInformation(value.node, \"Dynamic type.\")];\n  }\n  visitUnsupportedSyntax(value) {\n    return [makeRelatedInformation(value.node, \"This syntax is not supported.\")];\n  }\n  shouldTrace(node) {\n    if (node === this.node) {\n      return false;\n    }\n    const container = getContainerNode(node);\n    if (container === this.currentContainerNode) {\n      return false;\n    }\n    this.currentContainerNode = container;\n    return true;\n  }\n};\nfunction getContainerNode(node) {\n  let currentNode = node;\n  while (currentNode !== void 0) {\n    switch (currentNode.kind) {\n      case ts3.SyntaxKind.ExpressionStatement:\n      case ts3.SyntaxKind.VariableStatement:\n      case ts3.SyntaxKind.ReturnStatement:\n      case ts3.SyntaxKind.IfStatement:\n      case ts3.SyntaxKind.SwitchStatement:\n      case ts3.SyntaxKind.DoStatement:\n      case ts3.SyntaxKind.WhileStatement:\n      case ts3.SyntaxKind.ForStatement:\n      case ts3.SyntaxKind.ForInStatement:\n      case ts3.SyntaxKind.ForOfStatement:\n      case ts3.SyntaxKind.ContinueStatement:\n      case ts3.SyntaxKind.BreakStatement:\n      case ts3.SyntaxKind.ThrowStatement:\n      case ts3.SyntaxKind.ObjectBindingPattern:\n      case ts3.SyntaxKind.ArrayBindingPattern:\n        return currentNode;\n    }\n    currentNode = currentNode.parent;\n  }\n  return node.getSourceFile();\n}\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/src/util.mjs\nimport { ExternalExpr, LiteralExpr, ParseLocation, ParseSourceFile, ParseSourceSpan, ReadPropExpr, WrappedNodeExpr } from \"@angular/compiler\";\nimport ts4 from \"typescript\";\nfunction getConstructorDependencies(clazz, reflector, isCore) {\n  const deps = [];\n  const errors = [];\n  let ctorParams = reflector.getConstructorParameters(clazz);\n  if (ctorParams === null) {\n    if (reflector.hasBaseClass(clazz)) {\n      return null;\n    } else {\n      ctorParams = [];\n    }\n  }\n  ctorParams.forEach((param, idx) => {\n    let token = valueReferenceToExpression(param.typeValueReference);\n    let attributeNameType = null;\n    let optional = false, self = false, skipSelf = false, host = false;\n    (param.decorators || []).filter((dec) => isCore || isAngularCore(dec)).forEach((dec) => {\n      const name = isCore || dec.import === null ? dec.name : dec.import.name;\n      if (name === \"Inject\") {\n        if (dec.args === null || dec.args.length !== 1) {\n          throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(dec), `Unexpected number of arguments to @Inject().`);\n        }\n        token = new WrappedNodeExpr(dec.args[0]);\n      } else if (name === \"Optional\") {\n        optional = true;\n      } else if (name === \"SkipSelf\") {\n        skipSelf = true;\n      } else if (name === \"Self\") {\n        self = true;\n      } else if (name === \"Host\") {\n        host = true;\n      } else if (name === \"Attribute\") {\n        if (dec.args === null || dec.args.length !== 1) {\n          throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(dec), `Unexpected number of arguments to @Attribute().`);\n        }\n        const attributeName = dec.args[0];\n        token = new WrappedNodeExpr(attributeName);\n        if (ts4.isStringLiteralLike(attributeName)) {\n          attributeNameType = new LiteralExpr(attributeName.text);\n        } else {\n          attributeNameType = new WrappedNodeExpr(ts4.createKeywordTypeNode(ts4.SyntaxKind.UnknownKeyword));\n        }\n      } else {\n        throw new FatalDiagnosticError(ErrorCode.DECORATOR_UNEXPECTED, Decorator.nodeForError(dec), `Unexpected decorator ${name} on parameter.`);\n      }\n    });\n    if (token === null) {\n      if (param.typeValueReference.kind !== 2) {\n        throw new Error(\"Illegal state: expected value reference to be unavailable if no token is present\");\n      }\n      errors.push({\n        index: idx,\n        param,\n        reason: param.typeValueReference.reason\n      });\n    } else {\n      deps.push({ token, attributeNameType, optional, self, skipSelf, host });\n    }\n  });\n  if (errors.length === 0) {\n    return { deps };\n  } else {\n    return { deps: null, errors };\n  }\n}\nfunction valueReferenceToExpression(valueRef) {\n  if (valueRef.kind === 2) {\n    return null;\n  } else if (valueRef.kind === 0) {\n    const expr = new WrappedNodeExpr(valueRef.expression);\n    if (valueRef.defaultImportStatement !== null) {\n      attachDefaultImportDeclaration(expr, valueRef.defaultImportStatement);\n    }\n    return expr;\n  } else {\n    let importExpr = new ExternalExpr({ moduleName: valueRef.moduleName, name: valueRef.importedName });\n    if (valueRef.nestedPath !== null) {\n      for (const property of valueRef.nestedPath) {\n        importExpr = new ReadPropExpr(importExpr, property);\n      }\n    }\n    return importExpr;\n  }\n}\nfunction unwrapConstructorDependencies(deps) {\n  if (deps === null) {\n    return null;\n  } else if (deps.deps !== null) {\n    return deps.deps;\n  } else {\n    return \"invalid\";\n  }\n}\nfunction getValidConstructorDependencies(clazz, reflector, isCore) {\n  return validateConstructorDependencies(clazz, getConstructorDependencies(clazz, reflector, isCore));\n}\nfunction validateConstructorDependencies(clazz, deps) {\n  if (deps === null) {\n    return null;\n  } else if (deps.deps !== null) {\n    return deps.deps;\n  } else {\n    const error = deps.errors[0];\n    throw createUnsuitableInjectionTokenError(clazz, error);\n  }\n}\nfunction createUnsuitableInjectionTokenError(clazz, error) {\n  const { param, index, reason } = error;\n  let chainMessage = void 0;\n  let hints = void 0;\n  switch (reason.kind) {\n    case 5:\n      chainMessage = \"Consider using the @Inject decorator to specify an injection token.\";\n      hints = [\n        makeRelatedInformation(reason.typeNode, \"This type is not supported as injection token.\")\n      ];\n      break;\n    case 1:\n      chainMessage = \"Consider using the @Inject decorator to specify an injection token.\";\n      hints = [\n        makeRelatedInformation(reason.typeNode, \"This type does not have a value, so it cannot be used as injection token.\")\n      ];\n      if (reason.decl !== null) {\n        hints.push(makeRelatedInformation(reason.decl, \"The type is declared here.\"));\n      }\n      break;\n    case 2:\n      chainMessage = \"Consider changing the type-only import to a regular import, or use the @Inject decorator to specify an injection token.\";\n      hints = [\n        makeRelatedInformation(reason.typeNode, \"This type is imported using a type-only import, which prevents it from being usable as an injection token.\"),\n        makeRelatedInformation(reason.node, \"The type-only import occurs here.\")\n      ];\n      break;\n    case 4:\n      chainMessage = \"Consider using the @Inject decorator to specify an injection token.\";\n      hints = [\n        makeRelatedInformation(reason.typeNode, \"This type corresponds with a namespace, which cannot be used as injection token.\"),\n        makeRelatedInformation(reason.importClause, \"The namespace import occurs here.\")\n      ];\n      break;\n    case 3:\n      chainMessage = \"The type should reference a known declaration.\";\n      hints = [makeRelatedInformation(reason.typeNode, \"This type could not be resolved.\")];\n      break;\n    case 0:\n      chainMessage = \"Consider adding a type to the parameter or use the @Inject decorator to specify an injection token.\";\n      break;\n  }\n  const chain = {\n    messageText: `No suitable injection token for parameter '${param.name || index}' of class '${clazz.name.text}'.`,\n    category: ts4.DiagnosticCategory.Error,\n    code: 0,\n    next: [{\n      messageText: chainMessage,\n      category: ts4.DiagnosticCategory.Message,\n      code: 0\n    }]\n  };\n  return new FatalDiagnosticError(ErrorCode.PARAM_MISSING_TOKEN, param.nameNode, chain, hints);\n}\nfunction toR3Reference(valueRef, typeRef, valueContext, typeContext, refEmitter) {\n  return {\n    value: refEmitter.emit(valueRef, valueContext).expression,\n    type: refEmitter.emit(typeRef, typeContext, ImportFlags.ForceNewImport | ImportFlags.AllowTypeImports).expression\n  };\n}\nfunction isAngularCore(decorator) {\n  return decorator.import !== null && decorator.import.from === \"@angular/core\";\n}\nfunction isAngularCoreReference(reference, symbolName) {\n  return reference.ownedByModuleGuess === \"@angular/core\" && reference.debugName === symbolName;\n}\nfunction findAngularDecorator(decorators, name, isCore) {\n  return decorators.find((decorator) => isAngularDecorator(decorator, name, isCore));\n}\nfunction isAngularDecorator(decorator, name, isCore) {\n  if (isCore) {\n    return decorator.name === name;\n  } else if (isAngularCore(decorator)) {\n    return decorator.import.name === name;\n  }\n  return false;\n}\nfunction unwrapExpression(node) {\n  while (ts4.isAsExpression(node) || ts4.isParenthesizedExpression(node)) {\n    node = node.expression;\n  }\n  return node;\n}\nfunction expandForwardRef(arg) {\n  arg = unwrapExpression(arg);\n  if (!ts4.isArrowFunction(arg) && !ts4.isFunctionExpression(arg)) {\n    return null;\n  }\n  const body = arg.body;\n  if (ts4.isBlock(body)) {\n    if (body.statements.length !== 1) {\n      return null;\n    }\n    const stmt = body.statements[0];\n    if (!ts4.isReturnStatement(stmt) || stmt.expression === void 0) {\n      return null;\n    }\n    return stmt.expression;\n  } else {\n    return body;\n  }\n}\nfunction tryUnwrapForwardRef(node, reflector) {\n  node = unwrapExpression(node);\n  if (!ts4.isCallExpression(node) || node.arguments.length !== 1) {\n    return null;\n  }\n  const fn = ts4.isPropertyAccessExpression(node.expression) ? node.expression.name : node.expression;\n  if (!ts4.isIdentifier(fn)) {\n    return null;\n  }\n  const expr = expandForwardRef(node.arguments[0]);\n  if (expr === null) {\n    return null;\n  }\n  const imp = reflector.getImportOfIdentifier(fn);\n  if (imp === null || imp.from !== \"@angular/core\" || imp.name !== \"forwardRef\") {\n    return null;\n  }\n  return expr;\n}\nfunction forwardRefResolver(ref, args) {\n  if (!isAngularCoreReference(ref, \"forwardRef\") || args.length !== 1) {\n    return null;\n  }\n  return expandForwardRef(args[0]);\n}\nfunction combineResolvers(resolvers) {\n  return (ref, args) => {\n    for (const resolver of resolvers) {\n      const resolved = resolver(ref, args);\n      if (resolved !== null) {\n        return resolved;\n      }\n    }\n    return null;\n  };\n}\nfunction isExpressionForwardReference(expr, context, contextSource) {\n  if (isWrappedTsNodeExpr(expr)) {\n    const node = ts4.getOriginalNode(expr.node);\n    return node.getSourceFile() === contextSource && context.pos < node.pos;\n  } else {\n    return false;\n  }\n}\nfunction isWrappedTsNodeExpr(expr) {\n  return expr instanceof WrappedNodeExpr;\n}\nfunction readBaseClass(node, reflector, evaluator) {\n  const baseExpression = reflector.getBaseClassExpression(node);\n  if (baseExpression !== null) {\n    const baseClass = evaluator.evaluate(baseExpression);\n    if (baseClass instanceof Reference && reflector.isClass(baseClass.node)) {\n      return baseClass;\n    } else {\n      return \"dynamic\";\n    }\n  }\n  return null;\n}\nvar parensWrapperTransformerFactory = (context) => {\n  const visitor = (node) => {\n    const visited = ts4.visitEachChild(node, visitor, context);\n    if (ts4.isArrowFunction(visited) || ts4.isFunctionExpression(visited)) {\n      return ts4.createParen(visited);\n    }\n    return visited;\n  };\n  return (node) => ts4.visitEachChild(node, visitor, context);\n};\nfunction wrapFunctionExpressionsInParens(expression) {\n  return ts4.transform(expression, [parensWrapperTransformerFactory]).transformed[0];\n}\nfunction makeDuplicateDeclarationError(node, data, kind) {\n  const context = [];\n  for (const decl of data) {\n    if (decl.rawDeclarations === null) {\n      continue;\n    }\n    const contextNode = decl.ref.getOriginForDiagnostics(decl.rawDeclarations, decl.ngModule.name);\n    context.push(makeRelatedInformation(contextNode, `'${node.name.text}' is listed in the declarations of the NgModule '${decl.ngModule.name.text}'.`));\n  }\n  return makeDiagnostic(ErrorCode.NGMODULE_DECLARATION_NOT_UNIQUE, node.name, `The ${kind} '${node.name.text}' is declared by more than one NgModule.`, context);\n}\nfunction resolveProvidersRequiringFactory(rawProviders, reflector, evaluator) {\n  const providers = new Set();\n  const resolvedProviders = evaluator.evaluate(rawProviders);\n  if (!Array.isArray(resolvedProviders)) {\n    return providers;\n  }\n  resolvedProviders.forEach(function processProviders(provider) {\n    let tokenClass = null;\n    if (Array.isArray(provider)) {\n      provider.forEach(processProviders);\n    } else if (provider instanceof Reference) {\n      tokenClass = provider;\n    } else if (provider instanceof Map && provider.has(\"useClass\") && !provider.has(\"deps\")) {\n      const useExisting = provider.get(\"useClass\");\n      if (useExisting instanceof Reference) {\n        tokenClass = useExisting;\n      }\n    }\n    if (tokenClass !== null && !tokenClass.node.getSourceFile().isDeclarationFile && reflector.isClass(tokenClass.node)) {\n      const constructorParameters = reflector.getConstructorParameters(tokenClass.node);\n      if (constructorParameters !== null && constructorParameters.length > 0) {\n        providers.add(tokenClass);\n      }\n    }\n  });\n  return providers;\n}\nfunction wrapTypeReference(reflector, clazz) {\n  const dtsClass = reflector.getDtsDeclaration(clazz);\n  const value = new WrappedNodeExpr(clazz.name);\n  const type = dtsClass !== null && isNamedClassDeclaration(dtsClass) ? new WrappedNodeExpr(dtsClass.name) : value;\n  return { value, type };\n}\nfunction createSourceSpan(node) {\n  const sf = node.getSourceFile();\n  const [startOffset, endOffset] = [node.getStart(), node.getEnd()];\n  const { line: startLine, character: startCol } = sf.getLineAndCharacterOfPosition(startOffset);\n  const { line: endLine, character: endCol } = sf.getLineAndCharacterOfPosition(endOffset);\n  const parseSf = new ParseSourceFile(sf.getFullText(), sf.fileName);\n  return new ParseSourceSpan(new ParseLocation(parseSf, startOffset, startLine + 1, startCol + 1), new ParseLocation(parseSf, endOffset, endLine + 1, endCol + 1));\n}\nfunction compileResults(fac, def, metadataStmt, propName) {\n  const statements = def.statements;\n  if (metadataStmt !== null) {\n    statements.push(metadataStmt);\n  }\n  return [\n    fac,\n    {\n      name: propName,\n      initializer: def.expression,\n      statements: def.statements,\n      type: def.type\n    }\n  ];\n}\nfunction toFactoryMetadata(meta, target) {\n  return {\n    name: meta.name,\n    type: meta.type,\n    internalType: meta.internalType,\n    typeArgumentCount: meta.typeArgumentCount,\n    deps: meta.deps,\n    target\n  };\n}\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/src/component.mjs\nimport { compileClassMetadata as compileClassMetadata3, compileComponentFromMetadata, compileDeclareClassMetadata as compileDeclareClassMetadata3, compileDeclareComponentFromMetadata, CssSelector, DEFAULT_INTERPOLATION_CONFIG, DomElementSchemaRegistry, ExternalExpr as ExternalExpr5, FactoryTarget as FactoryTarget3, InterpolationConfig, makeBindingParser as makeBindingParser2, ParseSourceFile as ParseSourceFile2, parseTemplate, R3TargetBinder, SelectorMatcher, ViewEncapsulation, WrappedNodeExpr as WrappedNodeExpr5 } from \"@angular/compiler\";\nimport ts19 from \"typescript\";\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/incremental/semantic_graph/src/api.mjs\nimport ts5 from \"typescript\";\nvar SemanticSymbol = class {\n  constructor(decl) {\n    this.decl = decl;\n    this.path = absoluteFromSourceFile(decl.getSourceFile());\n    this.identifier = getSymbolIdentifier(decl);\n  }\n};\nfunction getSymbolIdentifier(decl) {\n  if (!ts5.isSourceFile(decl.parent)) {\n    return null;\n  }\n  return decl.name.text;\n}\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/incremental/semantic_graph/src/graph.mjs\nimport { ExternalExpr as ExternalExpr2 } from \"@angular/compiler\";\nvar OpaqueSymbol = class extends SemanticSymbol {\n  isPublicApiAffected() {\n    return false;\n  }\n  isTypeCheckApiAffected() {\n    return false;\n  }\n};\nvar SemanticDepGraph = class {\n  constructor() {\n    this.files = new Map();\n    this.symbolByDecl = new Map();\n  }\n  registerSymbol(symbol) {\n    this.symbolByDecl.set(symbol.decl, symbol);\n    if (symbol.identifier !== null) {\n      if (!this.files.has(symbol.path)) {\n        this.files.set(symbol.path, new Map());\n      }\n      this.files.get(symbol.path).set(symbol.identifier, symbol);\n    }\n  }\n  getEquivalentSymbol(symbol) {\n    let previousSymbol = this.getSymbolByDecl(symbol.decl);\n    if (previousSymbol === null && symbol.identifier !== null) {\n      previousSymbol = this.getSymbolByName(symbol.path, symbol.identifier);\n    }\n    return previousSymbol;\n  }\n  getSymbolByName(path, identifier) {\n    if (!this.files.has(path)) {\n      return null;\n    }\n    const file = this.files.get(path);\n    if (!file.has(identifier)) {\n      return null;\n    }\n    return file.get(identifier);\n  }\n  getSymbolByDecl(decl) {\n    if (!this.symbolByDecl.has(decl)) {\n      return null;\n    }\n    return this.symbolByDecl.get(decl);\n  }\n};\nvar SemanticDepGraphUpdater = class {\n  constructor(priorGraph) {\n    this.priorGraph = priorGraph;\n    this.newGraph = new SemanticDepGraph();\n    this.opaqueSymbols = new Map();\n  }\n  registerSymbol(symbol) {\n    this.newGraph.registerSymbol(symbol);\n  }\n  finalize() {\n    if (this.priorGraph === null) {\n      return {\n        needsEmit: new Set(),\n        needsTypeCheckEmit: new Set(),\n        newGraph: this.newGraph\n      };\n    }\n    const needsEmit = this.determineInvalidatedFiles(this.priorGraph);\n    const needsTypeCheckEmit = this.determineInvalidatedTypeCheckFiles(this.priorGraph);\n    return {\n      needsEmit,\n      needsTypeCheckEmit,\n      newGraph: this.newGraph\n    };\n  }\n  determineInvalidatedFiles(priorGraph) {\n    const isPublicApiAffected = new Set();\n    for (const symbol of this.newGraph.symbolByDecl.values()) {\n      const previousSymbol = priorGraph.getEquivalentSymbol(symbol);\n      if (previousSymbol === null || symbol.isPublicApiAffected(previousSymbol)) {\n        isPublicApiAffected.add(symbol);\n      }\n    }\n    const needsEmit = new Set();\n    for (const symbol of this.newGraph.symbolByDecl.values()) {\n      if (symbol.isEmitAffected === void 0) {\n        continue;\n      }\n      const previousSymbol = priorGraph.getEquivalentSymbol(symbol);\n      if (previousSymbol === null || symbol.isEmitAffected(previousSymbol, isPublicApiAffected)) {\n        needsEmit.add(symbol.path);\n      }\n    }\n    return needsEmit;\n  }\n  determineInvalidatedTypeCheckFiles(priorGraph) {\n    const isTypeCheckApiAffected = new Set();\n    for (const symbol of this.newGraph.symbolByDecl.values()) {\n      const previousSymbol = priorGraph.getEquivalentSymbol(symbol);\n      if (previousSymbol === null || symbol.isTypeCheckApiAffected(previousSymbol)) {\n        isTypeCheckApiAffected.add(symbol);\n      }\n    }\n    const needsTypeCheckEmit = new Set();\n    for (const symbol of this.newGraph.symbolByDecl.values()) {\n      if (symbol.isTypeCheckBlockAffected === void 0) {\n        continue;\n      }\n      const previousSymbol = priorGraph.getEquivalentSymbol(symbol);\n      if (previousSymbol === null || symbol.isTypeCheckBlockAffected(previousSymbol, isTypeCheckApiAffected)) {\n        needsTypeCheckEmit.add(symbol.path);\n      }\n    }\n    return needsTypeCheckEmit;\n  }\n  getSemanticReference(decl, expr) {\n    return {\n      symbol: this.getSymbol(decl),\n      importPath: getImportPath(expr)\n    };\n  }\n  getSymbol(decl) {\n    const symbol = this.newGraph.getSymbolByDecl(decl);\n    if (symbol === null) {\n      return this.getOpaqueSymbol(decl);\n    }\n    return symbol;\n  }\n  getOpaqueSymbol(decl) {\n    if (this.opaqueSymbols.has(decl)) {\n      return this.opaqueSymbols.get(decl);\n    }\n    const symbol = new OpaqueSymbol(decl);\n    this.opaqueSymbols.set(decl, symbol);\n    return symbol;\n  }\n};\nfunction getImportPath(expr) {\n  if (expr instanceof ExternalExpr2) {\n    return `${expr.value.moduleName}$${expr.value.name}`;\n  } else {\n    return null;\n  }\n}\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/incremental/semantic_graph/src/type_parameters.mjs\nimport ts6 from \"typescript\";\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/incremental/semantic_graph/src/util.mjs\nfunction isSymbolEqual(a, b) {\n  if (a.decl === b.decl) {\n    return true;\n  }\n  if (a.identifier === null || b.identifier === null) {\n    return false;\n  }\n  return a.path === b.path && a.identifier === b.identifier;\n}\nfunction isReferenceEqual(a, b) {\n  if (!isSymbolEqual(a.symbol, b.symbol)) {\n    return false;\n  }\n  return a.importPath === b.importPath;\n}\nfunction referenceEquality(a, b) {\n  return a === b;\n}\nfunction isArrayEqual(a, b, equalityTester = referenceEquality) {\n  if (a === null || b === null) {\n    return a === b;\n  }\n  if (a.length !== b.length) {\n    return false;\n  }\n  return !a.some((item, index) => !equalityTester(item, b[index]));\n}\nfunction isSetEqual(a, b, equalityTester = referenceEquality) {\n  if (a === null || b === null) {\n    return a === b;\n  }\n  if (a.size !== b.size) {\n    return false;\n  }\n  for (const itemA of a) {\n    let found = false;\n    for (const itemB of b) {\n      if (equalityTester(itemA, itemB)) {\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/incremental/semantic_graph/src/type_parameters.mjs\nfunction extractSemanticTypeParameters(node) {\n  if (!ts6.isClassDeclaration(node) || node.typeParameters === void 0) {\n    return null;\n  }\n  return node.typeParameters.map((typeParam) => ({ hasGenericTypeBound: typeParam.constraint !== void 0 }));\n}\nfunction areTypeParametersEqual(current, previous) {\n  if (!isArrayEqual(current, previous, isTypeParameterEqual)) {\n    return false;\n  }\n  if (current !== null && current.some((typeParam) => typeParam.hasGenericTypeBound)) {\n    return false;\n  }\n  return true;\n}\nfunction isTypeParameterEqual(a, b) {\n  return a.hasGenericTypeBound === b.hasGenericTypeBound;\n}\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/api.mjs\nvar MetaType;\n(function(MetaType2) {\n  MetaType2[MetaType2[\"Pipe\"] = 0] = \"Pipe\";\n  MetaType2[MetaType2[\"Directive\"] = 1] = \"Directive\";\n})(MetaType || (MetaType = {}));\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/dts.mjs\nimport ts8 from \"typescript\";\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/property_mapping.mjs\nvar ClassPropertyMapping = class {\n  constructor(forwardMap) {\n    this.forwardMap = forwardMap;\n    this.reverseMap = reverseMapFromForwardMap(forwardMap);\n  }\n  static empty() {\n    return new ClassPropertyMapping(new Map());\n  }\n  static fromMappedObject(obj) {\n    const forwardMap = new Map();\n    for (const classPropertyName of Object.keys(obj)) {\n      const value = obj[classPropertyName];\n      const bindingPropertyName = Array.isArray(value) ? value[0] : value;\n      const inputOrOutput = { classPropertyName, bindingPropertyName };\n      forwardMap.set(classPropertyName, inputOrOutput);\n    }\n    return new ClassPropertyMapping(forwardMap);\n  }\n  static merge(a, b) {\n    const forwardMap = new Map(a.forwardMap.entries());\n    for (const [classPropertyName, inputOrOutput] of b.forwardMap) {\n      forwardMap.set(classPropertyName, inputOrOutput);\n    }\n    return new ClassPropertyMapping(forwardMap);\n  }\n  get classPropertyNames() {\n    return Array.from(this.forwardMap.keys());\n  }\n  get propertyNames() {\n    return Array.from(this.reverseMap.keys());\n  }\n  hasBindingPropertyName(propertyName) {\n    return this.reverseMap.has(propertyName);\n  }\n  getByBindingPropertyName(propertyName) {\n    return this.reverseMap.has(propertyName) ? this.reverseMap.get(propertyName) : null;\n  }\n  getByClassPropertyName(classPropertyName) {\n    return this.forwardMap.has(classPropertyName) ? this.forwardMap.get(classPropertyName) : null;\n  }\n  toDirectMappedObject() {\n    const obj = {};\n    for (const [classPropertyName, inputOrOutput] of this.forwardMap) {\n      obj[classPropertyName] = inputOrOutput.bindingPropertyName;\n    }\n    return obj;\n  }\n  toJointMappedObject() {\n    const obj = {};\n    for (const [classPropertyName, inputOrOutput] of this.forwardMap) {\n      if (inputOrOutput.bindingPropertyName === classPropertyName) {\n        obj[classPropertyName] = inputOrOutput.bindingPropertyName;\n      } else {\n        obj[classPropertyName] = [inputOrOutput.bindingPropertyName, classPropertyName];\n      }\n    }\n    return obj;\n  }\n  *[Symbol.iterator]() {\n    for (const [classPropertyName, inputOrOutput] of this.forwardMap.entries()) {\n      yield [classPropertyName, inputOrOutput.bindingPropertyName];\n    }\n  }\n};\nfunction reverseMapFromForwardMap(forwardMap) {\n  const reverseMap = new Map();\n  for (const [_, inputOrOutput] of forwardMap) {\n    if (!reverseMap.has(inputOrOutput.bindingPropertyName)) {\n      reverseMap.set(inputOrOutput.bindingPropertyName, []);\n    }\n    reverseMap.get(inputOrOutput.bindingPropertyName).push(inputOrOutput);\n  }\n  return reverseMap;\n}\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/util.mjs\nimport ts7 from \"typescript\";\nfunction extractReferencesFromType(checker, def, bestGuessOwningModule) {\n  if (!ts7.isTupleTypeNode(def)) {\n    return [];\n  }\n  return def.elements.map((element) => {\n    if (!ts7.isTypeQueryNode(element)) {\n      throw new Error(`Expected TypeQueryNode: ${nodeDebugInfo(element)}`);\n    }\n    const type = element.exprName;\n    const { node, from } = reflectTypeEntityToDeclaration(type, checker);\n    if (!isNamedClassDeclaration(node)) {\n      throw new Error(`Expected named ClassDeclaration: ${nodeDebugInfo(node)}`);\n    }\n    if (from !== null && !from.startsWith(\".\")) {\n      return new Reference(node, { specifier: from, resolutionContext: def.getSourceFile().fileName });\n    } else {\n      return new Reference(node, bestGuessOwningModule);\n    }\n  });\n}\nfunction readStringType(type) {\n  if (!ts7.isLiteralTypeNode(type) || !ts7.isStringLiteral(type.literal)) {\n    return null;\n  }\n  return type.literal.text;\n}\nfunction readStringMapType(type) {\n  if (!ts7.isTypeLiteralNode(type)) {\n    return {};\n  }\n  const obj = {};\n  type.members.forEach((member) => {\n    if (!ts7.isPropertySignature(member) || member.type === void 0 || member.name === void 0 || !ts7.isStringLiteral(member.name)) {\n      return;\n    }\n    const value = readStringType(member.type);\n    if (value === null) {\n      return null;\n    }\n    obj[member.name.text] = value;\n  });\n  return obj;\n}\nfunction readStringArrayType(type) {\n  if (!ts7.isTupleTypeNode(type)) {\n    return [];\n  }\n  const res = [];\n  type.elements.forEach((el) => {\n    if (!ts7.isLiteralTypeNode(el) || !ts7.isStringLiteral(el.literal)) {\n      return;\n    }\n    res.push(el.literal.text);\n  });\n  return res;\n}\nfunction extractDirectiveTypeCheckMeta(node, inputs, reflector) {\n  const members = reflector.getMembersOfClass(node);\n  const staticMembers = members.filter((member) => member.isStatic);\n  const ngTemplateGuards = staticMembers.map(extractTemplateGuard).filter((guard) => guard !== null);\n  const hasNgTemplateContextGuard = staticMembers.some((member) => member.kind === ClassMemberKind.Method && member.name === \"ngTemplateContextGuard\");\n  const coercedInputFields = new Set(staticMembers.map(extractCoercedInput).filter((inputName) => inputName !== null));\n  const restrictedInputFields = new Set();\n  const stringLiteralInputFields = new Set();\n  const undeclaredInputFields = new Set();\n  for (const classPropertyName of inputs.classPropertyNames) {\n    const field = members.find((member) => member.name === classPropertyName);\n    if (field === void 0 || field.node === null) {\n      undeclaredInputFields.add(classPropertyName);\n      continue;\n    }\n    if (isRestricted(field.node)) {\n      restrictedInputFields.add(classPropertyName);\n    }\n    if (field.nameNode !== null && ts7.isStringLiteral(field.nameNode)) {\n      stringLiteralInputFields.add(classPropertyName);\n    }\n  }\n  const arity = reflector.getGenericArityOfClass(node);\n  return {\n    hasNgTemplateContextGuard,\n    ngTemplateGuards,\n    coercedInputFields,\n    restrictedInputFields,\n    stringLiteralInputFields,\n    undeclaredInputFields,\n    isGeneric: arity !== null && arity > 0\n  };\n}\nfunction isRestricted(node) {\n  if (node.modifiers === void 0) {\n    return false;\n  }\n  return node.modifiers.some((modifier) => modifier.kind === ts7.SyntaxKind.PrivateKeyword || modifier.kind === ts7.SyntaxKind.ProtectedKeyword || modifier.kind === ts7.SyntaxKind.ReadonlyKeyword);\n}\nfunction extractTemplateGuard(member) {\n  if (!member.name.startsWith(\"ngTemplateGuard_\")) {\n    return null;\n  }\n  const inputName = afterUnderscore(member.name);\n  if (member.kind === ClassMemberKind.Property) {\n    let type = null;\n    if (member.type !== null && ts7.isLiteralTypeNode(member.type) && ts7.isStringLiteral(member.type.literal)) {\n      type = member.type.literal.text;\n    }\n    if (type !== \"binding\") {\n      return null;\n    }\n    return { inputName, type };\n  } else if (member.kind === ClassMemberKind.Method) {\n    return { inputName, type: \"invocation\" };\n  } else {\n    return null;\n  }\n}\nfunction extractCoercedInput(member) {\n  if (member.kind !== ClassMemberKind.Property || !member.name.startsWith(\"ngAcceptInputType_\")) {\n    return null;\n  }\n  return afterUnderscore(member.name);\n}\nvar CompoundMetadataReader = class {\n  constructor(readers) {\n    this.readers = readers;\n  }\n  getDirectiveMetadata(node) {\n    for (const reader of this.readers) {\n      const meta = reader.getDirectiveMetadata(node);\n      if (meta !== null) {\n        return meta;\n      }\n    }\n    return null;\n  }\n  getNgModuleMetadata(node) {\n    for (const reader of this.readers) {\n      const meta = reader.getNgModuleMetadata(node);\n      if (meta !== null) {\n        return meta;\n      }\n    }\n    return null;\n  }\n  getPipeMetadata(node) {\n    for (const reader of this.readers) {\n      const meta = reader.getPipeMetadata(node);\n      if (meta !== null) {\n        return meta;\n      }\n    }\n    return null;\n  }\n};\nfunction afterUnderscore(str) {\n  const pos = str.indexOf(\"_\");\n  if (pos === -1) {\n    throw new Error(`Expected '${str}' to contain '_'`);\n  }\n  return str.substr(pos + 1);\n}\nfunction hasInjectableFields(clazz, host) {\n  const members = host.getMembersOfClass(clazz);\n  return members.some(({ isStatic, name }) => isStatic && (name === \"\\u0275prov\" || name === \"\\u0275fac\"));\n}\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/dts.mjs\nvar DtsMetadataReader = class {\n  constructor(checker, reflector) {\n    this.checker = checker;\n    this.reflector = reflector;\n  }\n  getNgModuleMetadata(ref) {\n    const clazz = ref.node;\n    const ngModuleDef = this.reflector.getMembersOfClass(clazz).find((member) => member.name === \"\\u0275mod\" && member.isStatic);\n    if (ngModuleDef === void 0) {\n      return null;\n    } else if (ngModuleDef.type === null || !ts8.isTypeReferenceNode(ngModuleDef.type) || ngModuleDef.type.typeArguments === void 0 || ngModuleDef.type.typeArguments.length !== 4) {\n      return null;\n    }\n    const [_, declarationMetadata, importMetadata, exportMetadata] = ngModuleDef.type.typeArguments;\n    return {\n      ref,\n      declarations: extractReferencesFromType(this.checker, declarationMetadata, ref.bestGuessOwningModule),\n      exports: extractReferencesFromType(this.checker, exportMetadata, ref.bestGuessOwningModule),\n      imports: extractReferencesFromType(this.checker, importMetadata, ref.bestGuessOwningModule),\n      schemas: [],\n      rawDeclarations: null\n    };\n  }\n  getDirectiveMetadata(ref) {\n    const clazz = ref.node;\n    const def = this.reflector.getMembersOfClass(clazz).find((field) => field.isStatic && (field.name === \"\\u0275cmp\" || field.name === \"\\u0275dir\"));\n    if (def === void 0) {\n      return null;\n    } else if (def.type === null || !ts8.isTypeReferenceNode(def.type) || def.type.typeArguments === void 0 || def.type.typeArguments.length < 2) {\n      return null;\n    }\n    const isComponent = def.name === \"\\u0275cmp\";\n    const ctorParams = this.reflector.getConstructorParameters(clazz);\n    const isStructural = !isComponent && ctorParams !== null && ctorParams.some((param) => {\n      return param.typeValueReference.kind === 1 && param.typeValueReference.moduleName === \"@angular/core\" && param.typeValueReference.importedName === \"TemplateRef\";\n    });\n    const inputs = ClassPropertyMapping.fromMappedObject(readStringMapType(def.type.typeArguments[3]));\n    const outputs = ClassPropertyMapping.fromMappedObject(readStringMapType(def.type.typeArguments[4]));\n    return __spreadProps(__spreadValues({\n      type: MetaType.Directive,\n      ref,\n      name: clazz.name.text,\n      isComponent,\n      selector: readStringType(def.type.typeArguments[1]),\n      exportAs: readStringArrayType(def.type.typeArguments[2]),\n      inputs,\n      outputs,\n      queries: readStringArrayType(def.type.typeArguments[5])\n    }, extractDirectiveTypeCheckMeta(clazz, inputs, this.reflector)), {\n      baseClass: readBaseClass2(clazz, this.checker, this.reflector),\n      isPoisoned: false,\n      isStructural\n    });\n  }\n  getPipeMetadata(ref) {\n    const def = this.reflector.getMembersOfClass(ref.node).find((field) => field.isStatic && field.name === \"\\u0275pipe\");\n    if (def === void 0) {\n      return null;\n    } else if (def.type === null || !ts8.isTypeReferenceNode(def.type) || def.type.typeArguments === void 0 || def.type.typeArguments.length < 2) {\n      return null;\n    }\n    const type = def.type.typeArguments[1];\n    if (!ts8.isLiteralTypeNode(type) || !ts8.isStringLiteral(type.literal)) {\n      return null;\n    }\n    const name = type.literal.text;\n    return {\n      type: MetaType.Pipe,\n      ref,\n      name,\n      nameExpr: null\n    };\n  }\n};\nfunction readBaseClass2(clazz, checker, reflector) {\n  if (!isNamedClassDeclaration(clazz)) {\n    return reflector.hasBaseClass(clazz) ? \"dynamic\" : null;\n  }\n  if (clazz.heritageClauses !== void 0) {\n    for (const clause of clazz.heritageClauses) {\n      if (clause.token === ts8.SyntaxKind.ExtendsKeyword) {\n        const baseExpr = clause.types[0].expression;\n        let symbol = checker.getSymbolAtLocation(baseExpr);\n        if (symbol === void 0) {\n          return \"dynamic\";\n        } else if (symbol.flags & ts8.SymbolFlags.Alias) {\n          symbol = checker.getAliasedSymbol(symbol);\n        }\n        if (symbol.valueDeclaration !== void 0 && isNamedClassDeclaration(symbol.valueDeclaration)) {\n          return new Reference(symbol.valueDeclaration);\n        } else {\n          return \"dynamic\";\n        }\n      }\n    }\n  }\n  return null;\n}\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/inheritance.mjs\nfunction flattenInheritedDirectiveMetadata(reader, dir) {\n  const topMeta = reader.getDirectiveMetadata(dir);\n  if (topMeta === null) {\n    throw new Error(`Metadata not found for directive: ${dir.debugName}`);\n  }\n  if (topMeta.baseClass === null) {\n    return topMeta;\n  }\n  const coercedInputFields = new Set();\n  const undeclaredInputFields = new Set();\n  const restrictedInputFields = new Set();\n  const stringLiteralInputFields = new Set();\n  let isDynamic = false;\n  let inputs = ClassPropertyMapping.empty();\n  let outputs = ClassPropertyMapping.empty();\n  let isStructural = false;\n  const addMetadata = (meta) => {\n    if (meta.baseClass === \"dynamic\") {\n      isDynamic = true;\n    } else if (meta.baseClass !== null) {\n      const baseMeta = reader.getDirectiveMetadata(meta.baseClass);\n      if (baseMeta !== null) {\n        addMetadata(baseMeta);\n      } else {\n        isDynamic = true;\n      }\n    }\n    isStructural = isStructural || meta.isStructural;\n    inputs = ClassPropertyMapping.merge(inputs, meta.inputs);\n    outputs = ClassPropertyMapping.merge(outputs, meta.outputs);\n    for (const coercedInputField of meta.coercedInputFields) {\n      coercedInputFields.add(coercedInputField);\n    }\n    for (const undeclaredInputField of meta.undeclaredInputFields) {\n      undeclaredInputFields.add(undeclaredInputField);\n    }\n    for (const restrictedInputField of meta.restrictedInputFields) {\n      restrictedInputFields.add(restrictedInputField);\n    }\n    for (const field of meta.stringLiteralInputFields) {\n      stringLiteralInputFields.add(field);\n    }\n  };\n  addMetadata(topMeta);\n  return __spreadProps(__spreadValues({}, topMeta), {\n    inputs,\n    outputs,\n    coercedInputFields,\n    undeclaredInputFields,\n    restrictedInputFields,\n    stringLiteralInputFields,\n    baseClass: isDynamic ? \"dynamic\" : null,\n    isStructural\n  });\n}\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/registry.mjs\nvar LocalMetadataRegistry = class {\n  constructor() {\n    this.directives = new Map();\n    this.ngModules = new Map();\n    this.pipes = new Map();\n  }\n  getDirectiveMetadata(ref) {\n    return this.directives.has(ref.node) ? this.directives.get(ref.node) : null;\n  }\n  getNgModuleMetadata(ref) {\n    return this.ngModules.has(ref.node) ? this.ngModules.get(ref.node) : null;\n  }\n  getPipeMetadata(ref) {\n    return this.pipes.has(ref.node) ? this.pipes.get(ref.node) : null;\n  }\n  registerDirectiveMetadata(meta) {\n    this.directives.set(meta.ref.node, meta);\n  }\n  registerNgModuleMetadata(meta) {\n    this.ngModules.set(meta.ref.node, meta);\n  }\n  registerPipeMetadata(meta) {\n    this.pipes.set(meta.ref.node, meta);\n  }\n};\nvar CompoundMetadataRegistry = class {\n  constructor(registries) {\n    this.registries = registries;\n  }\n  registerDirectiveMetadata(meta) {\n    for (const registry of this.registries) {\n      registry.registerDirectiveMetadata(meta);\n    }\n  }\n  registerNgModuleMetadata(meta) {\n    for (const registry of this.registries) {\n      registry.registerNgModuleMetadata(meta);\n    }\n  }\n  registerPipeMetadata(meta) {\n    for (const registry of this.registries) {\n      registry.registerPipeMetadata(meta);\n    }\n  }\n};\nvar InjectableClassRegistry = class {\n  constructor(host) {\n    this.host = host;\n    this.classes = new Set();\n  }\n  registerInjectable(declaration) {\n    this.classes.add(declaration);\n  }\n  isInjectable(declaration) {\n    return this.classes.has(declaration) || hasInjectableFields(declaration, this.host);\n  }\n};\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/metadata/src/resource_registry.mjs\nvar ResourceRegistry = class {\n  constructor() {\n    this.externalTemplateToComponentsMap = new Map();\n    this.componentToTemplateMap = new Map();\n    this.componentToStylesMap = new Map();\n    this.externalStyleToComponentsMap = new Map();\n  }\n  getComponentsWithTemplate(template) {\n    if (!this.externalTemplateToComponentsMap.has(template)) {\n      return new Set();\n    }\n    return this.externalTemplateToComponentsMap.get(template);\n  }\n  registerResources(resources, component) {\n    if (resources.template !== null) {\n      this.registerTemplate(resources.template, component);\n    }\n    for (const style of resources.styles) {\n      this.registerStyle(style, component);\n    }\n  }\n  registerTemplate(templateResource, component) {\n    const { path } = templateResource;\n    if (path !== null) {\n      if (!this.externalTemplateToComponentsMap.has(path)) {\n        this.externalTemplateToComponentsMap.set(path, new Set());\n      }\n      this.externalTemplateToComponentsMap.get(path).add(component);\n    }\n    this.componentToTemplateMap.set(component, templateResource);\n  }\n  getTemplate(component) {\n    if (!this.componentToTemplateMap.has(component)) {\n      return null;\n    }\n    return this.componentToTemplateMap.get(component);\n  }\n  registerStyle(styleResource, component) {\n    const { path } = styleResource;\n    if (!this.componentToStylesMap.has(component)) {\n      this.componentToStylesMap.set(component, new Set());\n    }\n    if (path !== null) {\n      if (!this.externalStyleToComponentsMap.has(path)) {\n        this.externalStyleToComponentsMap.set(path, new Set());\n      }\n      this.externalStyleToComponentsMap.get(path).add(component);\n    }\n    this.componentToStylesMap.get(component).add(styleResource);\n  }\n  getStyles(component) {\n    if (!this.componentToStylesMap.has(component)) {\n      return new Set();\n    }\n    return this.componentToStylesMap.get(component);\n  }\n  getComponentsWithStyle(styleUrl) {\n    if (!this.externalStyleToComponentsMap.has(styleUrl)) {\n      return new Set();\n    }\n    return this.externalStyleToComponentsMap.get(styleUrl);\n  }\n};\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/api.mjs\nvar CompilationMode;\n(function(CompilationMode2) {\n  CompilationMode2[CompilationMode2[\"FULL\"] = 0] = \"FULL\";\n  CompilationMode2[CompilationMode2[\"PARTIAL\"] = 1] = \"PARTIAL\";\n})(CompilationMode || (CompilationMode = {}));\nvar HandlerPrecedence;\n(function(HandlerPrecedence2) {\n  HandlerPrecedence2[HandlerPrecedence2[\"PRIMARY\"] = 0] = \"PRIMARY\";\n  HandlerPrecedence2[HandlerPrecedence2[\"SHARED\"] = 1] = \"SHARED\";\n  HandlerPrecedence2[HandlerPrecedence2[\"WEAK\"] = 2] = \"WEAK\";\n})(HandlerPrecedence || (HandlerPrecedence = {}));\nvar HandlerFlags;\n(function(HandlerFlags2) {\n  HandlerFlags2[HandlerFlags2[\"NONE\"] = 0] = \"NONE\";\n  HandlerFlags2[HandlerFlags2[\"FULL_INHERITANCE\"] = 1] = \"FULL_INHERITANCE\";\n})(HandlerFlags || (HandlerFlags = {}));\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/alias.mjs\nimport ts9 from \"typescript\";\nfunction aliasTransformFactory(exportStatements) {\n  return (context) => {\n    return (file) => {\n      if (ts9.isBundle(file) || !exportStatements.has(file.fileName)) {\n        return file;\n      }\n      const statements = [...file.statements];\n      exportStatements.get(file.fileName).forEach(([moduleName, symbolName], aliasName) => {\n        const stmt = ts9.createExportDeclaration(void 0, void 0, ts9.createNamedExports([createExportSpecifier(symbolName, aliasName)]), ts9.createStringLiteral(moduleName));\n        statements.push(stmt);\n      });\n      return ts9.updateSourceFileNode(file, statements);\n    };\n  };\n}\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/compilation.mjs\nimport ts10 from \"typescript\";\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/trait.mjs\nvar TraitState;\n(function(TraitState2) {\n  TraitState2[TraitState2[\"Pending\"] = 0] = \"Pending\";\n  TraitState2[TraitState2[\"Analyzed\"] = 1] = \"Analyzed\";\n  TraitState2[TraitState2[\"Resolved\"] = 2] = \"Resolved\";\n  TraitState2[TraitState2[\"Skipped\"] = 3] = \"Skipped\";\n})(TraitState || (TraitState = {}));\nvar Trait = {\n  pending: (handler, detected) => TraitImpl.pending(handler, detected)\n};\nvar TraitImpl = class {\n  constructor(handler, detected) {\n    this.state = TraitState.Pending;\n    this.analysis = null;\n    this.symbol = null;\n    this.resolution = null;\n    this.analysisDiagnostics = null;\n    this.resolveDiagnostics = null;\n    this.handler = handler;\n    this.detected = detected;\n  }\n  toAnalyzed(analysis, diagnostics, symbol) {\n    this.assertTransitionLegal(TraitState.Pending, TraitState.Analyzed);\n    this.analysis = analysis;\n    this.analysisDiagnostics = diagnostics;\n    this.symbol = symbol;\n    this.state = TraitState.Analyzed;\n    return this;\n  }\n  toResolved(resolution, diagnostics) {\n    this.assertTransitionLegal(TraitState.Analyzed, TraitState.Resolved);\n    if (this.analysis === null) {\n      throw new Error(`Cannot transition an Analyzed trait with a null analysis to Resolved`);\n    }\n    this.resolution = resolution;\n    this.state = TraitState.Resolved;\n    this.resolveDiagnostics = diagnostics;\n    return this;\n  }\n  toSkipped() {\n    this.assertTransitionLegal(TraitState.Pending, TraitState.Skipped);\n    this.state = TraitState.Skipped;\n    return this;\n  }\n  assertTransitionLegal(allowedState, transitionTo) {\n    if (!(this.state === allowedState)) {\n      throw new Error(`Assertion failure: cannot transition from ${TraitState[this.state]} to ${TraitState[transitionTo]}.`);\n    }\n  }\n  static pending(handler, detected) {\n    return new TraitImpl(handler, detected);\n  }\n};\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/compilation.mjs\nvar TraitCompiler = class {\n  constructor(handlers, reflector, perf, incrementalBuild, compileNonExportedClasses, compilationMode, dtsTransforms, semanticDepGraphUpdater) {\n    this.handlers = handlers;\n    this.reflector = reflector;\n    this.perf = perf;\n    this.incrementalBuild = incrementalBuild;\n    this.compileNonExportedClasses = compileNonExportedClasses;\n    this.compilationMode = compilationMode;\n    this.dtsTransforms = dtsTransforms;\n    this.semanticDepGraphUpdater = semanticDepGraphUpdater;\n    this.classes = new Map();\n    this.fileToClasses = new Map();\n    this.filesWithoutTraits = new Set();\n    this.reexportMap = new Map();\n    this.handlersByName = new Map();\n    for (const handler of handlers) {\n      this.handlersByName.set(handler.name, handler);\n    }\n  }\n  analyzeSync(sf) {\n    this.analyze(sf, false);\n  }\n  analyzeAsync(sf) {\n    return this.analyze(sf, true);\n  }\n  analyze(sf, preanalyze) {\n    if (sf.isDeclarationFile) {\n      return void 0;\n    }\n    const promises = [];\n    const priorWork = this.incrementalBuild.priorAnalysisFor(sf);\n    if (priorWork !== null) {\n      this.perf.eventCount(PerfEvent.SourceFileReuseAnalysis);\n      if (priorWork.length > 0) {\n        for (const priorRecord of priorWork) {\n          this.adopt(priorRecord);\n        }\n        this.perf.eventCount(PerfEvent.TraitReuseAnalysis, priorWork.length);\n      } else {\n        this.filesWithoutTraits.add(sf);\n      }\n      return;\n    }\n    const visit2 = (node) => {\n      if (this.reflector.isClass(node)) {\n        this.analyzeClass(node, preanalyze ? promises : null);\n      }\n      ts10.forEachChild(node, visit2);\n    };\n    visit2(sf);\n    if (preanalyze && promises.length > 0) {\n      return Promise.all(promises).then(() => void 0);\n    } else {\n      return void 0;\n    }\n  }\n  recordFor(clazz) {\n    if (this.classes.has(clazz)) {\n      return this.classes.get(clazz);\n    } else {\n      return null;\n    }\n  }\n  recordsFor(sf) {\n    if (!this.fileToClasses.has(sf)) {\n      return null;\n    }\n    const records = [];\n    for (const clazz of this.fileToClasses.get(sf)) {\n      records.push(this.classes.get(clazz));\n    }\n    return records;\n  }\n  getAnalyzedRecords() {\n    const result = new Map();\n    for (const [sf, classes] of this.fileToClasses) {\n      const records = [];\n      for (const clazz of classes) {\n        records.push(this.classes.get(clazz));\n      }\n      result.set(sf, records);\n    }\n    for (const sf of this.filesWithoutTraits) {\n      result.set(sf, []);\n    }\n    return result;\n  }\n  adopt(priorRecord) {\n    const record = {\n      hasPrimaryHandler: priorRecord.hasPrimaryHandler,\n      hasWeakHandlers: priorRecord.hasWeakHandlers,\n      metaDiagnostics: priorRecord.metaDiagnostics,\n      node: priorRecord.node,\n      traits: []\n    };\n    for (const priorTrait of priorRecord.traits) {\n      const handler = this.handlersByName.get(priorTrait.handler.name);\n      let trait = Trait.pending(handler, priorTrait.detected);\n      if (priorTrait.state === TraitState.Analyzed || priorTrait.state === TraitState.Resolved) {\n        const symbol = this.makeSymbolForTrait(handler, record.node, priorTrait.analysis);\n        trait = trait.toAnalyzed(priorTrait.analysis, priorTrait.analysisDiagnostics, symbol);\n        if (trait.analysis !== null && trait.handler.register !== void 0) {\n          trait.handler.register(record.node, trait.analysis);\n        }\n      } else if (priorTrait.state === TraitState.Skipped) {\n        trait = trait.toSkipped();\n      }\n      record.traits.push(trait);\n    }\n    this.classes.set(record.node, record);\n    const sf = record.node.getSourceFile();\n    if (!this.fileToClasses.has(sf)) {\n      this.fileToClasses.set(sf, new Set());\n    }\n    this.fileToClasses.get(sf).add(record.node);\n  }\n  scanClassForTraits(clazz) {\n    if (!this.compileNonExportedClasses && !this.reflector.isStaticallyExported(clazz)) {\n      return null;\n    }\n    const decorators = this.reflector.getDecoratorsOfDeclaration(clazz);\n    return this.detectTraits(clazz, decorators);\n  }\n  detectTraits(clazz, decorators) {\n    let record = this.recordFor(clazz);\n    let foundTraits = [];\n    for (const handler of this.handlers) {\n      const result = handler.detect(clazz, decorators);\n      if (result === void 0) {\n        continue;\n      }\n      const isPrimaryHandler = handler.precedence === HandlerPrecedence.PRIMARY;\n      const isWeakHandler = handler.precedence === HandlerPrecedence.WEAK;\n      const trait = Trait.pending(handler, result);\n      foundTraits.push(trait);\n      if (record === null) {\n        record = {\n          node: clazz,\n          traits: [trait],\n          metaDiagnostics: null,\n          hasPrimaryHandler: isPrimaryHandler,\n          hasWeakHandlers: isWeakHandler\n        };\n        this.classes.set(clazz, record);\n        const sf = clazz.getSourceFile();\n        if (!this.fileToClasses.has(sf)) {\n          this.fileToClasses.set(sf, new Set());\n        }\n        this.fileToClasses.get(sf).add(clazz);\n      } else {\n        if (!isWeakHandler && record.hasWeakHandlers) {\n          record.traits = record.traits.filter((field) => field.handler.precedence !== HandlerPrecedence.WEAK);\n          record.hasWeakHandlers = false;\n        } else if (isWeakHandler && !record.hasWeakHandlers) {\n          continue;\n        }\n        if (isPrimaryHandler && record.hasPrimaryHandler) {\n          record.metaDiagnostics = [{\n            category: ts10.DiagnosticCategory.Error,\n            code: Number(\"-99\" + ErrorCode.DECORATOR_COLLISION),\n            file: getSourceFile(clazz),\n            start: clazz.getStart(void 0, false),\n            length: clazz.getWidth(),\n            messageText: \"Two incompatible decorators on class\"\n          }];\n          record.traits = foundTraits = [];\n          break;\n        }\n        record.traits.push(trait);\n        record.hasPrimaryHandler = record.hasPrimaryHandler || isPrimaryHandler;\n      }\n    }\n    return foundTraits.length > 0 ? foundTraits : null;\n  }\n  makeSymbolForTrait(handler, decl, analysis) {\n    if (analysis === null) {\n      return null;\n    }\n    const symbol = handler.symbol(decl, analysis);\n    if (symbol !== null && this.semanticDepGraphUpdater !== null) {\n      const isPrimary = handler.precedence === HandlerPrecedence.PRIMARY;\n      if (!isPrimary) {\n        throw new Error(`AssertionError: ${handler.name} returned a symbol but is not a primary handler.`);\n      }\n      this.semanticDepGraphUpdater.registerSymbol(symbol);\n    }\n    return symbol;\n  }\n  analyzeClass(clazz, preanalyzeQueue) {\n    const traits = this.scanClassForTraits(clazz);\n    if (traits === null) {\n      return;\n    }\n    for (const trait of traits) {\n      const analyze = () => this.analyzeTrait(clazz, trait);\n      let preanalysis = null;\n      if (preanalyzeQueue !== null && trait.handler.preanalyze !== void 0) {\n        try {\n          preanalysis = trait.handler.preanalyze(clazz, trait.detected.metadata) || null;\n        } catch (err) {\n          if (err instanceof FatalDiagnosticError) {\n            trait.toAnalyzed(null, [err.toDiagnostic()], null);\n            return;\n          } else {\n            throw err;\n          }\n        }\n      }\n      if (preanalysis !== null) {\n        preanalyzeQueue.push(preanalysis.then(analyze));\n      } else {\n        analyze();\n      }\n    }\n  }\n  analyzeTrait(clazz, trait, flags) {\n    var _a, _b, _c;\n    if (trait.state !== TraitState.Pending) {\n      throw new Error(`Attempt to analyze trait of ${clazz.name.text} in state ${TraitState[trait.state]} (expected DETECTED)`);\n    }\n    this.perf.eventCount(PerfEvent.TraitAnalyze);\n    let result;\n    try {\n      result = trait.handler.analyze(clazz, trait.detected.metadata, flags);\n    } catch (err) {\n      if (err instanceof FatalDiagnosticError) {\n        trait.toAnalyzed(null, [err.toDiagnostic()], null);\n        return;\n      } else {\n        throw err;\n      }\n    }\n    const symbol = this.makeSymbolForTrait(trait.handler, clazz, (_a = result.analysis) != null ? _a : null);\n    if (result.analysis !== void 0 && trait.handler.register !== void 0) {\n      trait.handler.register(clazz, result.analysis);\n    }\n    trait = trait.toAnalyzed((_b = result.analysis) != null ? _b : null, (_c = result.diagnostics) != null ? _c : null, symbol);\n  }\n  resolve() {\n    var _a, _b;\n    const classes = Array.from(this.classes.keys());\n    for (const clazz of classes) {\n      const record = this.classes.get(clazz);\n      for (let trait of record.traits) {\n        const handler = trait.handler;\n        switch (trait.state) {\n          case TraitState.Skipped:\n            continue;\n          case TraitState.Pending:\n            throw new Error(`Resolving a trait that hasn't been analyzed: ${clazz.name.text} / ${Object.getPrototypeOf(trait.handler).constructor.name}`);\n          case TraitState.Resolved:\n            throw new Error(`Resolving an already resolved trait`);\n        }\n        if (trait.analysis === null) {\n          continue;\n        }\n        if (handler.resolve === void 0) {\n          trait = trait.toResolved(null, null);\n          continue;\n        }\n        let result;\n        try {\n          result = handler.resolve(clazz, trait.analysis, trait.symbol);\n        } catch (err) {\n          if (err instanceof FatalDiagnosticError) {\n            trait = trait.toResolved(null, [err.toDiagnostic()]);\n            continue;\n          } else {\n            throw err;\n          }\n        }\n        trait = trait.toResolved((_a = result.data) != null ? _a : null, (_b = result.diagnostics) != null ? _b : null);\n        if (result.reexports !== void 0) {\n          const fileName = clazz.getSourceFile().fileName;\n          if (!this.reexportMap.has(fileName)) {\n            this.reexportMap.set(fileName, new Map());\n          }\n          const fileReexports = this.reexportMap.get(fileName);\n          for (const reexport of result.reexports) {\n            fileReexports.set(reexport.asAlias, [reexport.fromModule, reexport.symbolName]);\n          }\n        }\n      }\n    }\n  }\n  typeCheck(sf, ctx) {\n    if (!this.fileToClasses.has(sf)) {\n      return;\n    }\n    for (const clazz of this.fileToClasses.get(sf)) {\n      const record = this.classes.get(clazz);\n      for (const trait of record.traits) {\n        if (trait.state !== TraitState.Resolved) {\n          continue;\n        } else if (trait.handler.typeCheck === void 0) {\n          continue;\n        }\n        if (trait.resolution !== null) {\n          trait.handler.typeCheck(ctx, clazz, trait.analysis, trait.resolution);\n        }\n      }\n    }\n  }\n  extendedTemplateCheck(sf, extendedTemplateChecker) {\n    const classes = this.fileToClasses.get(sf);\n    if (classes === void 0) {\n      return [];\n    }\n    const diagnostics = [];\n    for (const clazz of classes) {\n      if (!isNamedClassDeclaration(clazz)) {\n        continue;\n      }\n      const record = this.classes.get(clazz);\n      for (const trait of record.traits) {\n        if (trait.handler.extendedTemplateCheck === void 0) {\n          continue;\n        }\n        diagnostics.push(...trait.handler.extendedTemplateCheck(clazz, extendedTemplateChecker));\n      }\n    }\n    return diagnostics;\n  }\n  index(ctx) {\n    for (const clazz of this.classes.keys()) {\n      const record = this.classes.get(clazz);\n      for (const trait of record.traits) {\n        if (trait.state !== TraitState.Resolved) {\n          continue;\n        } else if (trait.handler.index === void 0) {\n          continue;\n        }\n        if (trait.resolution !== null) {\n          trait.handler.index(ctx, clazz, trait.analysis, trait.resolution);\n        }\n      }\n    }\n  }\n  xi18n(bundle) {\n    for (const clazz of this.classes.keys()) {\n      const record = this.classes.get(clazz);\n      for (const trait of record.traits) {\n        if (trait.state !== TraitState.Analyzed && trait.state !== TraitState.Resolved) {\n          continue;\n        } else if (trait.handler.xi18n === void 0) {\n          continue;\n        }\n        if (trait.analysis !== null) {\n          trait.handler.xi18n(bundle, clazz, trait.analysis);\n        }\n      }\n    }\n  }\n  updateResources(clazz) {\n    if (!this.reflector.isClass(clazz) || !this.classes.has(clazz)) {\n      return;\n    }\n    const record = this.classes.get(clazz);\n    for (const trait of record.traits) {\n      if (trait.state !== TraitState.Resolved || trait.handler.updateResources === void 0) {\n        continue;\n      }\n      trait.handler.updateResources(clazz, trait.analysis, trait.resolution);\n    }\n  }\n  compile(clazz, constantPool) {\n    const original = ts10.getOriginalNode(clazz);\n    if (!this.reflector.isClass(clazz) || !this.reflector.isClass(original) || !this.classes.has(original)) {\n      return null;\n    }\n    const record = this.classes.get(original);\n    let res = [];\n    for (const trait of record.traits) {\n      if (trait.state !== TraitState.Resolved || trait.analysisDiagnostics !== null || trait.resolveDiagnostics !== null) {\n        continue;\n      }\n      let compileRes;\n      if (this.compilationMode === CompilationMode.PARTIAL && trait.handler.compilePartial !== void 0) {\n        compileRes = trait.handler.compilePartial(clazz, trait.analysis, trait.resolution);\n      } else {\n        compileRes = trait.handler.compileFull(clazz, trait.analysis, trait.resolution, constantPool);\n      }\n      const compileMatchRes = compileRes;\n      if (Array.isArray(compileMatchRes)) {\n        for (const result of compileMatchRes) {\n          if (!res.some((r) => r.name === result.name)) {\n            res.push(result);\n          }\n        }\n      } else if (!res.some((result) => result.name === compileMatchRes.name)) {\n        res.push(compileMatchRes);\n      }\n    }\n    this.dtsTransforms.getIvyDeclarationTransform(original.getSourceFile()).addFields(original, res);\n    return res.length > 0 ? res : null;\n  }\n  decoratorsFor(node) {\n    const original = ts10.getOriginalNode(node);\n    if (!this.reflector.isClass(original) || !this.classes.has(original)) {\n      return [];\n    }\n    const record = this.classes.get(original);\n    const decorators = [];\n    for (const trait of record.traits) {\n      if (trait.state !== TraitState.Resolved) {\n        continue;\n      }\n      if (trait.detected.trigger !== null && ts10.isDecorator(trait.detected.trigger)) {\n        decorators.push(trait.detected.trigger);\n      }\n    }\n    return decorators;\n  }\n  get diagnostics() {\n    const diagnostics = [];\n    for (const clazz of this.classes.keys()) {\n      const record = this.classes.get(clazz);\n      if (record.metaDiagnostics !== null) {\n        diagnostics.push(...record.metaDiagnostics);\n      }\n      for (const trait of record.traits) {\n        if ((trait.state === TraitState.Analyzed || trait.state === TraitState.Resolved) && trait.analysisDiagnostics !== null) {\n          diagnostics.push(...trait.analysisDiagnostics);\n        }\n        if (trait.state === TraitState.Resolved && trait.resolveDiagnostics !== null) {\n          diagnostics.push(...trait.resolveDiagnostics);\n        }\n      }\n    }\n    return diagnostics;\n  }\n  get exportStatements() {\n    return this.reexportMap;\n  }\n};\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/declaration.mjs\nimport ts12 from \"typescript\";\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/utils.mjs\nimport ts11 from \"typescript\";\nfunction addImports(importManager, sf, extraStatements = []) {\n  const addedImports = importManager.getAllImports(sf.fileName).map((i) => {\n    const qualifier = ts11.createIdentifier(i.qualifier.text);\n    const importClause = ts11.createImportClause(void 0, ts11.createNamespaceImport(qualifier));\n    const decl = ts11.createImportDeclaration(void 0, void 0, importClause, ts11.createLiteral(i.specifier));\n    ts11.setOriginalNode(i.qualifier, decl);\n    return decl;\n  });\n  const existingImports = sf.statements.filter((stmt) => isImportStatement(stmt));\n  const body = sf.statements.filter((stmt) => !isImportStatement(stmt));\n  if (addedImports.length > 0) {\n    const fileoverviewAnchorStmt = ts11.createNotEmittedStatement(sf);\n    return ts11.updateSourceFileNode(sf, ts11.createNodeArray([\n      fileoverviewAnchorStmt,\n      ...existingImports,\n      ...addedImports,\n      ...extraStatements,\n      ...body\n    ]));\n  }\n  return sf;\n}\nfunction isImportStatement(stmt) {\n  return ts11.isImportDeclaration(stmt) || ts11.isImportEqualsDeclaration(stmt) || ts11.isNamespaceImport(stmt);\n}\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/declaration.mjs\nvar DtsTransformRegistry = class {\n  constructor() {\n    this.ivyDeclarationTransforms = new Map();\n  }\n  getIvyDeclarationTransform(sf) {\n    if (!this.ivyDeclarationTransforms.has(sf)) {\n      this.ivyDeclarationTransforms.set(sf, new IvyDeclarationDtsTransform());\n    }\n    return this.ivyDeclarationTransforms.get(sf);\n  }\n  getAllTransforms(sf) {\n    if (!sf.isDeclarationFile) {\n      return null;\n    }\n    const originalSf = ts12.getOriginalNode(sf);\n    let transforms = null;\n    if (this.ivyDeclarationTransforms.has(originalSf)) {\n      transforms = [];\n      transforms.push(this.ivyDeclarationTransforms.get(originalSf));\n    }\n    return transforms;\n  }\n};\nfunction declarationTransformFactory(transformRegistry, importRewriter, importPrefix) {\n  return (context) => {\n    const transformer = new DtsTransformer(context, importRewriter, importPrefix);\n    return (fileOrBundle) => {\n      if (ts12.isBundle(fileOrBundle)) {\n        return fileOrBundle;\n      }\n      const transforms = transformRegistry.getAllTransforms(fileOrBundle);\n      if (transforms === null) {\n        return fileOrBundle;\n      }\n      return transformer.transform(fileOrBundle, transforms);\n    };\n  };\n}\nvar DtsTransformer = class {\n  constructor(ctx, importRewriter, importPrefix) {\n    this.ctx = ctx;\n    this.importRewriter = importRewriter;\n    this.importPrefix = importPrefix;\n  }\n  transform(sf, transforms) {\n    const imports = new ImportManager(this.importRewriter, this.importPrefix);\n    const visitor = (node) => {\n      if (ts12.isClassDeclaration(node)) {\n        return this.transformClassDeclaration(node, transforms, imports);\n      } else if (ts12.isFunctionDeclaration(node)) {\n        return this.transformFunctionDeclaration(node, transforms, imports);\n      } else {\n        return ts12.visitEachChild(node, visitor, this.ctx);\n      }\n    };\n    sf = ts12.visitNode(sf, visitor);\n    return addImports(imports, sf);\n  }\n  transformClassDeclaration(clazz, transforms, imports) {\n    let elements = clazz.members;\n    let elementsChanged = false;\n    for (const transform of transforms) {\n      if (transform.transformClassElement !== void 0) {\n        for (let i = 0; i < elements.length; i++) {\n          const res = transform.transformClassElement(elements[i], imports);\n          if (res !== elements[i]) {\n            if (!elementsChanged) {\n              elements = [...elements];\n              elementsChanged = true;\n            }\n            elements[i] = res;\n          }\n        }\n      }\n    }\n    let newClazz = clazz;\n    for (const transform of transforms) {\n      if (transform.transformClass !== void 0) {\n        const inputMembers = clazz === newClazz ? elements : newClazz.members;\n        newClazz = transform.transformClass(newClazz, inputMembers, imports);\n      }\n    }\n    if (elementsChanged && clazz === newClazz) {\n      newClazz = ts12.updateClassDeclaration(clazz, clazz.decorators, clazz.modifiers, clazz.name, clazz.typeParameters, clazz.heritageClauses, elements);\n    }\n    return newClazz;\n  }\n  transformFunctionDeclaration(declaration, transforms, imports) {\n    let newDecl = declaration;\n    for (const transform of transforms) {\n      if (transform.transformFunctionDeclaration !== void 0) {\n        newDecl = transform.transformFunctionDeclaration(newDecl, imports);\n      }\n    }\n    return newDecl;\n  }\n};\nvar IvyDeclarationDtsTransform = class {\n  constructor() {\n    this.declarationFields = new Map();\n  }\n  addFields(decl, fields) {\n    this.declarationFields.set(decl, fields);\n  }\n  transformClass(clazz, members, imports) {\n    const original = ts12.getOriginalNode(clazz);\n    if (!this.declarationFields.has(original)) {\n      return clazz;\n    }\n    const fields = this.declarationFields.get(original);\n    const newMembers = fields.map((decl) => {\n      const modifiers = [ts12.createModifier(ts12.SyntaxKind.StaticKeyword)];\n      const typeRef = translateType(decl.type, imports);\n      markForEmitAsSingleLine(typeRef);\n      return ts12.createProperty(void 0, modifiers, decl.name, void 0, typeRef, void 0);\n    });\n    return ts12.updateClassDeclaration(clazz, clazz.decorators, clazz.modifiers, clazz.name, clazz.typeParameters, clazz.heritageClauses, [...members, ...newMembers]);\n  }\n};\nfunction markForEmitAsSingleLine(node) {\n  ts12.setEmitFlags(node, ts12.EmitFlags.SingleLine);\n  ts12.forEachChild(node, markForEmitAsSingleLine);\n}\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/transform.mjs\nimport { ConstantPool } from \"@angular/compiler\";\nimport ts14 from \"typescript\";\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/util/src/visitor.mjs\nimport ts13 from \"typescript\";\nfunction visit(node, visitor, context) {\n  return visitor._visit(node, context);\n}\nvar Visitor = class {\n  constructor() {\n    this._before = new Map();\n    this._after = new Map();\n  }\n  _visitListEntryNode(node, visitor) {\n    const result = visitor(node);\n    if (result.before !== void 0) {\n      this._before.set(result.node, result.before);\n    }\n    if (result.after !== void 0) {\n      this._after.set(result.node, result.after);\n    }\n    return result.node;\n  }\n  visitOtherNode(node) {\n    return node;\n  }\n  _visit(node, context) {\n    let visitedNode = null;\n    node = ts13.visitEachChild(node, (child) => this._visit(child, context), context);\n    if (ts13.isClassDeclaration(node)) {\n      visitedNode = this._visitListEntryNode(node, (node2) => this.visitClassDeclaration(node2));\n    } else {\n      visitedNode = this.visitOtherNode(node);\n    }\n    if (hasStatements(visitedNode)) {\n      visitedNode = this._maybeProcessStatements(visitedNode);\n    }\n    return visitedNode;\n  }\n  _maybeProcessStatements(node) {\n    if (node.statements.every((stmt) => !this._before.has(stmt) && !this._after.has(stmt))) {\n      return node;\n    }\n    const clone = ts13.getMutableClone(node);\n    const newStatements = [];\n    clone.statements.forEach((stmt) => {\n      if (this._before.has(stmt)) {\n        newStatements.push(...this._before.get(stmt));\n        this._before.delete(stmt);\n      }\n      newStatements.push(stmt);\n      if (this._after.has(stmt)) {\n        newStatements.push(...this._after.get(stmt));\n        this._after.delete(stmt);\n      }\n    });\n    clone.statements = ts13.createNodeArray(newStatements, node.statements.hasTrailingComma);\n    return clone;\n  }\n};\nfunction hasStatements(node) {\n  const block = node;\n  return block.statements !== void 0 && Array.isArray(block.statements);\n}\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/transform/src/transform.mjs\nvar NO_DECORATORS = new Set();\nvar CLOSURE_FILE_OVERVIEW_REGEXP = /\\s+@fileoverview\\s+/i;\nfunction ivyTransformFactory(compilation, reflector, importRewriter, defaultImportTracker, perf, isCore, isClosureCompilerEnabled) {\n  const recordWrappedNode = createRecorderFn(defaultImportTracker);\n  return (context) => {\n    return (file) => {\n      return perf.inPhase(PerfPhase.Compile, () => transformIvySourceFile(compilation, context, reflector, importRewriter, file, isCore, isClosureCompilerEnabled, recordWrappedNode));\n    };\n  };\n}\nvar IvyCompilationVisitor = class extends Visitor {\n  constructor(compilation, constantPool) {\n    super();\n    this.compilation = compilation;\n    this.constantPool = constantPool;\n    this.classCompilationMap = new Map();\n  }\n  visitClassDeclaration(node) {\n    const result = this.compilation.compile(node, this.constantPool);\n    if (result !== null) {\n      this.classCompilationMap.set(node, result);\n    }\n    return { node };\n  }\n};\nvar IvyTransformationVisitor = class extends Visitor {\n  constructor(compilation, classCompilationMap, reflector, importManager, recordWrappedNodeExpr, isClosureCompilerEnabled, isCore) {\n    super();\n    this.compilation = compilation;\n    this.classCompilationMap = classCompilationMap;\n    this.reflector = reflector;\n    this.importManager = importManager;\n    this.recordWrappedNodeExpr = recordWrappedNodeExpr;\n    this.isClosureCompilerEnabled = isClosureCompilerEnabled;\n    this.isCore = isCore;\n  }\n  visitClassDeclaration(node) {\n    if (!this.classCompilationMap.has(node)) {\n      return { node };\n    }\n    const translateOptions = {\n      recordWrappedNode: this.recordWrappedNodeExpr,\n      annotateForClosureCompiler: this.isClosureCompilerEnabled\n    };\n    const statements = [];\n    const members = [...node.members];\n    for (const field of this.classCompilationMap.get(node)) {\n      const exprNode = translateExpression(field.initializer, this.importManager, translateOptions);\n      const property = ts14.createProperty(void 0, [ts14.createToken(ts14.SyntaxKind.StaticKeyword)], field.name, void 0, void 0, exprNode);\n      if (this.isClosureCompilerEnabled) {\n        ts14.addSyntheticLeadingComment(property, ts14.SyntaxKind.MultiLineCommentTrivia, \"* @nocollapse \", false);\n      }\n      field.statements.map((stmt) => translateStatement(stmt, this.importManager, translateOptions)).forEach((stmt) => statements.push(stmt));\n      members.push(property);\n    }\n    node = ts14.updateClassDeclaration(node, maybeFilterDecorator(node.decorators, this.compilation.decoratorsFor(node)), node.modifiers, node.name, node.typeParameters, node.heritageClauses || [], members.map((member) => this._stripAngularDecorators(member)));\n    return { node, after: statements };\n  }\n  _angularCoreDecorators(decl) {\n    const decorators = this.reflector.getDecoratorsOfDeclaration(decl);\n    if (decorators === null) {\n      return NO_DECORATORS;\n    }\n    const coreDecorators = decorators.filter((dec) => this.isCore || isFromAngularCore(dec)).map((dec) => dec.node);\n    if (coreDecorators.length > 0) {\n      return new Set(coreDecorators);\n    } else {\n      return NO_DECORATORS;\n    }\n  }\n  _nonCoreDecoratorsOnly(node) {\n    if (node.decorators === void 0) {\n      return void 0;\n    }\n    const coreDecorators = this._angularCoreDecorators(node);\n    if (coreDecorators.size === node.decorators.length) {\n      return void 0;\n    } else if (coreDecorators.size === 0) {\n      return node.decorators;\n    }\n    const filtered = node.decorators.filter((dec) => !coreDecorators.has(dec));\n    if (filtered.length === 0) {\n      return void 0;\n    }\n    const array = ts14.createNodeArray(filtered);\n    array.pos = node.decorators.pos;\n    array.end = node.decorators.end;\n    return array;\n  }\n  _stripAngularDecorators(node) {\n    if (ts14.isParameter(node)) {\n      node = ts14.updateParameter(node, this._nonCoreDecoratorsOnly(node), node.modifiers, node.dotDotDotToken, node.name, node.questionToken, node.type, node.initializer);\n    } else if (ts14.isMethodDeclaration(node) && node.decorators !== void 0) {\n      node = ts14.updateMethod(node, this._nonCoreDecoratorsOnly(node), node.modifiers, node.asteriskToken, node.name, node.questionToken, node.typeParameters, node.parameters, node.type, node.body);\n    } else if (ts14.isPropertyDeclaration(node) && node.decorators !== void 0) {\n      node = ts14.updateProperty(node, this._nonCoreDecoratorsOnly(node), node.modifiers, node.name, node.questionToken, node.type, node.initializer);\n    } else if (ts14.isGetAccessor(node)) {\n      node = ts14.updateGetAccessor(node, this._nonCoreDecoratorsOnly(node), node.modifiers, node.name, node.parameters, node.type, node.body);\n    } else if (ts14.isSetAccessor(node)) {\n      node = ts14.updateSetAccessor(node, this._nonCoreDecoratorsOnly(node), node.modifiers, node.name, node.parameters, node.body);\n    } else if (ts14.isConstructorDeclaration(node)) {\n      const parameters = node.parameters.map((param) => this._stripAngularDecorators(param));\n      node = ts14.updateConstructor(node, node.decorators, node.modifiers, parameters, node.body);\n    }\n    return node;\n  }\n};\nfunction transformIvySourceFile(compilation, context, reflector, importRewriter, file, isCore, isClosureCompilerEnabled, recordWrappedNode) {\n  const constantPool = new ConstantPool(isClosureCompilerEnabled);\n  const importManager = new ImportManager(importRewriter);\n  const compilationVisitor = new IvyCompilationVisitor(compilation, constantPool);\n  visit(file, compilationVisitor, context);\n  const transformationVisitor = new IvyTransformationVisitor(compilation, compilationVisitor.classCompilationMap, reflector, importManager, recordWrappedNode, isClosureCompilerEnabled, isCore);\n  let sf = visit(file, transformationVisitor, context);\n  const downlevelTranslatedCode = getLocalizeCompileTarget(context) < ts14.ScriptTarget.ES2015;\n  const constants = constantPool.statements.map((stmt) => translateStatement(stmt, importManager, {\n    recordWrappedNode,\n    downlevelTaggedTemplates: downlevelTranslatedCode,\n    downlevelVariableDeclarations: downlevelTranslatedCode,\n    annotateForClosureCompiler: isClosureCompilerEnabled\n  }));\n  const fileOverviewMeta = isClosureCompilerEnabled ? getFileOverviewComment(sf.statements) : null;\n  sf = addImports(importManager, sf, constants);\n  if (fileOverviewMeta !== null) {\n    setFileOverviewComment(sf, fileOverviewMeta);\n  }\n  return sf;\n}\nfunction getLocalizeCompileTarget(context) {\n  const target = context.getCompilerOptions().target || ts14.ScriptTarget.ES2015;\n  return target !== ts14.ScriptTarget.JSON ? target : ts14.ScriptTarget.ES2015;\n}\nfunction getFileOverviewComment(statements) {\n  if (statements.length > 0) {\n    const host = statements[0];\n    let trailing = false;\n    let comments = ts14.getSyntheticLeadingComments(host);\n    if (!comments || comments.length === 0) {\n      trailing = true;\n      comments = ts14.getSyntheticTrailingComments(host);\n    }\n    if (comments && comments.length > 0 && CLOSURE_FILE_OVERVIEW_REGEXP.test(comments[0].text)) {\n      return { comments, host, trailing };\n    }\n  }\n  return null;\n}\nfunction setFileOverviewComment(sf, fileoverview) {\n  const { comments, host, trailing } = fileoverview;\n  if (sf.statements.length > 0 && host !== sf.statements[0]) {\n    if (trailing) {\n      ts14.setSyntheticTrailingComments(host, void 0);\n    } else {\n      ts14.setSyntheticLeadingComments(host, void 0);\n    }\n    ts14.setSyntheticLeadingComments(sf.statements[0], comments);\n  }\n}\nfunction maybeFilterDecorator(decorators, toRemove) {\n  if (decorators === void 0) {\n    return void 0;\n  }\n  const filtered = decorators.filter((dec) => toRemove.find((decToRemove) => ts14.getOriginalNode(dec) === decToRemove) === void 0);\n  if (filtered.length === 0) {\n    return void 0;\n  }\n  return ts14.createNodeArray(filtered);\n}\nfunction isFromAngularCore(decorator) {\n  return decorator.import !== null && decorator.import.from === \"@angular/core\";\n}\nfunction createRecorderFn(defaultImportTracker) {\n  return (node) => {\n    const importDecl = getDefaultImportDeclaration(node);\n    if (importDecl !== null) {\n      defaultImportTracker.recordUsedImport(importDecl);\n    }\n  };\n}\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/src/diagnostics.mjs\nimport ts15 from \"typescript\";\nfunction createValueHasWrongTypeError(node, value, messageText) {\n  var _a;\n  let chainedMessage;\n  let relatedInformation;\n  if (value instanceof DynamicValue) {\n    chainedMessage = \"Value could not be determined statically.\";\n    relatedInformation = traceDynamicValue(node, value);\n  } else if (value instanceof Reference) {\n    const target = value.debugName !== null ? `'${value.debugName}'` : \"an anonymous declaration\";\n    chainedMessage = `Value is a reference to ${target}.`;\n    const referenceNode = (_a = identifierOfNode(value.node)) != null ? _a : value.node;\n    relatedInformation = [makeRelatedInformation(referenceNode, \"Reference is declared here.\")];\n  } else {\n    chainedMessage = `Value is of type '${describeResolvedType(value)}'.`;\n  }\n  const chain = {\n    messageText,\n    category: ts15.DiagnosticCategory.Error,\n    code: 0,\n    next: [{\n      messageText: chainedMessage,\n      category: ts15.DiagnosticCategory.Message,\n      code: 0\n    }]\n  };\n  return new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, node, chain, relatedInformation);\n}\nfunction getProviderDiagnostics(providerClasses, providersDeclaration, registry) {\n  const diagnostics = [];\n  for (const provider of providerClasses) {\n    if (registry.isInjectable(provider.node)) {\n      continue;\n    }\n    const contextNode = provider.getOriginForDiagnostics(providersDeclaration);\n    diagnostics.push(makeDiagnostic(ErrorCode.UNDECORATED_PROVIDER, contextNode, `The class '${provider.node.name.text}' cannot be created via dependency injection, as it does not have an Angular decorator. This will result in an error at runtime.\n\nEither add the @Injectable() decorator to '${provider.node.name.text}', or configure a different provider (such as a provider with 'useFactory').\n`, [makeRelatedInformation(provider.node, `'${provider.node.name.text}' is declared here.`)]));\n  }\n  return diagnostics;\n}\nfunction getDirectiveDiagnostics(node, reader, evaluator, reflector, scopeRegistry, kind) {\n  let diagnostics = [];\n  const addDiagnostics = (more) => {\n    if (more === null) {\n      return;\n    } else if (diagnostics === null) {\n      diagnostics = Array.isArray(more) ? more : [more];\n    } else if (Array.isArray(more)) {\n      diagnostics.push(...more);\n    } else {\n      diagnostics.push(more);\n    }\n  };\n  const duplicateDeclarations = scopeRegistry.getDuplicateDeclarations(node);\n  if (duplicateDeclarations !== null) {\n    addDiagnostics(makeDuplicateDeclarationError(node, duplicateDeclarations, kind));\n  }\n  addDiagnostics(checkInheritanceOfDirective(node, reader, reflector, evaluator));\n  return diagnostics;\n}\nfunction getUndecoratedClassWithAngularFeaturesDiagnostic(node) {\n  return makeDiagnostic(ErrorCode.UNDECORATED_CLASS_USING_ANGULAR_FEATURES, node.name, `Class is using Angular features but is not decorated. Please add an explicit Angular decorator.`);\n}\nfunction checkInheritanceOfDirective(node, reader, reflector, evaluator) {\n  if (!reflector.isClass(node) || reflector.getConstructorParameters(node) !== null) {\n    return null;\n  }\n  let baseClass = readBaseClass(node, reflector, evaluator);\n  while (baseClass !== null) {\n    if (baseClass === \"dynamic\") {\n      return null;\n    }\n    const baseClassMeta = reader.getDirectiveMetadata(baseClass);\n    if (baseClassMeta !== null) {\n      return null;\n    }\n    const baseClassConstructorParams = reflector.getConstructorParameters(baseClass.node);\n    const newParentClass = readBaseClass(baseClass.node, reflector, evaluator);\n    if (baseClassConstructorParams !== null && baseClassConstructorParams.length > 0) {\n      return getInheritedUndecoratedCtorDiagnostic(node, baseClass, reader);\n    } else if (baseClassConstructorParams !== null || newParentClass === null) {\n      return null;\n    }\n    baseClass = newParentClass;\n  }\n  return null;\n}\nfunction getInheritedUndecoratedCtorDiagnostic(node, baseClass, reader) {\n  const subclassMeta = reader.getDirectiveMetadata(new Reference(node));\n  const dirOrComp = subclassMeta.isComponent ? \"Component\" : \"Directive\";\n  const baseClassName = baseClass.debugName;\n  return makeDiagnostic(ErrorCode.DIRECTIVE_INHERITS_UNDECORATED_CTOR, node.name, `The ${dirOrComp.toLowerCase()} ${node.name.text} inherits its constructor from ${baseClassName}, but the latter does not have an Angular decorator of its own. Dependency injection will not be able to resolve the parameters of ${baseClassName}'s constructor. Either add a @Directive decorator to ${baseClassName}, or add an explicit constructor to ${node.name.text}.`);\n}\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/src/directive.mjs\nimport { compileClassMetadata, compileDeclareClassMetadata, compileDeclareDirectiveFromMetadata, compileDirectiveFromMetadata, createMayBeForwardRefExpression, emitDistinctChangesOnlyDefaultValue, ExternalExpr as ExternalExpr3, FactoryTarget, getSafePropertyAccessString, makeBindingParser, parseHostBindings, verifyHostBindings, WrappedNodeExpr as WrappedNodeExpr3 } from \"@angular/compiler\";\nimport ts17 from \"typescript\";\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/src/factory.mjs\nimport { compileDeclareFactoryFunction, compileFactoryFunction } from \"@angular/compiler\";\nfunction compileNgFactoryDefField(metadata) {\n  const res = compileFactoryFunction(metadata);\n  return { name: \"\\u0275fac\", initializer: res.expression, statements: res.statements, type: res.type };\n}\nfunction compileDeclareFactory(metadata) {\n  const res = compileDeclareFactoryFunction(metadata);\n  return { name: \"\\u0275fac\", initializer: res.expression, statements: res.statements, type: res.type };\n}\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/src/metadata.mjs\nimport { FunctionExpr, LiteralArrayExpr, LiteralExpr as LiteralExpr2, literalMap, ReturnStatement, WrappedNodeExpr as WrappedNodeExpr2 } from \"@angular/compiler\";\nimport ts16 from \"typescript\";\nfunction extractClassMetadata(clazz, reflection, isCore, annotateForClosureCompiler, angularDecoratorTransform = (dec) => dec) {\n  if (!reflection.isClass(clazz)) {\n    return null;\n  }\n  const id = reflection.getAdjacentNameOfClass(clazz);\n  const classDecorators = reflection.getDecoratorsOfDeclaration(clazz);\n  if (classDecorators === null) {\n    return null;\n  }\n  const ngClassDecorators = classDecorators.filter((dec) => isAngularDecorator2(dec, isCore)).map((decorator) => decoratorToMetadata(angularDecoratorTransform(decorator), annotateForClosureCompiler)).map((decorator) => removeIdentifierReferences(decorator, id.text));\n  if (ngClassDecorators.length === 0) {\n    return null;\n  }\n  const metaDecorators = new WrappedNodeExpr2(ts16.createArrayLiteral(ngClassDecorators));\n  let metaCtorParameters = null;\n  const classCtorParameters = reflection.getConstructorParameters(clazz);\n  if (classCtorParameters !== null) {\n    const ctorParameters = classCtorParameters.map((param) => ctorParameterToMetadata(param, isCore));\n    metaCtorParameters = new FunctionExpr([], [\n      new ReturnStatement(new LiteralArrayExpr(ctorParameters))\n    ]);\n  }\n  let metaPropDecorators = null;\n  const classMembers = reflection.getMembersOfClass(clazz).filter((member) => !member.isStatic && member.decorators !== null && member.decorators.length > 0);\n  const duplicateDecoratedMemberNames = classMembers.map((member) => member.name).filter((name, i, arr) => arr.indexOf(name) < i);\n  if (duplicateDecoratedMemberNames.length > 0) {\n    throw new Error(`Duplicate decorated properties found on class '${clazz.name.text}': ` + duplicateDecoratedMemberNames.join(\", \"));\n  }\n  const decoratedMembers = classMembers.map((member) => {\n    var _a;\n    return classMemberToMetadata((_a = member.nameNode) != null ? _a : member.name, member.decorators, isCore);\n  });\n  if (decoratedMembers.length > 0) {\n    metaPropDecorators = new WrappedNodeExpr2(ts16.createObjectLiteral(decoratedMembers));\n  }\n  return {\n    type: new WrappedNodeExpr2(id),\n    decorators: metaDecorators,\n    ctorParameters: metaCtorParameters,\n    propDecorators: metaPropDecorators\n  };\n}\nfunction ctorParameterToMetadata(param, isCore) {\n  const type = param.typeValueReference.kind !== 2 ? valueReferenceToExpression(param.typeValueReference) : new LiteralExpr2(void 0);\n  const mapEntries = [\n    { key: \"type\", value: type, quoted: false }\n  ];\n  if (param.decorators !== null) {\n    const ngDecorators = param.decorators.filter((dec) => isAngularDecorator2(dec, isCore)).map((decorator) => decoratorToMetadata(decorator));\n    const value = new WrappedNodeExpr2(ts16.createArrayLiteral(ngDecorators));\n    mapEntries.push({ key: \"decorators\", value, quoted: false });\n  }\n  return literalMap(mapEntries);\n}\nfunction classMemberToMetadata(name, decorators, isCore) {\n  const ngDecorators = decorators.filter((dec) => isAngularDecorator2(dec, isCore)).map((decorator) => decoratorToMetadata(decorator));\n  const decoratorMeta = ts16.createArrayLiteral(ngDecorators);\n  return ts16.createPropertyAssignment(name, decoratorMeta);\n}\nfunction decoratorToMetadata(decorator, wrapFunctionsInParens) {\n  if (decorator.identifier === null) {\n    throw new Error(\"Illegal state: synthesized decorator cannot be emitted in class metadata.\");\n  }\n  const properties = [\n    ts16.createPropertyAssignment(\"type\", ts16.getMutableClone(decorator.identifier))\n  ];\n  if (decorator.args !== null && decorator.args.length > 0) {\n    const args = decorator.args.map((arg) => {\n      const expr = ts16.getMutableClone(arg);\n      return wrapFunctionsInParens ? wrapFunctionExpressionsInParens(expr) : expr;\n    });\n    properties.push(ts16.createPropertyAssignment(\"args\", ts16.createArrayLiteral(args)));\n  }\n  return ts16.createObjectLiteral(properties, true);\n}\nfunction isAngularDecorator2(decorator, isCore) {\n  return isCore || decorator.import !== null && decorator.import.from === \"@angular/core\";\n}\nfunction removeIdentifierReferences(node, name) {\n  const result = ts16.transform(node, [(context) => (root) => ts16.visitNode(root, function walk(current) {\n    return ts16.isIdentifier(current) && current.text === name ? ts16.createIdentifier(current.text) : ts16.visitEachChild(current, walk, context);\n  })]);\n  return result.transformed[0];\n}\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/src/directive.mjs\nvar EMPTY_OBJECT = {};\nvar FIELD_DECORATORS = [\n  \"Input\",\n  \"Output\",\n  \"ViewChild\",\n  \"ViewChildren\",\n  \"ContentChild\",\n  \"ContentChildren\",\n  \"HostBinding\",\n  \"HostListener\"\n];\nvar LIFECYCLE_HOOKS = new Set([\n  \"ngOnChanges\",\n  \"ngOnInit\",\n  \"ngOnDestroy\",\n  \"ngDoCheck\",\n  \"ngAfterViewInit\",\n  \"ngAfterViewChecked\",\n  \"ngAfterContentInit\",\n  \"ngAfterContentChecked\"\n]);\nvar DirectiveSymbol = class extends SemanticSymbol {\n  constructor(decl, selector, inputs, outputs, exportAs, typeCheckMeta, typeParameters) {\n    super(decl);\n    this.selector = selector;\n    this.inputs = inputs;\n    this.outputs = outputs;\n    this.exportAs = exportAs;\n    this.typeCheckMeta = typeCheckMeta;\n    this.typeParameters = typeParameters;\n    this.baseClass = null;\n  }\n  isPublicApiAffected(previousSymbol) {\n    if (!(previousSymbol instanceof DirectiveSymbol)) {\n      return true;\n    }\n    return this.selector !== previousSymbol.selector || !isArrayEqual(this.inputs.propertyNames, previousSymbol.inputs.propertyNames) || !isArrayEqual(this.outputs.propertyNames, previousSymbol.outputs.propertyNames) || !isArrayEqual(this.exportAs, previousSymbol.exportAs);\n  }\n  isTypeCheckApiAffected(previousSymbol) {\n    if (this.isPublicApiAffected(previousSymbol)) {\n      return true;\n    }\n    if (!(previousSymbol instanceof DirectiveSymbol)) {\n      return true;\n    }\n    if (!isArrayEqual(Array.from(this.inputs), Array.from(previousSymbol.inputs), isInputMappingEqual) || !isArrayEqual(Array.from(this.outputs), Array.from(previousSymbol.outputs), isInputMappingEqual)) {\n      return true;\n    }\n    if (!areTypeParametersEqual(this.typeParameters, previousSymbol.typeParameters)) {\n      return true;\n    }\n    if (!isTypeCheckMetaEqual(this.typeCheckMeta, previousSymbol.typeCheckMeta)) {\n      return true;\n    }\n    if (!isBaseClassEqual(this.baseClass, previousSymbol.baseClass)) {\n      return true;\n    }\n    return false;\n  }\n};\nfunction isInputMappingEqual(current, previous) {\n  return current[0] === previous[0] && current[1] === previous[1];\n}\nfunction isTypeCheckMetaEqual(current, previous) {\n  if (current.hasNgTemplateContextGuard !== previous.hasNgTemplateContextGuard) {\n    return false;\n  }\n  if (current.isGeneric !== previous.isGeneric) {\n    return false;\n  }\n  if (!isArrayEqual(current.ngTemplateGuards, previous.ngTemplateGuards, isTemplateGuardEqual)) {\n    return false;\n  }\n  if (!isSetEqual(current.coercedInputFields, previous.coercedInputFields)) {\n    return false;\n  }\n  if (!isSetEqual(current.restrictedInputFields, previous.restrictedInputFields)) {\n    return false;\n  }\n  if (!isSetEqual(current.stringLiteralInputFields, previous.stringLiteralInputFields)) {\n    return false;\n  }\n  if (!isSetEqual(current.undeclaredInputFields, previous.undeclaredInputFields)) {\n    return false;\n  }\n  return true;\n}\nfunction isTemplateGuardEqual(current, previous) {\n  return current.inputName === previous.inputName && current.type === previous.type;\n}\nfunction isBaseClassEqual(current, previous) {\n  if (current === null || previous === null) {\n    return current === previous;\n  }\n  return isSymbolEqual(current, previous);\n}\nvar DirectiveDecoratorHandler = class {\n  constructor(reflector, evaluator, metaRegistry, scopeRegistry, metaReader, injectableRegistry, isCore, semanticDepGraphUpdater, annotateForClosureCompiler, compileUndecoratedClassesWithAngularFeatures, perf) {\n    this.reflector = reflector;\n    this.evaluator = evaluator;\n    this.metaRegistry = metaRegistry;\n    this.scopeRegistry = scopeRegistry;\n    this.metaReader = metaReader;\n    this.injectableRegistry = injectableRegistry;\n    this.isCore = isCore;\n    this.semanticDepGraphUpdater = semanticDepGraphUpdater;\n    this.annotateForClosureCompiler = annotateForClosureCompiler;\n    this.compileUndecoratedClassesWithAngularFeatures = compileUndecoratedClassesWithAngularFeatures;\n    this.perf = perf;\n    this.precedence = HandlerPrecedence.PRIMARY;\n    this.name = DirectiveDecoratorHandler.name;\n  }\n  detect(node, decorators) {\n    if (!decorators) {\n      const angularField = this.findClassFieldWithAngularFeatures(node);\n      return angularField ? { trigger: angularField.node, decorator: null, metadata: null } : void 0;\n    } else {\n      const decorator = findAngularDecorator(decorators, \"Directive\", this.isCore);\n      return decorator ? { trigger: decorator.node, decorator, metadata: decorator } : void 0;\n    }\n  }\n  analyze(node, decorator, flags = HandlerFlags.NONE) {\n    if (this.compileUndecoratedClassesWithAngularFeatures === false && decorator === null) {\n      return { diagnostics: [getUndecoratedClassWithAngularFeaturesDiagnostic(node)] };\n    }\n    this.perf.eventCount(PerfEvent.AnalyzeDirective);\n    const directiveResult = extractDirectiveMetadata(node, decorator, this.reflector, this.evaluator, this.isCore, flags, this.annotateForClosureCompiler);\n    if (directiveResult === void 0) {\n      return {};\n    }\n    const analysis = directiveResult.metadata;\n    let providersRequiringFactory = null;\n    if (directiveResult !== void 0 && directiveResult.decorator.has(\"providers\")) {\n      providersRequiringFactory = resolveProvidersRequiringFactory(directiveResult.decorator.get(\"providers\"), this.reflector, this.evaluator);\n    }\n    return {\n      analysis: {\n        inputs: directiveResult.inputs,\n        outputs: directiveResult.outputs,\n        meta: analysis,\n        classMetadata: extractClassMetadata(node, this.reflector, this.isCore, this.annotateForClosureCompiler),\n        baseClass: readBaseClass(node, this.reflector, this.evaluator),\n        typeCheckMeta: extractDirectiveTypeCheckMeta(node, directiveResult.inputs, this.reflector),\n        providersRequiringFactory,\n        isPoisoned: false,\n        isStructural: directiveResult.isStructural\n      }\n    };\n  }\n  symbol(node, analysis) {\n    const typeParameters = extractSemanticTypeParameters(node);\n    return new DirectiveSymbol(node, analysis.meta.selector, analysis.inputs, analysis.outputs, analysis.meta.exportAs, analysis.typeCheckMeta, typeParameters);\n  }\n  register(node, analysis) {\n    const ref = new Reference(node);\n    this.metaRegistry.registerDirectiveMetadata(__spreadProps(__spreadValues({\n      type: MetaType.Directive,\n      ref,\n      name: node.name.text,\n      selector: analysis.meta.selector,\n      exportAs: analysis.meta.exportAs,\n      inputs: analysis.inputs,\n      outputs: analysis.outputs,\n      queries: analysis.meta.queries.map((query) => query.propertyName),\n      isComponent: false,\n      baseClass: analysis.baseClass\n    }, analysis.typeCheckMeta), {\n      isPoisoned: analysis.isPoisoned,\n      isStructural: analysis.isStructural\n    }));\n    this.injectableRegistry.registerInjectable(node);\n  }\n  resolve(node, analysis, symbol) {\n    if (this.semanticDepGraphUpdater !== null && analysis.baseClass instanceof Reference) {\n      symbol.baseClass = this.semanticDepGraphUpdater.getSymbol(analysis.baseClass.node);\n    }\n    const diagnostics = [];\n    if (analysis.providersRequiringFactory !== null && analysis.meta.providers instanceof WrappedNodeExpr3) {\n      const providerDiagnostics = getProviderDiagnostics(analysis.providersRequiringFactory, analysis.meta.providers.node, this.injectableRegistry);\n      diagnostics.push(...providerDiagnostics);\n    }\n    const directiveDiagnostics = getDirectiveDiagnostics(node, this.metaReader, this.evaluator, this.reflector, this.scopeRegistry, \"Directive\");\n    if (directiveDiagnostics !== null) {\n      diagnostics.push(...directiveDiagnostics);\n    }\n    return { diagnostics: diagnostics.length > 0 ? diagnostics : void 0 };\n  }\n  compileFull(node, analysis, resolution, pool) {\n    const fac = compileNgFactoryDefField(toFactoryMetadata(analysis.meta, FactoryTarget.Directive));\n    const def = compileDirectiveFromMetadata(analysis.meta, pool, makeBindingParser());\n    const classMetadata = analysis.classMetadata !== null ? compileClassMetadata(analysis.classMetadata).toStmt() : null;\n    return compileResults(fac, def, classMetadata, \"\\u0275dir\");\n  }\n  compilePartial(node, analysis, resolution) {\n    const fac = compileDeclareFactory(toFactoryMetadata(analysis.meta, FactoryTarget.Directive));\n    const def = compileDeclareDirectiveFromMetadata(analysis.meta);\n    const classMetadata = analysis.classMetadata !== null ? compileDeclareClassMetadata(analysis.classMetadata).toStmt() : null;\n    return compileResults(fac, def, classMetadata, \"\\u0275dir\");\n  }\n  findClassFieldWithAngularFeatures(node) {\n    return this.reflector.getMembersOfClass(node).find((member) => {\n      if (!member.isStatic && member.kind === ClassMemberKind.Method && LIFECYCLE_HOOKS.has(member.name)) {\n        return true;\n      }\n      if (member.decorators) {\n        return member.decorators.some((decorator) => FIELD_DECORATORS.some((decoratorName) => isAngularDecorator(decorator, decoratorName, this.isCore)));\n      }\n      return false;\n    });\n  }\n};\nfunction extractDirectiveMetadata(clazz, decorator, reflector, evaluator, isCore, flags, annotateForClosureCompiler, defaultSelector = null) {\n  let directive;\n  if (decorator === null || decorator.args === null || decorator.args.length === 0) {\n    directive = new Map();\n  } else if (decorator.args.length !== 1) {\n    throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(decorator), `Incorrect number of arguments to @${decorator.name} decorator`);\n  } else {\n    const meta = unwrapExpression(decorator.args[0]);\n    if (!ts17.isObjectLiteralExpression(meta)) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, `@${decorator.name} argument must be an object literal`);\n    }\n    directive = reflectObjectLiteral(meta);\n  }\n  if (directive.has(\"jit\")) {\n    return void 0;\n  }\n  const members = reflector.getMembersOfClass(clazz);\n  const decoratedElements = members.filter((member) => !member.isStatic && member.decorators !== null);\n  const coreModule = isCore ? void 0 : \"@angular/core\";\n  const inputsFromMeta = parseFieldToPropertyMapping(directive, \"inputs\", evaluator);\n  const inputsFromFields = parseDecoratedFields(filterToMembersWithDecorator(decoratedElements, \"Input\", coreModule), evaluator, resolveInput);\n  const outputsFromMeta = parseFieldToPropertyMapping(directive, \"outputs\", evaluator);\n  const outputsFromFields = parseDecoratedFields(filterToMembersWithDecorator(decoratedElements, \"Output\", coreModule), evaluator, resolveOutput);\n  const contentChildFromFields = queriesFromFields(filterToMembersWithDecorator(decoratedElements, \"ContentChild\", coreModule), reflector, evaluator);\n  const contentChildrenFromFields = queriesFromFields(filterToMembersWithDecorator(decoratedElements, \"ContentChildren\", coreModule), reflector, evaluator);\n  const queries = [...contentChildFromFields, ...contentChildrenFromFields];\n  const viewChildFromFields = queriesFromFields(filterToMembersWithDecorator(decoratedElements, \"ViewChild\", coreModule), reflector, evaluator);\n  const viewChildrenFromFields = queriesFromFields(filterToMembersWithDecorator(decoratedElements, \"ViewChildren\", coreModule), reflector, evaluator);\n  const viewQueries = [...viewChildFromFields, ...viewChildrenFromFields];\n  if (directive.has(\"queries\")) {\n    const queriesFromDecorator = extractQueriesFromDecorator(directive.get(\"queries\"), reflector, evaluator, isCore);\n    queries.push(...queriesFromDecorator.content);\n    viewQueries.push(...queriesFromDecorator.view);\n  }\n  let selector = defaultSelector;\n  if (directive.has(\"selector\")) {\n    const expr = directive.get(\"selector\");\n    const resolved = evaluator.evaluate(expr);\n    if (typeof resolved !== \"string\") {\n      throw createValueHasWrongTypeError(expr, resolved, `selector must be a string`);\n    }\n    selector = resolved === \"\" ? defaultSelector : resolved;\n    if (!selector) {\n      throw new FatalDiagnosticError(ErrorCode.DIRECTIVE_MISSING_SELECTOR, expr, `Directive ${clazz.name.text} has no selector, please add it!`);\n    }\n  }\n  const host = extractHostBindings(decoratedElements, evaluator, coreModule, directive);\n  const providers = directive.has(\"providers\") ? new WrappedNodeExpr3(annotateForClosureCompiler ? wrapFunctionExpressionsInParens(directive.get(\"providers\")) : directive.get(\"providers\")) : null;\n  const usesOnChanges = members.some((member) => !member.isStatic && member.kind === ClassMemberKind.Method && member.name === \"ngOnChanges\");\n  let exportAs = null;\n  if (directive.has(\"exportAs\")) {\n    const expr = directive.get(\"exportAs\");\n    const resolved = evaluator.evaluate(expr);\n    if (typeof resolved !== \"string\") {\n      throw createValueHasWrongTypeError(expr, resolved, `exportAs must be a string`);\n    }\n    exportAs = resolved.split(\",\").map((part) => part.trim());\n  }\n  const rawCtorDeps = getConstructorDependencies(clazz, reflector, isCore);\n  const ctorDeps = selector !== null ? validateConstructorDependencies(clazz, rawCtorDeps) : unwrapConstructorDependencies(rawCtorDeps);\n  const isStructural = ctorDeps !== null && ctorDeps !== \"invalid\" && ctorDeps.some((dep) => dep.token instanceof ExternalExpr3 && dep.token.value.moduleName === \"@angular/core\" && dep.token.value.name === \"TemplateRef\");\n  const usesInheritance = reflector.hasBaseClass(clazz);\n  const type = wrapTypeReference(reflector, clazz);\n  const internalType = new WrappedNodeExpr3(reflector.getInternalNameOfClass(clazz));\n  const inputs = ClassPropertyMapping.fromMappedObject(__spreadValues(__spreadValues({}, inputsFromMeta), inputsFromFields));\n  const outputs = ClassPropertyMapping.fromMappedObject(__spreadValues(__spreadValues({}, outputsFromMeta), outputsFromFields));\n  const metadata = {\n    name: clazz.name.text,\n    deps: ctorDeps,\n    host,\n    lifecycle: {\n      usesOnChanges\n    },\n    inputs: inputs.toJointMappedObject(),\n    outputs: outputs.toDirectMappedObject(),\n    queries,\n    viewQueries,\n    selector,\n    fullInheritance: !!(flags & HandlerFlags.FULL_INHERITANCE),\n    type,\n    internalType,\n    typeArgumentCount: reflector.getGenericArityOfClass(clazz) || 0,\n    typeSourceSpan: createSourceSpan(clazz.name),\n    usesInheritance,\n    exportAs,\n    providers\n  };\n  return {\n    decorator: directive,\n    metadata,\n    inputs,\n    outputs,\n    isStructural\n  };\n}\nfunction extractQueryMetadata(exprNode, name, args, propertyName, reflector, evaluator) {\n  if (args.length === 0) {\n    throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, exprNode, `@${name} must have arguments`);\n  }\n  const first = name === \"ViewChild\" || name === \"ContentChild\";\n  const forwardReferenceTarget = tryUnwrapForwardRef(args[0], reflector);\n  const node = forwardReferenceTarget != null ? forwardReferenceTarget : args[0];\n  const arg = evaluator.evaluate(node);\n  let isStatic = false;\n  let predicate = null;\n  if (arg instanceof Reference || arg instanceof DynamicValue) {\n    predicate = createMayBeForwardRefExpression(new WrappedNodeExpr3(node), forwardReferenceTarget !== null ? 2 : 0);\n  } else if (typeof arg === \"string\") {\n    predicate = [arg];\n  } else if (isStringArrayOrDie(arg, `@${name} predicate`, node)) {\n    predicate = arg;\n  } else {\n    throw createValueHasWrongTypeError(node, arg, `@${name} predicate cannot be interpreted`);\n  }\n  let read = null;\n  let descendants = name !== \"ContentChildren\";\n  let emitDistinctChangesOnly = emitDistinctChangesOnlyDefaultValue;\n  if (args.length === 2) {\n    const optionsExpr = unwrapExpression(args[1]);\n    if (!ts17.isObjectLiteralExpression(optionsExpr)) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, optionsExpr, `@${name} options must be an object literal`);\n    }\n    const options = reflectObjectLiteral(optionsExpr);\n    if (options.has(\"read\")) {\n      read = new WrappedNodeExpr3(options.get(\"read\"));\n    }\n    if (options.has(\"descendants\")) {\n      const descendantsExpr = options.get(\"descendants\");\n      const descendantsValue = evaluator.evaluate(descendantsExpr);\n      if (typeof descendantsValue !== \"boolean\") {\n        throw createValueHasWrongTypeError(descendantsExpr, descendantsValue, `@${name} options.descendants must be a boolean`);\n      }\n      descendants = descendantsValue;\n    }\n    if (options.has(\"emitDistinctChangesOnly\")) {\n      const emitDistinctChangesOnlyExpr = options.get(\"emitDistinctChangesOnly\");\n      const emitDistinctChangesOnlyValue = evaluator.evaluate(emitDistinctChangesOnlyExpr);\n      if (typeof emitDistinctChangesOnlyValue !== \"boolean\") {\n        throw createValueHasWrongTypeError(emitDistinctChangesOnlyExpr, emitDistinctChangesOnlyValue, `@${name} options.emitDistinctChangesOnly must be a boolean`);\n      }\n      emitDistinctChangesOnly = emitDistinctChangesOnlyValue;\n    }\n    if (options.has(\"static\")) {\n      const staticValue = evaluator.evaluate(options.get(\"static\"));\n      if (typeof staticValue !== \"boolean\") {\n        throw createValueHasWrongTypeError(node, staticValue, `@${name} options.static must be a boolean`);\n      }\n      isStatic = staticValue;\n    }\n  } else if (args.length > 2) {\n    throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, node, `@${name} has too many arguments`);\n  }\n  return {\n    propertyName,\n    predicate,\n    first,\n    descendants,\n    read,\n    static: isStatic,\n    emitDistinctChangesOnly\n  };\n}\nfunction extractQueriesFromDecorator(queryData, reflector, evaluator, isCore) {\n  const content = [], view = [];\n  if (!ts17.isObjectLiteralExpression(queryData)) {\n    throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, queryData, \"Decorator queries metadata must be an object literal\");\n  }\n  reflectObjectLiteral(queryData).forEach((queryExpr, propertyName) => {\n    queryExpr = unwrapExpression(queryExpr);\n    if (!ts17.isNewExpression(queryExpr)) {\n      throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, queryData, \"Decorator query metadata must be an instance of a query type\");\n    }\n    const queryType = ts17.isPropertyAccessExpression(queryExpr.expression) ? queryExpr.expression.name : queryExpr.expression;\n    if (!ts17.isIdentifier(queryType)) {\n      throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, queryData, \"Decorator query metadata must be an instance of a query type\");\n    }\n    const type = reflector.getImportOfIdentifier(queryType);\n    if (type === null || !isCore && type.from !== \"@angular/core\" || !QUERY_TYPES.has(type.name)) {\n      throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, queryData, \"Decorator query metadata must be an instance of a query type\");\n    }\n    const query = extractQueryMetadata(queryExpr, type.name, queryExpr.arguments || [], propertyName, reflector, evaluator);\n    if (type.name.startsWith(\"Content\")) {\n      content.push(query);\n    } else {\n      view.push(query);\n    }\n  });\n  return { content, view };\n}\nfunction isStringArrayOrDie(value, name, node) {\n  if (!Array.isArray(value)) {\n    return false;\n  }\n  for (let i = 0; i < value.length; i++) {\n    if (typeof value[i] !== \"string\") {\n      throw createValueHasWrongTypeError(node, value[i], `Failed to resolve ${name} at position ${i} to a string`);\n    }\n  }\n  return true;\n}\nfunction parseFieldArrayValue(directive, field, evaluator) {\n  if (!directive.has(field)) {\n    return null;\n  }\n  const expression = directive.get(field);\n  const value = evaluator.evaluate(expression);\n  if (!isStringArrayOrDie(value, field, expression)) {\n    throw createValueHasWrongTypeError(expression, value, `Failed to resolve @Directive.${field} to a string array`);\n  }\n  return value;\n}\nfunction parseFieldToPropertyMapping(directive, field, evaluator) {\n  const metaValues = parseFieldArrayValue(directive, field, evaluator);\n  if (!metaValues) {\n    return EMPTY_OBJECT;\n  }\n  return metaValues.reduce((results, value) => {\n    const [field2, property] = value.split(\":\", 2).map((str) => str.trim());\n    results[field2] = property || field2;\n    return results;\n  }, {});\n}\nfunction parseDecoratedFields(fields, evaluator, mapValueResolver) {\n  return fields.reduce((results, field) => {\n    const fieldName = field.member.name;\n    field.decorators.forEach((decorator) => {\n      if (decorator.args == null || decorator.args.length === 0) {\n        results[fieldName] = fieldName;\n      } else if (decorator.args.length === 1) {\n        const property = evaluator.evaluate(decorator.args[0]);\n        if (typeof property !== \"string\") {\n          throw createValueHasWrongTypeError(Decorator.nodeForError(decorator), property, `@${decorator.name} decorator argument must resolve to a string`);\n        }\n        results[fieldName] = mapValueResolver(property, fieldName);\n      } else {\n        throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(decorator), `@${decorator.name} can have at most one argument, got ${decorator.args.length} argument(s)`);\n      }\n    });\n    return results;\n  }, {});\n}\nfunction resolveInput(publicName, internalName) {\n  return [publicName, internalName];\n}\nfunction resolveOutput(publicName, internalName) {\n  return publicName;\n}\nfunction queriesFromFields(fields, reflector, evaluator) {\n  return fields.map(({ member, decorators }) => {\n    const decorator = decorators[0];\n    const node = member.node || Decorator.nodeForError(decorator);\n    if (member.decorators.some((v) => v.name === \"Input\")) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_COLLISION, node, \"Cannot combine @Input decorators with query decorators\");\n    }\n    if (decorators.length !== 1) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_COLLISION, node, \"Cannot have multiple query decorators on the same class member\");\n    } else if (!isPropertyTypeMember(member)) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_UNEXPECTED, node, \"Query decorator must go on a property-type member\");\n    }\n    return extractQueryMetadata(node, decorator.name, decorator.args || [], member.name, reflector, evaluator);\n  });\n}\nfunction isPropertyTypeMember(member) {\n  return member.kind === ClassMemberKind.Getter || member.kind === ClassMemberKind.Setter || member.kind === ClassMemberKind.Property;\n}\nfunction evaluateHostExpressionBindings(hostExpr, evaluator) {\n  const hostMetaMap = evaluator.evaluate(hostExpr);\n  if (!(hostMetaMap instanceof Map)) {\n    throw createValueHasWrongTypeError(hostExpr, hostMetaMap, `Decorator host metadata must be an object`);\n  }\n  const hostMetadata = {};\n  hostMetaMap.forEach((value, key) => {\n    if (value instanceof EnumValue) {\n      value = value.resolved;\n    }\n    if (typeof key !== \"string\") {\n      throw createValueHasWrongTypeError(hostExpr, key, `Decorator host metadata must be a string -> string object, but found unparseable key`);\n    }\n    if (typeof value == \"string\") {\n      hostMetadata[key] = value;\n    } else if (value instanceof DynamicValue) {\n      hostMetadata[key] = new WrappedNodeExpr3(value.node);\n    } else {\n      throw createValueHasWrongTypeError(hostExpr, value, `Decorator host metadata must be a string -> string object, but found unparseable value`);\n    }\n  });\n  const bindings = parseHostBindings(hostMetadata);\n  const errors = verifyHostBindings(bindings, createSourceSpan(hostExpr));\n  if (errors.length > 0) {\n    throw new FatalDiagnosticError(ErrorCode.HOST_BINDING_PARSE_ERROR, hostExpr, errors.map((error) => error.msg).join(\"\\n\"));\n  }\n  return bindings;\n}\nfunction extractHostBindings(members, evaluator, coreModule, metadata) {\n  let bindings;\n  if (metadata && metadata.has(\"host\")) {\n    bindings = evaluateHostExpressionBindings(metadata.get(\"host\"), evaluator);\n  } else {\n    bindings = parseHostBindings({});\n  }\n  filterToMembersWithDecorator(members, \"HostBinding\", coreModule).forEach(({ member, decorators }) => {\n    decorators.forEach((decorator) => {\n      let hostPropertyName = member.name;\n      if (decorator.args !== null && decorator.args.length > 0) {\n        if (decorator.args.length !== 1) {\n          throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(decorator), `@HostBinding can have at most one argument, got ${decorator.args.length} argument(s)`);\n        }\n        const resolved = evaluator.evaluate(decorator.args[0]);\n        if (typeof resolved !== \"string\") {\n          throw createValueHasWrongTypeError(Decorator.nodeForError(decorator), resolved, `@HostBinding's argument must be a string`);\n        }\n        hostPropertyName = resolved;\n      }\n      bindings.properties[hostPropertyName] = getSafePropertyAccessString(\"this\", member.name);\n    });\n  });\n  filterToMembersWithDecorator(members, \"HostListener\", coreModule).forEach(({ member, decorators }) => {\n    decorators.forEach((decorator) => {\n      let eventName = member.name;\n      let args = [];\n      if (decorator.args !== null && decorator.args.length > 0) {\n        if (decorator.args.length > 2) {\n          throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, decorator.args[2], `@HostListener can have at most two arguments`);\n        }\n        const resolved = evaluator.evaluate(decorator.args[0]);\n        if (typeof resolved !== \"string\") {\n          throw createValueHasWrongTypeError(decorator.args[0], resolved, `@HostListener's event name argument must be a string`);\n        }\n        eventName = resolved;\n        if (decorator.args.length === 2) {\n          const expression = decorator.args[1];\n          const resolvedArgs = evaluator.evaluate(decorator.args[1]);\n          if (!isStringArrayOrDie(resolvedArgs, \"@HostListener.args\", expression)) {\n            throw createValueHasWrongTypeError(decorator.args[1], resolvedArgs, `@HostListener's second argument must be a string array`);\n          }\n          args = resolvedArgs;\n        }\n      }\n      bindings.listeners[eventName] = `${member.name}(${args.join(\",\")})`;\n    });\n  });\n  return bindings;\n}\nvar QUERY_TYPES = new Set([\n  \"ContentChild\",\n  \"ContentChildren\",\n  \"ViewChild\",\n  \"ViewChildren\"\n]);\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/src/ng_module.mjs\nimport { compileClassMetadata as compileClassMetadata2, compileDeclareClassMetadata as compileDeclareClassMetadata2, compileDeclareInjectorFromMetadata, compileDeclareNgModuleFromMetadata, compileInjector, compileNgModule, CUSTOM_ELEMENTS_SCHEMA, ExternalExpr as ExternalExpr4, FactoryTarget as FactoryTarget2, InvokeFunctionExpr, LiteralArrayExpr as LiteralArrayExpr2, NO_ERRORS_SCHEMA, R3Identifiers, WrappedNodeExpr as WrappedNodeExpr4 } from \"@angular/compiler\";\nimport ts18 from \"typescript\";\nvar NgModuleSymbol = class extends SemanticSymbol {\n  constructor() {\n    super(...arguments);\n    this.remotelyScopedComponents = [];\n  }\n  isPublicApiAffected(previousSymbol) {\n    if (!(previousSymbol instanceof NgModuleSymbol)) {\n      return true;\n    }\n    return false;\n  }\n  isEmitAffected(previousSymbol) {\n    if (!(previousSymbol instanceof NgModuleSymbol)) {\n      return true;\n    }\n    if (previousSymbol.remotelyScopedComponents.length !== this.remotelyScopedComponents.length) {\n      return true;\n    }\n    for (const currEntry of this.remotelyScopedComponents) {\n      const prevEntry = previousSymbol.remotelyScopedComponents.find((prevEntry2) => {\n        return isSymbolEqual(prevEntry2.component, currEntry.component);\n      });\n      if (prevEntry === void 0) {\n        return true;\n      }\n      if (!isArrayEqual(currEntry.usedDirectives, prevEntry.usedDirectives, isReferenceEqual)) {\n        return true;\n      }\n      if (!isArrayEqual(currEntry.usedPipes, prevEntry.usedPipes, isReferenceEqual)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  isTypeCheckApiAffected(previousSymbol) {\n    if (!(previousSymbol instanceof NgModuleSymbol)) {\n      return true;\n    }\n    return false;\n  }\n  addRemotelyScopedComponent(component, usedDirectives, usedPipes) {\n    this.remotelyScopedComponents.push({ component, usedDirectives, usedPipes });\n  }\n};\nvar NgModuleDecoratorHandler = class {\n  constructor(reflector, evaluator, metaReader, metaRegistry, scopeRegistry, referencesRegistry, isCore, refEmitter, factoryTracker, annotateForClosureCompiler, injectableRegistry, perf) {\n    this.reflector = reflector;\n    this.evaluator = evaluator;\n    this.metaReader = metaReader;\n    this.metaRegistry = metaRegistry;\n    this.scopeRegistry = scopeRegistry;\n    this.referencesRegistry = referencesRegistry;\n    this.isCore = isCore;\n    this.refEmitter = refEmitter;\n    this.factoryTracker = factoryTracker;\n    this.annotateForClosureCompiler = annotateForClosureCompiler;\n    this.injectableRegistry = injectableRegistry;\n    this.perf = perf;\n    this.precedence = HandlerPrecedence.PRIMARY;\n    this.name = NgModuleDecoratorHandler.name;\n  }\n  detect(node, decorators) {\n    if (!decorators) {\n      return void 0;\n    }\n    const decorator = findAngularDecorator(decorators, \"NgModule\", this.isCore);\n    if (decorator !== void 0) {\n      return {\n        trigger: decorator.node,\n        decorator,\n        metadata: decorator\n      };\n    } else {\n      return void 0;\n    }\n  }\n  analyze(node, decorator) {\n    this.perf.eventCount(PerfEvent.AnalyzeNgModule);\n    const name = node.name.text;\n    if (decorator.args === null || decorator.args.length > 1) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(decorator), `Incorrect number of arguments to @NgModule decorator`);\n    }\n    const meta = decorator.args.length === 1 ? unwrapExpression(decorator.args[0]) : ts18.createObjectLiteral([]);\n    if (!ts18.isObjectLiteralExpression(meta)) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, \"@NgModule argument must be an object literal\");\n    }\n    const ngModule = reflectObjectLiteral(meta);\n    if (ngModule.has(\"jit\")) {\n      return {};\n    }\n    const moduleResolvers = combineResolvers([\n      (ref) => this._extractModuleFromModuleWithProvidersFn(ref.node),\n      forwardRefResolver\n    ]);\n    const diagnostics = [];\n    let declarationRefs = [];\n    let rawDeclarations = null;\n    if (ngModule.has(\"declarations\")) {\n      rawDeclarations = ngModule.get(\"declarations\");\n      const declarationMeta = this.evaluator.evaluate(rawDeclarations, forwardRefResolver);\n      declarationRefs = this.resolveTypeList(rawDeclarations, declarationMeta, name, \"declarations\");\n      for (const ref of declarationRefs) {\n        if (ref.node.getSourceFile().isDeclarationFile) {\n          const errorNode = ref.getOriginForDiagnostics(rawDeclarations);\n          diagnostics.push(makeDiagnostic(ErrorCode.NGMODULE_INVALID_DECLARATION, errorNode, `Cannot declare '${ref.node.name.text}' in an NgModule as it's not a part of the current compilation.`, [makeRelatedInformation(ref.node.name, `'${ref.node.name.text}' is declared here.`)]));\n        }\n      }\n    }\n    if (diagnostics.length > 0) {\n      return { diagnostics };\n    }\n    let importRefs = [];\n    if (ngModule.has(\"imports\")) {\n      const rawImports = ngModule.get(\"imports\");\n      const importsMeta = this.evaluator.evaluate(rawImports, moduleResolvers);\n      importRefs = this.resolveTypeList(rawImports, importsMeta, name, \"imports\");\n    }\n    let exportRefs = [];\n    if (ngModule.has(\"exports\")) {\n      const rawExports = ngModule.get(\"exports\");\n      const exportsMeta = this.evaluator.evaluate(rawExports, moduleResolvers);\n      exportRefs = this.resolveTypeList(rawExports, exportsMeta, name, \"exports\");\n      this.referencesRegistry.add(node, ...exportRefs);\n    }\n    let bootstrapRefs = [];\n    if (ngModule.has(\"bootstrap\")) {\n      const expr = ngModule.get(\"bootstrap\");\n      const bootstrapMeta = this.evaluator.evaluate(expr, forwardRefResolver);\n      bootstrapRefs = this.resolveTypeList(expr, bootstrapMeta, name, \"bootstrap\");\n    }\n    const schemas = [];\n    if (ngModule.has(\"schemas\")) {\n      const rawExpr = ngModule.get(\"schemas\");\n      const result = this.evaluator.evaluate(rawExpr);\n      if (!Array.isArray(result)) {\n        throw createValueHasWrongTypeError(rawExpr, result, `NgModule.schemas must be an array`);\n      }\n      for (const schemaRef of result) {\n        if (!(schemaRef instanceof Reference)) {\n          throw createValueHasWrongTypeError(rawExpr, result, \"NgModule.schemas must be an array of schemas\");\n        }\n        const id2 = schemaRef.getIdentityIn(schemaRef.node.getSourceFile());\n        if (id2 === null || schemaRef.ownedByModuleGuess !== \"@angular/core\") {\n          throw createValueHasWrongTypeError(rawExpr, result, \"NgModule.schemas must be an array of schemas\");\n        }\n        switch (id2.text) {\n          case \"CUSTOM_ELEMENTS_SCHEMA\":\n            schemas.push(CUSTOM_ELEMENTS_SCHEMA);\n            break;\n          case \"NO_ERRORS_SCHEMA\":\n            schemas.push(NO_ERRORS_SCHEMA);\n            break;\n          default:\n            throw createValueHasWrongTypeError(rawExpr, schemaRef, `'${schemaRef.debugName}' is not a valid NgModule schema`);\n        }\n      }\n    }\n    const id = ngModule.has(\"id\") ? new WrappedNodeExpr4(ngModule.get(\"id\")) : null;\n    const valueContext = node.getSourceFile();\n    let typeContext = valueContext;\n    const typeNode = this.reflector.getDtsDeclaration(node);\n    if (typeNode !== null) {\n      typeContext = typeNode.getSourceFile();\n    }\n    const bootstrap = bootstrapRefs.map((bootstrap2) => this._toR3Reference(bootstrap2, valueContext, typeContext));\n    const declarations = declarationRefs.map((decl) => this._toR3Reference(decl, valueContext, typeContext));\n    const imports = importRefs.map((imp) => this._toR3Reference(imp, valueContext, typeContext));\n    const exports = exportRefs.map((exp) => this._toR3Reference(exp, valueContext, typeContext));\n    const isForwardReference = (ref) => isExpressionForwardReference(ref.value, node.name, valueContext);\n    const containsForwardDecls = bootstrap.some(isForwardReference) || declarations.some(isForwardReference) || imports.some(isForwardReference) || exports.some(isForwardReference);\n    const type = wrapTypeReference(this.reflector, node);\n    const internalType = new WrappedNodeExpr4(this.reflector.getInternalNameOfClass(node));\n    const adjacentType = new WrappedNodeExpr4(this.reflector.getAdjacentNameOfClass(node));\n    const ngModuleMetadata = {\n      type,\n      internalType,\n      adjacentType,\n      bootstrap,\n      declarations,\n      exports,\n      imports,\n      containsForwardDecls,\n      id,\n      emitInline: false,\n      schemas: []\n    };\n    const rawProviders = ngModule.has(\"providers\") ? ngModule.get(\"providers\") : null;\n    const wrapperProviders = rawProviders !== null ? new WrappedNodeExpr4(this.annotateForClosureCompiler ? wrapFunctionExpressionsInParens(rawProviders) : rawProviders) : null;\n    const injectorImports = [];\n    if (ngModule.has(\"imports\")) {\n      injectorImports.push(new WrappedNodeExpr4(ngModule.get(\"imports\")));\n    }\n    const injectorMetadata = {\n      name,\n      type,\n      internalType,\n      providers: wrapperProviders,\n      imports: injectorImports\n    };\n    const factoryMetadata = {\n      name,\n      type,\n      internalType,\n      typeArgumentCount: 0,\n      deps: getValidConstructorDependencies(node, this.reflector, this.isCore),\n      target: FactoryTarget2.NgModule\n    };\n    return {\n      analysis: {\n        id,\n        schemas,\n        mod: ngModuleMetadata,\n        inj: injectorMetadata,\n        fac: factoryMetadata,\n        declarations: declarationRefs,\n        rawDeclarations,\n        imports: importRefs,\n        exports: exportRefs,\n        providers: rawProviders,\n        providersRequiringFactory: rawProviders ? resolveProvidersRequiringFactory(rawProviders, this.reflector, this.evaluator) : null,\n        classMetadata: extractClassMetadata(node, this.reflector, this.isCore, this.annotateForClosureCompiler),\n        factorySymbolName: node.name.text\n      }\n    };\n  }\n  symbol(node) {\n    return new NgModuleSymbol(node);\n  }\n  register(node, analysis) {\n    this.metaRegistry.registerNgModuleMetadata({\n      ref: new Reference(node),\n      schemas: analysis.schemas,\n      declarations: analysis.declarations,\n      imports: analysis.imports,\n      exports: analysis.exports,\n      rawDeclarations: analysis.rawDeclarations\n    });\n    if (this.factoryTracker !== null) {\n      this.factoryTracker.track(node.getSourceFile(), {\n        name: analysis.factorySymbolName,\n        hasId: analysis.id !== null\n      });\n    }\n    this.injectableRegistry.registerInjectable(node);\n  }\n  resolve(node, analysis) {\n    const scope = this.scopeRegistry.getScopeOfModule(node);\n    const diagnostics = [];\n    const scopeDiagnostics = this.scopeRegistry.getDiagnosticsOfModule(node);\n    if (scopeDiagnostics !== null) {\n      diagnostics.push(...scopeDiagnostics);\n    }\n    if (analysis.providersRequiringFactory !== null) {\n      const providerDiagnostics = getProviderDiagnostics(analysis.providersRequiringFactory, analysis.providers, this.injectableRegistry);\n      diagnostics.push(...providerDiagnostics);\n    }\n    const data = {\n      injectorImports: []\n    };\n    if (scope !== null && !scope.compilation.isPoisoned) {\n      const context = getSourceFile(node);\n      for (const exportRef of analysis.exports) {\n        if (isNgModule(exportRef.node, scope.compilation)) {\n          data.injectorImports.push(this.refEmitter.emit(exportRef, context).expression);\n        }\n      }\n      for (const decl of analysis.declarations) {\n        const metadata = this.metaReader.getDirectiveMetadata(decl);\n        if (metadata !== null && metadata.selector === null) {\n          throw new FatalDiagnosticError(ErrorCode.DIRECTIVE_MISSING_SELECTOR, decl.node, `Directive ${decl.node.name.text} has no selector, please add it!`);\n        }\n      }\n    }\n    if (diagnostics.length > 0) {\n      return { diagnostics };\n    }\n    if (scope === null || scope.compilation.isPoisoned || scope.exported.isPoisoned || scope.reexports === null) {\n      return { data };\n    } else {\n      return {\n        data,\n        reexports: scope.reexports\n      };\n    }\n  }\n  compileFull(node, { inj, mod, fac, classMetadata, declarations }, { injectorImports }) {\n    const factoryFn = compileNgFactoryDefField(fac);\n    const ngInjectorDef = compileInjector(this.mergeInjectorImports(inj, injectorImports));\n    const ngModuleDef = compileNgModule(mod);\n    const statements = ngModuleDef.statements;\n    const metadata = classMetadata !== null ? compileClassMetadata2(classMetadata) : null;\n    this.insertMetadataStatement(statements, metadata);\n    this.appendRemoteScopingStatements(statements, node, declarations);\n    return this.compileNgModule(factoryFn, ngInjectorDef, ngModuleDef);\n  }\n  compilePartial(node, { inj, fac, mod, classMetadata }, { injectorImports }) {\n    const factoryFn = compileDeclareFactory(fac);\n    const injectorDef = compileDeclareInjectorFromMetadata(this.mergeInjectorImports(inj, injectorImports));\n    const ngModuleDef = compileDeclareNgModuleFromMetadata(mod);\n    const metadata = classMetadata !== null ? compileDeclareClassMetadata2(classMetadata) : null;\n    this.insertMetadataStatement(ngModuleDef.statements, metadata);\n    return this.compileNgModule(factoryFn, injectorDef, ngModuleDef);\n  }\n  mergeInjectorImports(inj, injectorImports) {\n    return __spreadProps(__spreadValues({}, inj), { imports: [...inj.imports, ...injectorImports] });\n  }\n  insertMetadataStatement(ngModuleStatements, metadata) {\n    if (metadata !== null) {\n      ngModuleStatements.unshift(metadata.toStmt());\n    }\n  }\n  appendRemoteScopingStatements(ngModuleStatements, node, declarations) {\n    const context = getSourceFile(node);\n    for (const decl of declarations) {\n      const remoteScope = this.scopeRegistry.getRemoteScope(decl.node);\n      if (remoteScope !== null) {\n        const directives = remoteScope.directives.map((directive) => this.refEmitter.emit(directive, context).expression);\n        const pipes = remoteScope.pipes.map((pipe) => this.refEmitter.emit(pipe, context).expression);\n        const directiveArray = new LiteralArrayExpr2(directives);\n        const pipesArray = new LiteralArrayExpr2(pipes);\n        const declExpr = this.refEmitter.emit(decl, context).expression;\n        const setComponentScope = new ExternalExpr4(R3Identifiers.setComponentScope);\n        const callExpr = new InvokeFunctionExpr(setComponentScope, [declExpr, directiveArray, pipesArray]);\n        ngModuleStatements.push(callExpr.toStmt());\n      }\n    }\n  }\n  compileNgModule(factoryFn, injectorDef, ngModuleDef) {\n    const res = [\n      factoryFn,\n      {\n        name: \"\\u0275mod\",\n        initializer: ngModuleDef.expression,\n        statements: ngModuleDef.statements,\n        type: ngModuleDef.type\n      },\n      {\n        name: \"\\u0275inj\",\n        initializer: injectorDef.expression,\n        statements: injectorDef.statements,\n        type: injectorDef.type\n      }\n    ];\n    return res;\n  }\n  _toR3Reference(valueRef, valueContext, typeContext) {\n    if (valueRef.hasOwningModuleGuess) {\n      return toR3Reference(valueRef, valueRef, valueContext, valueContext, this.refEmitter);\n    } else {\n      let typeRef = valueRef;\n      let typeNode = this.reflector.getDtsDeclaration(typeRef.node);\n      if (typeNode !== null && isNamedClassDeclaration(typeNode)) {\n        typeRef = new Reference(typeNode);\n      }\n      return toR3Reference(valueRef, typeRef, valueContext, typeContext, this.refEmitter);\n    }\n  }\n  _extractModuleFromModuleWithProvidersFn(node) {\n    const type = node.type || null;\n    return type && (this._reflectModuleFromTypeParam(type, node) || this._reflectModuleFromLiteralType(type));\n  }\n  _reflectModuleFromTypeParam(type, node) {\n    if (!ts18.isTypeReferenceNode(type)) {\n      return null;\n    }\n    const typeName = type && (ts18.isIdentifier(type.typeName) && type.typeName || ts18.isQualifiedName(type.typeName) && type.typeName.right) || null;\n    if (typeName === null) {\n      return null;\n    }\n    const id = this.reflector.getImportOfIdentifier(typeName);\n    if (id === null || id.name !== \"ModuleWithProviders\") {\n      return null;\n    }\n    if (!this.isCore && id.from !== \"@angular/core\") {\n      return null;\n    }\n    if (type.typeArguments === void 0 || type.typeArguments.length !== 1) {\n      const parent = ts18.isMethodDeclaration(node) && ts18.isClassDeclaration(node.parent) ? node.parent : null;\n      const symbolName = (parent && parent.name ? parent.name.getText() + \".\" : \"\") + (node.name ? node.name.getText() : \"anonymous\");\n      throw new FatalDiagnosticError(ErrorCode.NGMODULE_MODULE_WITH_PROVIDERS_MISSING_GENERIC, type, `${symbolName} returns a ModuleWithProviders type without a generic type argument. Please add a generic type argument to the ModuleWithProviders type. If this occurrence is in library code you don't control, please contact the library authors.`);\n    }\n    const arg = type.typeArguments[0];\n    return typeNodeToValueExpr(arg);\n  }\n  _reflectModuleFromLiteralType(type) {\n    if (!ts18.isIntersectionTypeNode(type)) {\n      return null;\n    }\n    for (const t of type.types) {\n      if (ts18.isTypeLiteralNode(t)) {\n        for (const m of t.members) {\n          const ngModuleType = ts18.isPropertySignature(m) && ts18.isIdentifier(m.name) && m.name.text === \"ngModule\" && m.type || null;\n          const ngModuleExpression = ngModuleType && typeNodeToValueExpr(ngModuleType);\n          if (ngModuleExpression) {\n            return ngModuleExpression;\n          }\n        }\n      }\n    }\n    return null;\n  }\n  isClassDeclarationReference(ref) {\n    return this.reflector.isClass(ref.node);\n  }\n  resolveTypeList(expr, resolvedList, className, arrayName) {\n    const refList = [];\n    if (!Array.isArray(resolvedList)) {\n      throw createValueHasWrongTypeError(expr, resolvedList, `Expected array when reading the NgModule.${arrayName} of ${className}`);\n    }\n    resolvedList.forEach((entry, idx) => {\n      if (entry instanceof Map && entry.has(\"ngModule\")) {\n        entry = entry.get(\"ngModule\");\n      }\n      if (Array.isArray(entry)) {\n        refList.push(...this.resolveTypeList(expr, entry, className, arrayName));\n      } else if (entry instanceof Reference) {\n        if (!this.isClassDeclarationReference(entry)) {\n          throw createValueHasWrongTypeError(entry.node, entry, `Value at position ${idx} in the NgModule.${arrayName} of ${className} is not a class`);\n        }\n        refList.push(entry);\n      } else {\n        throw createValueHasWrongTypeError(expr, entry, `Value at position ${idx} in the NgModule.${arrayName} of ${className} is not a reference`);\n      }\n    });\n    return refList;\n  }\n};\nfunction isNgModule(node, compilation) {\n  return !compilation.directives.some((directive) => directive.ref.node === node) && !compilation.pipes.some((pipe) => pipe.ref.node === node);\n}\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/src/component.mjs\nvar EMPTY_MAP = new Map();\nvar EMPTY_ARRAY = [];\nvar ComponentSymbol = class extends DirectiveSymbol {\n  constructor() {\n    super(...arguments);\n    this.usedDirectives = [];\n    this.usedPipes = [];\n    this.isRemotelyScoped = false;\n  }\n  isEmitAffected(previousSymbol, publicApiAffected) {\n    if (!(previousSymbol instanceof ComponentSymbol)) {\n      return true;\n    }\n    const isSymbolUnaffected = (current, previous) => isReferenceEqual(current, previous) && !publicApiAffected.has(current.symbol);\n    return this.isRemotelyScoped !== previousSymbol.isRemotelyScoped || !isArrayEqual(this.usedDirectives, previousSymbol.usedDirectives, isSymbolUnaffected) || !isArrayEqual(this.usedPipes, previousSymbol.usedPipes, isSymbolUnaffected);\n  }\n  isTypeCheckBlockAffected(previousSymbol, typeCheckApiAffected) {\n    if (!(previousSymbol instanceof ComponentSymbol)) {\n      return true;\n    }\n    const isInheritanceChainAffected = (symbol) => {\n      let currentSymbol = symbol;\n      while (currentSymbol instanceof DirectiveSymbol) {\n        if (typeCheckApiAffected.has(currentSymbol)) {\n          return true;\n        }\n        currentSymbol = currentSymbol.baseClass;\n      }\n      return false;\n    };\n    const isDirectiveUnaffected = (current, previous) => isReferenceEqual(current, previous) && !isInheritanceChainAffected(current.symbol);\n    const isPipeUnaffected = (current, previous) => isReferenceEqual(current, previous) && !typeCheckApiAffected.has(current.symbol);\n    return !isArrayEqual(this.usedDirectives, previousSymbol.usedDirectives, isDirectiveUnaffected) || !isArrayEqual(this.usedPipes, previousSymbol.usedPipes, isPipeUnaffected);\n  }\n};\nvar ComponentDecoratorHandler = class {\n  constructor(reflector, evaluator, metaRegistry, metaReader, scopeReader, scopeRegistry, typeCheckScopeRegistry, resourceRegistry, isCore, resourceLoader, rootDirs, defaultPreserveWhitespaces, i18nUseExternalIds, enableI18nLegacyMessageIdFormat, usePoisonedData, i18nNormalizeLineEndingsInICUs, moduleResolver, cycleAnalyzer, cycleHandlingStrategy, refEmitter, depTracker, injectableRegistry, semanticDepGraphUpdater, annotateForClosureCompiler, perf) {\n    this.reflector = reflector;\n    this.evaluator = evaluator;\n    this.metaRegistry = metaRegistry;\n    this.metaReader = metaReader;\n    this.scopeReader = scopeReader;\n    this.scopeRegistry = scopeRegistry;\n    this.typeCheckScopeRegistry = typeCheckScopeRegistry;\n    this.resourceRegistry = resourceRegistry;\n    this.isCore = isCore;\n    this.resourceLoader = resourceLoader;\n    this.rootDirs = rootDirs;\n    this.defaultPreserveWhitespaces = defaultPreserveWhitespaces;\n    this.i18nUseExternalIds = i18nUseExternalIds;\n    this.enableI18nLegacyMessageIdFormat = enableI18nLegacyMessageIdFormat;\n    this.usePoisonedData = usePoisonedData;\n    this.i18nNormalizeLineEndingsInICUs = i18nNormalizeLineEndingsInICUs;\n    this.moduleResolver = moduleResolver;\n    this.cycleAnalyzer = cycleAnalyzer;\n    this.cycleHandlingStrategy = cycleHandlingStrategy;\n    this.refEmitter = refEmitter;\n    this.depTracker = depTracker;\n    this.injectableRegistry = injectableRegistry;\n    this.semanticDepGraphUpdater = semanticDepGraphUpdater;\n    this.annotateForClosureCompiler = annotateForClosureCompiler;\n    this.perf = perf;\n    this.literalCache = new Map();\n    this.elementSchemaRegistry = new DomElementSchemaRegistry();\n    this.preanalyzeTemplateCache = new Map();\n    this.preanalyzeStylesCache = new Map();\n    this.precedence = HandlerPrecedence.PRIMARY;\n    this.name = ComponentDecoratorHandler.name;\n  }\n  detect(node, decorators) {\n    if (!decorators) {\n      return void 0;\n    }\n    const decorator = findAngularDecorator(decorators, \"Component\", this.isCore);\n    if (decorator !== void 0) {\n      return {\n        trigger: decorator.node,\n        decorator,\n        metadata: decorator\n      };\n    } else {\n      return void 0;\n    }\n  }\n  preanalyze(node, decorator) {\n    if (!this.resourceLoader.canPreload) {\n      return void 0;\n    }\n    const meta = this._resolveLiteral(decorator);\n    const component = reflectObjectLiteral(meta);\n    const containingFile = node.getSourceFile().fileName;\n    const resolveStyleUrl = (styleUrl) => {\n      try {\n        const resourceUrl = this.resourceLoader.resolve(styleUrl, containingFile);\n        return this.resourceLoader.preload(resourceUrl, { type: \"style\", containingFile });\n      } catch {\n        return void 0;\n      }\n    };\n    const templateAndTemplateStyleResources = this._preloadAndParseTemplate(node, decorator, component, containingFile).then((template) => {\n      if (template === null) {\n        return void 0;\n      }\n      return Promise.all(template.styleUrls.map((styleUrl) => resolveStyleUrl(styleUrl))).then(() => void 0);\n    });\n    const componentStyleUrls = this._extractComponentStyleUrls(component);\n    let inlineStyles;\n    if (component.has(\"styles\")) {\n      const litStyles = parseFieldArrayValue(component, \"styles\", this.evaluator);\n      if (litStyles === null) {\n        this.preanalyzeStylesCache.set(node, null);\n      } else {\n        inlineStyles = Promise.all(litStyles.map((style) => this.resourceLoader.preprocessInline(style, { type: \"style\", containingFile }))).then((styles) => {\n          this.preanalyzeStylesCache.set(node, styles);\n        });\n      }\n    } else {\n      this.preanalyzeStylesCache.set(node, null);\n    }\n    return Promise.all([\n      templateAndTemplateStyleResources,\n      inlineStyles,\n      ...componentStyleUrls.map((styleUrl) => resolveStyleUrl(styleUrl.url))\n    ]).then(() => void 0);\n  }\n  analyze(node, decorator, flags = HandlerFlags.NONE) {\n    var _a, _b;\n    this.perf.eventCount(PerfEvent.AnalyzeComponent);\n    const containingFile = node.getSourceFile().fileName;\n    this.literalCache.delete(decorator);\n    let diagnostics;\n    let isPoisoned = false;\n    const directiveResult = extractDirectiveMetadata(node, decorator, this.reflector, this.evaluator, this.isCore, flags, this.annotateForClosureCompiler, this.elementSchemaRegistry.getDefaultComponentElementName());\n    if (directiveResult === void 0) {\n      return {};\n    }\n    const { decorator: component, metadata, inputs, outputs } = directiveResult;\n    const encapsulation = (_a = this._resolveEnumValue(component, \"encapsulation\", \"ViewEncapsulation\")) != null ? _a : ViewEncapsulation.Emulated;\n    const changeDetection = this._resolveEnumValue(component, \"changeDetection\", \"ChangeDetectionStrategy\");\n    let animations = null;\n    if (component.has(\"animations\")) {\n      animations = new WrappedNodeExpr5(component.get(\"animations\"));\n    }\n    const relativeContextFilePath = this.rootDirs.reduce((previous, rootDir) => {\n      const candidate = relative(absoluteFrom(rootDir), absoluteFrom(containingFile));\n      if (previous === void 0 || candidate.length < previous.length) {\n        return candidate;\n      } else {\n        return previous;\n      }\n    }, void 0);\n    let viewProvidersRequiringFactory = null;\n    let providersRequiringFactory = null;\n    let wrappedViewProviders = null;\n    if (component.has(\"viewProviders\")) {\n      const viewProviders = component.get(\"viewProviders\");\n      viewProvidersRequiringFactory = resolveProvidersRequiringFactory(viewProviders, this.reflector, this.evaluator);\n      wrappedViewProviders = new WrappedNodeExpr5(this.annotateForClosureCompiler ? wrapFunctionExpressionsInParens(viewProviders) : viewProviders);\n    }\n    if (component.has(\"providers\")) {\n      providersRequiringFactory = resolveProvidersRequiringFactory(component.get(\"providers\"), this.reflector, this.evaluator);\n    }\n    let template;\n    if (this.preanalyzeTemplateCache.has(node)) {\n      const preanalyzed = this.preanalyzeTemplateCache.get(node);\n      this.preanalyzeTemplateCache.delete(node);\n      template = preanalyzed;\n    } else {\n      const templateDecl = this.parseTemplateDeclaration(decorator, component, containingFile);\n      template = this.extractTemplate(node, templateDecl);\n    }\n    const templateResource = template.declaration.isInline ? { path: null, expression: component.get(\"template\") } : {\n      path: absoluteFrom(template.declaration.resolvedTemplateUrl),\n      expression: template.sourceMapping.node\n    };\n    let styles = [];\n    const styleResources = this._extractStyleResources(component, containingFile);\n    const styleUrls = [\n      ...this._extractComponentStyleUrls(component),\n      ...this._extractTemplateStyleUrls(template)\n    ];\n    for (const styleUrl of styleUrls) {\n      try {\n        const resourceUrl = this.resourceLoader.resolve(styleUrl.url, containingFile);\n        const resourceStr = this.resourceLoader.load(resourceUrl);\n        styles.push(resourceStr);\n        if (this.depTracker !== null) {\n          this.depTracker.addResourceDependency(node.getSourceFile(), absoluteFrom(resourceUrl));\n        }\n      } catch {\n        if (diagnostics === void 0) {\n          diagnostics = [];\n        }\n        const resourceType = styleUrl.source === 2 ? 2 : 1;\n        diagnostics.push(this.makeResourceNotFoundError(styleUrl.url, styleUrl.nodeForError, resourceType).toDiagnostic());\n      }\n    }\n    if (encapsulation === ViewEncapsulation.ShadowDom && metadata.selector !== null) {\n      const selectorError = checkCustomElementSelectorForErrors(metadata.selector);\n      if (selectorError !== null) {\n        if (diagnostics === void 0) {\n          diagnostics = [];\n        }\n        diagnostics.push(makeDiagnostic(ErrorCode.COMPONENT_INVALID_SHADOW_DOM_SELECTOR, component.get(\"selector\"), selectorError));\n      }\n    }\n    let inlineStyles = null;\n    if (this.preanalyzeStylesCache.has(node)) {\n      inlineStyles = this.preanalyzeStylesCache.get(node);\n      this.preanalyzeStylesCache.delete(node);\n      if (inlineStyles !== null) {\n        styles.push(...inlineStyles);\n      }\n    } else {\n      if (this.resourceLoader.canPreprocess) {\n        throw new Error(\"Inline resource processing requires asynchronous preanalyze.\");\n      }\n      if (component.has(\"styles\")) {\n        const litStyles = parseFieldArrayValue(component, \"styles\", this.evaluator);\n        if (litStyles !== null) {\n          inlineStyles = [...litStyles];\n          styles.push(...litStyles);\n        }\n      }\n    }\n    if (template.styles.length > 0) {\n      styles.push(...template.styles);\n    }\n    const output = {\n      analysis: {\n        baseClass: readBaseClass(node, this.reflector, this.evaluator),\n        inputs,\n        outputs,\n        meta: __spreadProps(__spreadValues({}, metadata), {\n          template: {\n            nodes: template.nodes,\n            ngContentSelectors: template.ngContentSelectors\n          },\n          encapsulation,\n          interpolation: (_b = template.interpolationConfig) != null ? _b : DEFAULT_INTERPOLATION_CONFIG,\n          styles,\n          animations,\n          viewProviders: wrappedViewProviders,\n          i18nUseExternalIds: this.i18nUseExternalIds,\n          relativeContextFilePath\n        }),\n        typeCheckMeta: extractDirectiveTypeCheckMeta(node, inputs, this.reflector),\n        classMetadata: extractClassMetadata(node, this.reflector, this.isCore, this.annotateForClosureCompiler, (dec) => this._transformDecoratorToInlineResources(dec, component, styles, template)),\n        template,\n        providersRequiringFactory,\n        viewProvidersRequiringFactory,\n        inlineStyles,\n        styleUrls,\n        resources: {\n          styles: styleResources,\n          template: templateResource\n        },\n        isPoisoned\n      },\n      diagnostics\n    };\n    if (changeDetection !== null) {\n      output.analysis.meta.changeDetection = changeDetection;\n    }\n    return output;\n  }\n  symbol(node, analysis) {\n    const typeParameters = extractSemanticTypeParameters(node);\n    return new ComponentSymbol(node, analysis.meta.selector, analysis.inputs, analysis.outputs, analysis.meta.exportAs, analysis.typeCheckMeta, typeParameters);\n  }\n  register(node, analysis) {\n    const ref = new Reference(node);\n    this.metaRegistry.registerDirectiveMetadata(__spreadProps(__spreadValues({\n      type: MetaType.Directive,\n      ref,\n      name: node.name.text,\n      selector: analysis.meta.selector,\n      exportAs: analysis.meta.exportAs,\n      inputs: analysis.inputs,\n      outputs: analysis.outputs,\n      queries: analysis.meta.queries.map((query) => query.propertyName),\n      isComponent: true,\n      baseClass: analysis.baseClass\n    }, analysis.typeCheckMeta), {\n      isPoisoned: analysis.isPoisoned,\n      isStructural: false\n    }));\n    this.resourceRegistry.registerResources(analysis.resources, node);\n    this.injectableRegistry.registerInjectable(node);\n  }\n  index(context, node, analysis) {\n    if (analysis.isPoisoned && !this.usePoisonedData) {\n      return null;\n    }\n    const scope = this.scopeReader.getScopeForComponent(node);\n    const selector = analysis.meta.selector;\n    const matcher = new SelectorMatcher();\n    if (scope !== null) {\n      if ((scope.compilation.isPoisoned || scope.exported.isPoisoned) && !this.usePoisonedData) {\n        return null;\n      }\n      for (const directive of scope.compilation.directives) {\n        if (directive.selector !== null) {\n          matcher.addSelectables(CssSelector.parse(directive.selector), directive);\n        }\n      }\n    }\n    const binder = new R3TargetBinder(matcher);\n    const boundTemplate = binder.bind({ template: analysis.template.diagNodes });\n    context.addComponent({\n      declaration: node,\n      selector,\n      boundTemplate,\n      templateMeta: {\n        isInline: analysis.template.declaration.isInline,\n        file: analysis.template.file\n      }\n    });\n  }\n  typeCheck(ctx, node, meta) {\n    if (this.typeCheckScopeRegistry === null || !ts19.isClassDeclaration(node)) {\n      return;\n    }\n    if (meta.isPoisoned && !this.usePoisonedData) {\n      return;\n    }\n    const scope = this.typeCheckScopeRegistry.getTypeCheckScope(node);\n    if (scope.isPoisoned && !this.usePoisonedData) {\n      return;\n    }\n    const binder = new R3TargetBinder(scope.matcher);\n    ctx.addTemplate(new Reference(node), binder, meta.template.diagNodes, scope.pipes, scope.schemas, meta.template.sourceMapping, meta.template.file, meta.template.errors);\n  }\n  extendedTemplateCheck(component, extendedTemplateChecker) {\n    return extendedTemplateChecker.getDiagnosticsForComponent(component);\n  }\n  resolve(node, analysis, symbol) {\n    if (this.semanticDepGraphUpdater !== null && analysis.baseClass instanceof Reference) {\n      symbol.baseClass = this.semanticDepGraphUpdater.getSymbol(analysis.baseClass.node);\n    }\n    if (analysis.isPoisoned && !this.usePoisonedData) {\n      return {};\n    }\n    const context = node.getSourceFile();\n    const scope = this.scopeReader.getScopeForComponent(node);\n    let metadata = analysis.meta;\n    const data = {\n      directives: EMPTY_ARRAY,\n      pipes: EMPTY_MAP,\n      declarationListEmitMode: 0\n    };\n    if (scope !== null && (!scope.compilation.isPoisoned || this.usePoisonedData)) {\n      const matcher = new SelectorMatcher();\n      for (const dir of scope.compilation.directives) {\n        if (dir.selector !== null) {\n          matcher.addSelectables(CssSelector.parse(dir.selector), dir);\n        }\n      }\n      const pipes = new Map();\n      for (const pipe of scope.compilation.pipes) {\n        pipes.set(pipe.name, pipe.ref);\n      }\n      const binder = new R3TargetBinder(matcher);\n      const bound = binder.bind({ template: metadata.template.nodes });\n      const usedDirectives = bound.getUsedDirectives().map((directive) => {\n        const type = this.refEmitter.emit(directive.ref, context);\n        return {\n          ref: directive.ref,\n          type: type.expression,\n          importedFile: type.importedFile,\n          selector: directive.selector,\n          inputs: directive.inputs.propertyNames,\n          outputs: directive.outputs.propertyNames,\n          exportAs: directive.exportAs,\n          isComponent: directive.isComponent\n        };\n      });\n      const usedPipes = [];\n      for (const pipeName of bound.getUsedPipes()) {\n        if (!pipes.has(pipeName)) {\n          continue;\n        }\n        const pipe = pipes.get(pipeName);\n        const type = this.refEmitter.emit(pipe, context);\n        usedPipes.push({\n          ref: pipe,\n          pipeName,\n          expression: type.expression,\n          importedFile: type.importedFile\n        });\n      }\n      if (this.semanticDepGraphUpdater !== null) {\n        symbol.usedDirectives = usedDirectives.map((dir) => this.semanticDepGraphUpdater.getSemanticReference(dir.ref.node, dir.type));\n        symbol.usedPipes = usedPipes.map((pipe) => this.semanticDepGraphUpdater.getSemanticReference(pipe.ref.node, pipe.expression));\n      }\n      const cyclesFromDirectives = new Map();\n      for (const usedDirective of usedDirectives) {\n        const cycle = this._checkForCyclicImport(usedDirective.importedFile, usedDirective.type, context);\n        if (cycle !== null) {\n          cyclesFromDirectives.set(usedDirective, cycle);\n        }\n      }\n      const cyclesFromPipes = new Map();\n      for (const usedPipe of usedPipes) {\n        const cycle = this._checkForCyclicImport(usedPipe.importedFile, usedPipe.expression, context);\n        if (cycle !== null) {\n          cyclesFromPipes.set(usedPipe, cycle);\n        }\n      }\n      const cycleDetected = cyclesFromDirectives.size !== 0 || cyclesFromPipes.size !== 0;\n      if (!cycleDetected) {\n        for (const { type, importedFile } of usedDirectives) {\n          this._recordSyntheticImport(importedFile, type, context);\n        }\n        for (const { expression, importedFile } of usedPipes) {\n          this._recordSyntheticImport(importedFile, expression, context);\n        }\n        const wrapDirectivesAndPipesInClosure = usedDirectives.some((dir) => isExpressionForwardReference(dir.type, node.name, context)) || usedPipes.some((pipe) => isExpressionForwardReference(pipe.expression, node.name, context));\n        data.directives = usedDirectives;\n        data.pipes = new Map(usedPipes.map((pipe) => [pipe.pipeName, pipe.expression]));\n        data.declarationListEmitMode = wrapDirectivesAndPipesInClosure ? 1 : 0;\n      } else {\n        if (this.cycleHandlingStrategy === 0) {\n          this.scopeRegistry.setComponentRemoteScope(node, usedDirectives.map((dir) => dir.ref), usedPipes.map((pipe) => pipe.ref));\n          symbol.isRemotelyScoped = true;\n          if (this.semanticDepGraphUpdater !== null) {\n            const moduleSymbol = this.semanticDepGraphUpdater.getSymbol(scope.ngModule);\n            if (!(moduleSymbol instanceof NgModuleSymbol)) {\n              throw new Error(`AssertionError: Expected ${scope.ngModule.name} to be an NgModuleSymbol.`);\n            }\n            moduleSymbol.addRemotelyScopedComponent(symbol, symbol.usedDirectives, symbol.usedPipes);\n          }\n        } else {\n          const relatedMessages = [];\n          for (const [dir, cycle] of cyclesFromDirectives) {\n            relatedMessages.push(makeCyclicImportInfo(dir.ref, dir.isComponent ? \"component\" : \"directive\", cycle));\n          }\n          for (const [pipe, cycle] of cyclesFromPipes) {\n            relatedMessages.push(makeCyclicImportInfo(pipe.ref, \"pipe\", cycle));\n          }\n          throw new FatalDiagnosticError(ErrorCode.IMPORT_CYCLE_DETECTED, node, \"One or more import cycles would need to be created to compile this component, which is not supported by the current compiler configuration.\", relatedMessages);\n        }\n      }\n    }\n    const diagnostics = [];\n    if (analysis.providersRequiringFactory !== null && analysis.meta.providers instanceof WrappedNodeExpr5) {\n      const providerDiagnostics = getProviderDiagnostics(analysis.providersRequiringFactory, analysis.meta.providers.node, this.injectableRegistry);\n      diagnostics.push(...providerDiagnostics);\n    }\n    if (analysis.viewProvidersRequiringFactory !== null && analysis.meta.viewProviders instanceof WrappedNodeExpr5) {\n      const viewProviderDiagnostics = getProviderDiagnostics(analysis.viewProvidersRequiringFactory, analysis.meta.viewProviders.node, this.injectableRegistry);\n      diagnostics.push(...viewProviderDiagnostics);\n    }\n    const directiveDiagnostics = getDirectiveDiagnostics(node, this.metaReader, this.evaluator, this.reflector, this.scopeRegistry, \"Component\");\n    if (directiveDiagnostics !== null) {\n      diagnostics.push(...directiveDiagnostics);\n    }\n    if (diagnostics.length > 0) {\n      return { diagnostics };\n    }\n    return { data };\n  }\n  xi18n(ctx, node, analysis) {\n    var _a;\n    ctx.updateFromTemplate(analysis.template.content, analysis.template.declaration.resolvedTemplateUrl, (_a = analysis.template.interpolationConfig) != null ? _a : DEFAULT_INTERPOLATION_CONFIG);\n  }\n  updateResources(node, analysis) {\n    const containingFile = node.getSourceFile().fileName;\n    const templateDecl = analysis.template.declaration;\n    if (!templateDecl.isInline) {\n      analysis.template = this.extractTemplate(node, templateDecl);\n    }\n    let styles = [];\n    if (analysis.styleUrls !== null) {\n      for (const styleUrl of analysis.styleUrls) {\n        try {\n          const resolvedStyleUrl = this.resourceLoader.resolve(styleUrl.url, containingFile);\n          const styleText = this.resourceLoader.load(resolvedStyleUrl);\n          styles.push(styleText);\n        } catch (e) {\n        }\n      }\n    }\n    if (analysis.inlineStyles !== null) {\n      for (const styleText of analysis.inlineStyles) {\n        styles.push(styleText);\n      }\n    }\n    for (const styleText of analysis.template.styles) {\n      styles.push(styleText);\n    }\n    analysis.meta.styles = styles;\n  }\n  compileFull(node, analysis, resolution, pool) {\n    if (analysis.template.errors !== null && analysis.template.errors.length > 0) {\n      return [];\n    }\n    const meta = __spreadValues(__spreadValues({}, analysis.meta), resolution);\n    const fac = compileNgFactoryDefField(toFactoryMetadata(meta, FactoryTarget3.Component));\n    const def = compileComponentFromMetadata(meta, pool, makeBindingParser2());\n    const classMetadata = analysis.classMetadata !== null ? compileClassMetadata3(analysis.classMetadata).toStmt() : null;\n    return compileResults(fac, def, classMetadata, \"\\u0275cmp\");\n  }\n  compilePartial(node, analysis, resolution) {\n    if (analysis.template.errors !== null && analysis.template.errors.length > 0) {\n      return [];\n    }\n    const templateInfo = {\n      content: analysis.template.content,\n      sourceUrl: analysis.template.declaration.resolvedTemplateUrl,\n      isInline: analysis.template.declaration.isInline,\n      inlineTemplateLiteralExpression: analysis.template.sourceMapping.type === \"direct\" ? new WrappedNodeExpr5(analysis.template.sourceMapping.node) : null\n    };\n    const meta = __spreadValues(__spreadValues({}, analysis.meta), resolution);\n    const fac = compileDeclareFactory(toFactoryMetadata(meta, FactoryTarget3.Component));\n    const def = compileDeclareComponentFromMetadata(meta, analysis.template, templateInfo);\n    const classMetadata = analysis.classMetadata !== null ? compileDeclareClassMetadata3(analysis.classMetadata).toStmt() : null;\n    return compileResults(fac, def, classMetadata, \"\\u0275cmp\");\n  }\n  _transformDecoratorToInlineResources(dec, component, styles, template) {\n    if (dec.name !== \"Component\") {\n      return dec;\n    }\n    if (!component.has(\"templateUrl\") && !component.has(\"styleUrls\")) {\n      return dec;\n    }\n    const metadata = new Map(component);\n    if (metadata.has(\"templateUrl\")) {\n      metadata.delete(\"templateUrl\");\n      metadata.set(\"template\", ts19.createStringLiteral(template.content));\n    }\n    if (metadata.has(\"styleUrls\")) {\n      metadata.delete(\"styleUrls\");\n      metadata.set(\"styles\", ts19.createArrayLiteral(styles.map((s) => ts19.createStringLiteral(s))));\n    }\n    const newMetadataFields = [];\n    for (const [name, value] of metadata.entries()) {\n      newMetadataFields.push(ts19.createPropertyAssignment(name, value));\n    }\n    return __spreadProps(__spreadValues({}, dec), { args: [ts19.createObjectLiteral(newMetadataFields)] });\n  }\n  _resolveLiteral(decorator) {\n    if (this.literalCache.has(decorator)) {\n      return this.literalCache.get(decorator);\n    }\n    if (decorator.args === null || decorator.args.length !== 1) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(decorator), `Incorrect number of arguments to @Component decorator`);\n    }\n    const meta = unwrapExpression(decorator.args[0]);\n    if (!ts19.isObjectLiteralExpression(meta)) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, `Decorator argument must be literal.`);\n    }\n    this.literalCache.set(decorator, meta);\n    return meta;\n  }\n  _resolveEnumValue(component, field, enumSymbolName) {\n    let resolved = null;\n    if (component.has(field)) {\n      const expr = component.get(field);\n      const value = this.evaluator.evaluate(expr);\n      if (value instanceof EnumValue && isAngularCoreReference(value.enumRef, enumSymbolName)) {\n        resolved = value.resolved;\n      } else {\n        throw createValueHasWrongTypeError(expr, value, `${field} must be a member of ${enumSymbolName} enum from @angular/core`);\n      }\n    }\n    return resolved;\n  }\n  _extractComponentStyleUrls(component) {\n    if (!component.has(\"styleUrls\")) {\n      return [];\n    }\n    return this._extractStyleUrlsFromExpression(component.get(\"styleUrls\"));\n  }\n  _extractStyleUrlsFromExpression(styleUrlsExpr) {\n    const styleUrls = [];\n    if (ts19.isArrayLiteralExpression(styleUrlsExpr)) {\n      for (const styleUrlExpr of styleUrlsExpr.elements) {\n        if (ts19.isSpreadElement(styleUrlExpr)) {\n          styleUrls.push(...this._extractStyleUrlsFromExpression(styleUrlExpr.expression));\n        } else {\n          const styleUrl = this.evaluator.evaluate(styleUrlExpr);\n          if (typeof styleUrl !== \"string\") {\n            throw createValueHasWrongTypeError(styleUrlExpr, styleUrl, \"styleUrl must be a string\");\n          }\n          styleUrls.push({\n            url: styleUrl,\n            source: 2,\n            nodeForError: styleUrlExpr\n          });\n        }\n      }\n    } else {\n      const evaluatedStyleUrls = this.evaluator.evaluate(styleUrlsExpr);\n      if (!isStringArray(evaluatedStyleUrls)) {\n        throw createValueHasWrongTypeError(styleUrlsExpr, evaluatedStyleUrls, \"styleUrls must be an array of strings\");\n      }\n      for (const styleUrl of evaluatedStyleUrls) {\n        styleUrls.push({\n          url: styleUrl,\n          source: 2,\n          nodeForError: styleUrlsExpr\n        });\n      }\n    }\n    return styleUrls;\n  }\n  _extractStyleResources(component, containingFile) {\n    const styles = new Set();\n    function stringLiteralElements(array) {\n      return array.elements.filter((e) => ts19.isStringLiteralLike(e));\n    }\n    const styleUrlsExpr = component.get(\"styleUrls\");\n    if (styleUrlsExpr !== void 0 && ts19.isArrayLiteralExpression(styleUrlsExpr)) {\n      for (const expression of stringLiteralElements(styleUrlsExpr)) {\n        try {\n          const resourceUrl = this.resourceLoader.resolve(expression.text, containingFile);\n          styles.add({ path: absoluteFrom(resourceUrl), expression });\n        } catch {\n        }\n      }\n    }\n    const stylesExpr = component.get(\"styles\");\n    if (stylesExpr !== void 0 && ts19.isArrayLiteralExpression(stylesExpr)) {\n      for (const expression of stringLiteralElements(stylesExpr)) {\n        styles.add({ path: null, expression });\n      }\n    }\n    return styles;\n  }\n  _preloadAndParseTemplate(node, decorator, component, containingFile) {\n    if (component.has(\"templateUrl\")) {\n      const templateUrlExpr = component.get(\"templateUrl\");\n      const templateUrl = this.evaluator.evaluate(templateUrlExpr);\n      if (typeof templateUrl !== \"string\") {\n        throw createValueHasWrongTypeError(templateUrlExpr, templateUrl, \"templateUrl must be a string\");\n      }\n      try {\n        const resourceUrl = this.resourceLoader.resolve(templateUrl, containingFile);\n        const templatePromise = this.resourceLoader.preload(resourceUrl, { type: \"template\", containingFile });\n        if (templatePromise !== void 0) {\n          return templatePromise.then(() => {\n            const templateDecl = this.parseTemplateDeclaration(decorator, component, containingFile);\n            const template = this.extractTemplate(node, templateDecl);\n            this.preanalyzeTemplateCache.set(node, template);\n            return template;\n          });\n        } else {\n          return Promise.resolve(null);\n        }\n      } catch (e) {\n        throw this.makeResourceNotFoundError(templateUrl, templateUrlExpr, 0);\n      }\n    } else {\n      const templateDecl = this.parseTemplateDeclaration(decorator, component, containingFile);\n      const template = this.extractTemplate(node, templateDecl);\n      this.preanalyzeTemplateCache.set(node, template);\n      return Promise.resolve(template);\n    }\n  }\n  extractTemplate(node, template) {\n    if (template.isInline) {\n      let sourceStr;\n      let sourceParseRange = null;\n      let templateContent;\n      let sourceMapping;\n      let escapedString = false;\n      let sourceMapUrl;\n      if (ts19.isStringLiteral(template.expression) || ts19.isNoSubstitutionTemplateLiteral(template.expression)) {\n        sourceParseRange = getTemplateRange(template.expression);\n        sourceStr = template.expression.getSourceFile().text;\n        templateContent = template.expression.text;\n        escapedString = true;\n        sourceMapping = {\n          type: \"direct\",\n          node: template.expression\n        };\n        sourceMapUrl = template.resolvedTemplateUrl;\n      } else {\n        const resolvedTemplate = this.evaluator.evaluate(template.expression);\n        if (typeof resolvedTemplate !== \"string\") {\n          throw createValueHasWrongTypeError(template.expression, resolvedTemplate, \"template must be a string\");\n        }\n        sourceStr = resolvedTemplate;\n        templateContent = resolvedTemplate;\n        sourceMapping = {\n          type: \"indirect\",\n          node: template.expression,\n          componentClass: node,\n          template: templateContent\n        };\n        sourceMapUrl = null;\n      }\n      return __spreadProps(__spreadValues({}, this._parseTemplate(template, sourceStr, sourceParseRange, escapedString, sourceMapUrl)), {\n        content: templateContent,\n        sourceMapping,\n        declaration: template\n      });\n    } else {\n      const templateContent = this.resourceLoader.load(template.resolvedTemplateUrl);\n      if (this.depTracker !== null) {\n        this.depTracker.addResourceDependency(node.getSourceFile(), absoluteFrom(template.resolvedTemplateUrl));\n      }\n      return __spreadProps(__spreadValues({}, this._parseTemplate(template, templateContent, null, false, template.resolvedTemplateUrl)), {\n        content: templateContent,\n        sourceMapping: {\n          type: \"external\",\n          componentClass: node,\n          node: template.templateUrlExpression,\n          template: templateContent,\n          templateUrl: template.resolvedTemplateUrl\n        },\n        declaration: template\n      });\n    }\n  }\n  _parseTemplate(template, sourceStr, sourceParseRange, escapedString, sourceMapUrl) {\n    const i18nNormalizeLineEndingsInICUs = escapedString || this.i18nNormalizeLineEndingsInICUs;\n    const parsedTemplate = parseTemplate(sourceStr, sourceMapUrl != null ? sourceMapUrl : \"\", {\n      preserveWhitespaces: template.preserveWhitespaces,\n      interpolationConfig: template.interpolationConfig,\n      range: sourceParseRange != null ? sourceParseRange : void 0,\n      escapedString,\n      enableI18nLegacyMessageIdFormat: this.enableI18nLegacyMessageIdFormat,\n      i18nNormalizeLineEndingsInICUs,\n      alwaysAttemptHtmlToR3AstConversion: this.usePoisonedData\n    });\n    const { nodes: diagNodes } = parseTemplate(sourceStr, sourceMapUrl != null ? sourceMapUrl : \"\", {\n      preserveWhitespaces: true,\n      preserveLineEndings: true,\n      interpolationConfig: template.interpolationConfig,\n      range: sourceParseRange != null ? sourceParseRange : void 0,\n      escapedString,\n      enableI18nLegacyMessageIdFormat: this.enableI18nLegacyMessageIdFormat,\n      i18nNormalizeLineEndingsInICUs,\n      leadingTriviaChars: [],\n      alwaysAttemptHtmlToR3AstConversion: this.usePoisonedData\n    });\n    return __spreadProps(__spreadValues({}, parsedTemplate), {\n      diagNodes,\n      file: new ParseSourceFile2(sourceStr, sourceMapUrl != null ? sourceMapUrl : \"\")\n    });\n  }\n  parseTemplateDeclaration(decorator, component, containingFile) {\n    let preserveWhitespaces = this.defaultPreserveWhitespaces;\n    if (component.has(\"preserveWhitespaces\")) {\n      const expr = component.get(\"preserveWhitespaces\");\n      const value = this.evaluator.evaluate(expr);\n      if (typeof value !== \"boolean\") {\n        throw createValueHasWrongTypeError(expr, value, \"preserveWhitespaces must be a boolean\");\n      }\n      preserveWhitespaces = value;\n    }\n    let interpolationConfig = DEFAULT_INTERPOLATION_CONFIG;\n    if (component.has(\"interpolation\")) {\n      const expr = component.get(\"interpolation\");\n      const value = this.evaluator.evaluate(expr);\n      if (!Array.isArray(value) || value.length !== 2 || !value.every((element) => typeof element === \"string\")) {\n        throw createValueHasWrongTypeError(expr, value, \"interpolation must be an array with 2 elements of string type\");\n      }\n      interpolationConfig = InterpolationConfig.fromArray(value);\n    }\n    if (component.has(\"templateUrl\")) {\n      const templateUrlExpr = component.get(\"templateUrl\");\n      const templateUrl = this.evaluator.evaluate(templateUrlExpr);\n      if (typeof templateUrl !== \"string\") {\n        throw createValueHasWrongTypeError(templateUrlExpr, templateUrl, \"templateUrl must be a string\");\n      }\n      try {\n        const resourceUrl = this.resourceLoader.resolve(templateUrl, containingFile);\n        return {\n          isInline: false,\n          interpolationConfig,\n          preserveWhitespaces,\n          templateUrl,\n          templateUrlExpression: templateUrlExpr,\n          resolvedTemplateUrl: resourceUrl\n        };\n      } catch (e) {\n        throw this.makeResourceNotFoundError(templateUrl, templateUrlExpr, 0);\n      }\n    } else if (component.has(\"template\")) {\n      return {\n        isInline: true,\n        interpolationConfig,\n        preserveWhitespaces,\n        expression: component.get(\"template\"),\n        templateUrl: containingFile,\n        resolvedTemplateUrl: containingFile\n      };\n    } else {\n      throw new FatalDiagnosticError(ErrorCode.COMPONENT_MISSING_TEMPLATE, Decorator.nodeForError(decorator), \"component is missing a template\");\n    }\n  }\n  _resolveImportedFile(importedFile, expr, origin) {\n    if (importedFile !== \"unknown\") {\n      return importedFile;\n    }\n    if (!(expr instanceof ExternalExpr5)) {\n      return null;\n    }\n    return this.moduleResolver.resolveModule(expr.value.moduleName, origin.fileName);\n  }\n  _checkForCyclicImport(importedFile, expr, origin) {\n    const imported = this._resolveImportedFile(importedFile, expr, origin);\n    if (imported === null) {\n      return null;\n    }\n    return this.cycleAnalyzer.wouldCreateCycle(origin, imported);\n  }\n  _recordSyntheticImport(importedFile, expr, origin) {\n    const imported = this._resolveImportedFile(importedFile, expr, origin);\n    if (imported === null) {\n      return;\n    }\n    this.cycleAnalyzer.recordSyntheticImport(origin, imported);\n  }\n  makeResourceNotFoundError(file, nodeForError, resourceType) {\n    let errorText;\n    switch (resourceType) {\n      case 0:\n        errorText = `Could not find template file '${file}'.`;\n        break;\n      case 1:\n        errorText = `Could not find stylesheet file '${file}' linked from the template.`;\n        break;\n      case 2:\n        errorText = `Could not find stylesheet file '${file}'.`;\n        break;\n    }\n    return new FatalDiagnosticError(ErrorCode.COMPONENT_RESOURCE_NOT_FOUND, nodeForError, errorText);\n  }\n  _extractTemplateStyleUrls(template) {\n    if (template.styleUrls === null) {\n      return [];\n    }\n    const nodeForError = getTemplateDeclarationNodeForError(template.declaration);\n    return template.styleUrls.map((url) => ({ url, source: 1, nodeForError }));\n  }\n};\nfunction getTemplateRange(templateExpr) {\n  const startPos = templateExpr.getStart() + 1;\n  const { line, character } = ts19.getLineAndCharacterOfPosition(templateExpr.getSourceFile(), startPos);\n  return {\n    startPos,\n    startLine: line,\n    startCol: character,\n    endPos: templateExpr.getEnd() - 1\n  };\n}\nfunction isStringArray(resolvedValue) {\n  return Array.isArray(resolvedValue) && resolvedValue.every((elem) => typeof elem === \"string\");\n}\nfunction getTemplateDeclarationNodeForError(declaration) {\n  switch (declaration.isInline) {\n    case true:\n      return declaration.expression;\n    case false:\n      return declaration.templateUrlExpression;\n  }\n}\nfunction makeCyclicImportInfo(ref, type, cycle) {\n  const name = ref.debugName || \"(unknown)\";\n  const path = cycle.getPath().map((sf) => sf.fileName).join(\" -> \");\n  const message = `The ${type} '${name}' is used in the template but importing it would create a cycle: `;\n  return makeRelatedInformation(ref.node, message + path);\n}\nfunction checkCustomElementSelectorForErrors(selector) {\n  if (selector.includes(\".\") || selector.includes(\"[\") && selector.includes(\"]\")) {\n    return null;\n  }\n  if (!/^[a-z]/.test(selector)) {\n    return \"Selector of a ShadowDom-encapsulated component must start with a lower case letter.\";\n  }\n  if (/[A-Z]/.test(selector)) {\n    return \"Selector of a ShadowDom-encapsulated component must all be in lower case.\";\n  }\n  if (!selector.includes(\"-\")) {\n    return \"Selector of a component that uses ViewEncapsulation.ShadowDom must contain a hyphen.\";\n  }\n  return null;\n}\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/src/injectable.mjs\nimport { compileClassMetadata as compileClassMetadata4, compileDeclareClassMetadata as compileDeclareClassMetadata4, compileDeclareInjectableFromMetadata, compileInjectable, createMayBeForwardRefExpression as createMayBeForwardRefExpression2, FactoryTarget as FactoryTarget4, LiteralExpr as LiteralExpr3, WrappedNodeExpr as WrappedNodeExpr6 } from \"@angular/compiler\";\nimport ts20 from \"typescript\";\nvar InjectableDecoratorHandler = class {\n  constructor(reflector, isCore, strictCtorDeps, injectableRegistry, perf, errorOnDuplicateProv = true) {\n    this.reflector = reflector;\n    this.isCore = isCore;\n    this.strictCtorDeps = strictCtorDeps;\n    this.injectableRegistry = injectableRegistry;\n    this.perf = perf;\n    this.errorOnDuplicateProv = errorOnDuplicateProv;\n    this.precedence = HandlerPrecedence.SHARED;\n    this.name = InjectableDecoratorHandler.name;\n  }\n  detect(node, decorators) {\n    if (!decorators) {\n      return void 0;\n    }\n    const decorator = findAngularDecorator(decorators, \"Injectable\", this.isCore);\n    if (decorator !== void 0) {\n      return {\n        trigger: decorator.node,\n        decorator,\n        metadata: decorator\n      };\n    } else {\n      return void 0;\n    }\n  }\n  analyze(node, decorator) {\n    this.perf.eventCount(PerfEvent.AnalyzeInjectable);\n    const meta = extractInjectableMetadata(node, decorator, this.reflector);\n    const decorators = this.reflector.getDecoratorsOfDeclaration(node);\n    return {\n      analysis: {\n        meta,\n        ctorDeps: extractInjectableCtorDeps(node, meta, decorator, this.reflector, this.isCore, this.strictCtorDeps),\n        classMetadata: extractClassMetadata(node, this.reflector, this.isCore),\n        needsFactory: !decorators || decorators.every((current) => !isAngularCore(current) || current.name === \"Injectable\")\n      }\n    };\n  }\n  symbol() {\n    return null;\n  }\n  register(node) {\n    this.injectableRegistry.registerInjectable(node);\n  }\n  compileFull(node, analysis) {\n    return this.compile(compileNgFactoryDefField, (meta) => compileInjectable(meta, false), compileClassMetadata4, node, analysis);\n  }\n  compilePartial(node, analysis) {\n    return this.compile(compileDeclareFactory, compileDeclareInjectableFromMetadata, compileDeclareClassMetadata4, node, analysis);\n  }\n  compile(compileFactoryFn, compileInjectableFn, compileClassMetadataFn, node, analysis) {\n    const results = [];\n    if (analysis.needsFactory) {\n      const meta = analysis.meta;\n      const factoryRes = compileFactoryFn(toFactoryMetadata(__spreadProps(__spreadValues({}, meta), { deps: analysis.ctorDeps }), FactoryTarget4.Injectable));\n      if (analysis.classMetadata !== null) {\n        factoryRes.statements.push(compileClassMetadataFn(analysis.classMetadata).toStmt());\n      }\n      results.push(factoryRes);\n    }\n    const \\u0275prov = this.reflector.getMembersOfClass(node).find((member) => member.name === \"\\u0275prov\");\n    if (\\u0275prov !== void 0 && this.errorOnDuplicateProv) {\n      throw new FatalDiagnosticError(ErrorCode.INJECTABLE_DUPLICATE_PROV, \\u0275prov.nameNode || \\u0275prov.node || node, \"Injectables cannot contain a static \\u0275prov property, because the compiler is going to generate one.\");\n    }\n    if (\\u0275prov === void 0) {\n      const res = compileInjectableFn(analysis.meta);\n      results.push({ name: \"\\u0275prov\", initializer: res.expression, statements: res.statements, type: res.type });\n    }\n    return results;\n  }\n};\nfunction extractInjectableMetadata(clazz, decorator, reflector) {\n  const name = clazz.name.text;\n  const type = wrapTypeReference(reflector, clazz);\n  const internalType = new WrappedNodeExpr6(reflector.getInternalNameOfClass(clazz));\n  const typeArgumentCount = reflector.getGenericArityOfClass(clazz) || 0;\n  if (decorator.args === null) {\n    throw new FatalDiagnosticError(ErrorCode.DECORATOR_NOT_CALLED, Decorator.nodeForError(decorator), \"@Injectable must be called\");\n  }\n  if (decorator.args.length === 0) {\n    return {\n      name,\n      type,\n      typeArgumentCount,\n      internalType,\n      providedIn: createMayBeForwardRefExpression2(new LiteralExpr3(null), 0)\n    };\n  } else if (decorator.args.length === 1) {\n    const metaNode = decorator.args[0];\n    if (!ts20.isObjectLiteralExpression(metaNode)) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, metaNode, `@Injectable argument must be an object literal`);\n    }\n    const meta = reflectObjectLiteral(metaNode);\n    const providedIn = meta.has(\"providedIn\") ? getProviderExpression(meta.get(\"providedIn\"), reflector) : createMayBeForwardRefExpression2(new LiteralExpr3(null), 0);\n    let deps = void 0;\n    if ((meta.has(\"useClass\") || meta.has(\"useFactory\")) && meta.has(\"deps\")) {\n      const depsExpr = meta.get(\"deps\");\n      if (!ts20.isArrayLiteralExpression(depsExpr)) {\n        throw new FatalDiagnosticError(ErrorCode.VALUE_NOT_LITERAL, depsExpr, `@Injectable deps metadata must be an inline array`);\n      }\n      deps = depsExpr.elements.map((dep) => getDep(dep, reflector));\n    }\n    const result = { name, type, typeArgumentCount, internalType, providedIn };\n    if (meta.has(\"useValue\")) {\n      result.useValue = getProviderExpression(meta.get(\"useValue\"), reflector);\n    } else if (meta.has(\"useExisting\")) {\n      result.useExisting = getProviderExpression(meta.get(\"useExisting\"), reflector);\n    } else if (meta.has(\"useClass\")) {\n      result.useClass = getProviderExpression(meta.get(\"useClass\"), reflector);\n      result.deps = deps;\n    } else if (meta.has(\"useFactory\")) {\n      result.useFactory = new WrappedNodeExpr6(meta.get(\"useFactory\"));\n      result.deps = deps;\n    }\n    return result;\n  } else {\n    throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, decorator.args[2], \"Too many arguments to @Injectable\");\n  }\n}\nfunction getProviderExpression(expression, reflector) {\n  const forwardRefValue = tryUnwrapForwardRef(expression, reflector);\n  return createMayBeForwardRefExpression2(new WrappedNodeExpr6(forwardRefValue != null ? forwardRefValue : expression), forwardRefValue !== null ? 2 : 0);\n}\nfunction extractInjectableCtorDeps(clazz, meta, decorator, reflector, isCore, strictCtorDeps) {\n  if (decorator.args === null) {\n    throw new FatalDiagnosticError(ErrorCode.DECORATOR_NOT_CALLED, Decorator.nodeForError(decorator), \"@Injectable must be called\");\n  }\n  let ctorDeps = null;\n  if (decorator.args.length === 0) {\n    if (strictCtorDeps) {\n      ctorDeps = getValidConstructorDependencies(clazz, reflector, isCore);\n    } else {\n      ctorDeps = unwrapConstructorDependencies(getConstructorDependencies(clazz, reflector, isCore));\n    }\n    return ctorDeps;\n  } else if (decorator.args.length === 1) {\n    const rawCtorDeps = getConstructorDependencies(clazz, reflector, isCore);\n    if (strictCtorDeps && meta.useValue === void 0 && meta.useExisting === void 0 && meta.useClass === void 0 && meta.useFactory === void 0) {\n      ctorDeps = validateConstructorDependencies(clazz, rawCtorDeps);\n    } else {\n      ctorDeps = unwrapConstructorDependencies(rawCtorDeps);\n    }\n  }\n  return ctorDeps;\n}\nfunction getDep(dep, reflector) {\n  const meta = {\n    token: new WrappedNodeExpr6(dep),\n    attributeNameType: null,\n    host: false,\n    optional: false,\n    self: false,\n    skipSelf: false\n  };\n  function maybeUpdateDecorator(dec, reflector2, token) {\n    const source = reflector2.getImportOfIdentifier(dec);\n    if (source === null || source.from !== \"@angular/core\") {\n      return false;\n    }\n    switch (source.name) {\n      case \"Inject\":\n        if (token !== void 0) {\n          meta.token = new WrappedNodeExpr6(token);\n        }\n        break;\n      case \"Optional\":\n        meta.optional = true;\n        break;\n      case \"SkipSelf\":\n        meta.skipSelf = true;\n        break;\n      case \"Self\":\n        meta.self = true;\n        break;\n      default:\n        return false;\n    }\n    return true;\n  }\n  if (ts20.isArrayLiteralExpression(dep)) {\n    dep.elements.forEach((el) => {\n      let isDecorator = false;\n      if (ts20.isIdentifier(el)) {\n        isDecorator = maybeUpdateDecorator(el, reflector);\n      } else if (ts20.isNewExpression(el) && ts20.isIdentifier(el.expression)) {\n        const token = el.arguments && el.arguments.length > 0 && el.arguments[0] || void 0;\n        isDecorator = maybeUpdateDecorator(el.expression, reflector, token);\n      }\n      if (!isDecorator) {\n        meta.token = new WrappedNodeExpr6(el);\n      }\n    });\n  }\n  return meta;\n}\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/src/pipe.mjs\nimport { compileClassMetadata as compileClassMetadata5, compileDeclareClassMetadata as compileDeclareClassMetadata5, compileDeclarePipeFromMetadata, compilePipeFromMetadata, FactoryTarget as FactoryTarget5, WrappedNodeExpr as WrappedNodeExpr7 } from \"@angular/compiler\";\nimport ts21 from \"typescript\";\nvar PipeSymbol = class extends SemanticSymbol {\n  constructor(decl, name) {\n    super(decl);\n    this.name = name;\n  }\n  isPublicApiAffected(previousSymbol) {\n    if (!(previousSymbol instanceof PipeSymbol)) {\n      return true;\n    }\n    return this.name !== previousSymbol.name;\n  }\n  isTypeCheckApiAffected(previousSymbol) {\n    return this.isPublicApiAffected(previousSymbol);\n  }\n};\nvar PipeDecoratorHandler = class {\n  constructor(reflector, evaluator, metaRegistry, scopeRegistry, injectableRegistry, isCore, perf) {\n    this.reflector = reflector;\n    this.evaluator = evaluator;\n    this.metaRegistry = metaRegistry;\n    this.scopeRegistry = scopeRegistry;\n    this.injectableRegistry = injectableRegistry;\n    this.isCore = isCore;\n    this.perf = perf;\n    this.precedence = HandlerPrecedence.PRIMARY;\n    this.name = PipeDecoratorHandler.name;\n  }\n  detect(node, decorators) {\n    if (!decorators) {\n      return void 0;\n    }\n    const decorator = findAngularDecorator(decorators, \"Pipe\", this.isCore);\n    if (decorator !== void 0) {\n      return {\n        trigger: decorator.node,\n        decorator,\n        metadata: decorator\n      };\n    } else {\n      return void 0;\n    }\n  }\n  analyze(clazz, decorator) {\n    this.perf.eventCount(PerfEvent.AnalyzePipe);\n    const name = clazz.name.text;\n    const type = wrapTypeReference(this.reflector, clazz);\n    const internalType = new WrappedNodeExpr7(this.reflector.getInternalNameOfClass(clazz));\n    if (decorator.args === null) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_NOT_CALLED, Decorator.nodeForError(decorator), `@Pipe must be called`);\n    }\n    if (decorator.args.length !== 1) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(decorator), \"@Pipe must have exactly one argument\");\n    }\n    const meta = unwrapExpression(decorator.args[0]);\n    if (!ts21.isObjectLiteralExpression(meta)) {\n      throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, \"@Pipe must have a literal argument\");\n    }\n    const pipe = reflectObjectLiteral(meta);\n    if (!pipe.has(\"name\")) {\n      throw new FatalDiagnosticError(ErrorCode.PIPE_MISSING_NAME, meta, `@Pipe decorator is missing name field`);\n    }\n    const pipeNameExpr = pipe.get(\"name\");\n    const pipeName = this.evaluator.evaluate(pipeNameExpr);\n    if (typeof pipeName !== \"string\") {\n      throw createValueHasWrongTypeError(pipeNameExpr, pipeName, `@Pipe.name must be a string`);\n    }\n    let pure = true;\n    if (pipe.has(\"pure\")) {\n      const expr = pipe.get(\"pure\");\n      const pureValue = this.evaluator.evaluate(expr);\n      if (typeof pureValue !== \"boolean\") {\n        throw createValueHasWrongTypeError(expr, pureValue, `@Pipe.pure must be a boolean`);\n      }\n      pure = pureValue;\n    }\n    return {\n      analysis: {\n        meta: {\n          name,\n          type,\n          internalType,\n          typeArgumentCount: this.reflector.getGenericArityOfClass(clazz) || 0,\n          pipeName,\n          deps: getValidConstructorDependencies(clazz, this.reflector, this.isCore),\n          pure\n        },\n        classMetadata: extractClassMetadata(clazz, this.reflector, this.isCore),\n        pipeNameExpr\n      }\n    };\n  }\n  symbol(node, analysis) {\n    return new PipeSymbol(node, analysis.meta.name);\n  }\n  register(node, analysis) {\n    const ref = new Reference(node);\n    this.metaRegistry.registerPipeMetadata({ type: MetaType.Pipe, ref, name: analysis.meta.pipeName, nameExpr: analysis.pipeNameExpr });\n    this.injectableRegistry.registerInjectable(node);\n  }\n  resolve(node) {\n    const duplicateDeclData = this.scopeRegistry.getDuplicateDeclarations(node);\n    if (duplicateDeclData !== null) {\n      return {\n        diagnostics: [makeDuplicateDeclarationError(node, duplicateDeclData, \"Pipe\")]\n      };\n    }\n    return {};\n  }\n  compileFull(node, analysis) {\n    const fac = compileNgFactoryDefField(toFactoryMetadata(analysis.meta, FactoryTarget5.Pipe));\n    const def = compilePipeFromMetadata(analysis.meta);\n    const classMetadata = analysis.classMetadata !== null ? compileClassMetadata5(analysis.classMetadata).toStmt() : null;\n    return compileResults(fac, def, classMetadata, \"\\u0275pipe\");\n  }\n  compilePartial(node, analysis) {\n    const fac = compileDeclareFactory(toFactoryMetadata(analysis.meta, FactoryTarget5.Pipe));\n    const def = compileDeclarePipeFromMetadata(analysis.meta);\n    const classMetadata = analysis.classMetadata !== null ? compileDeclareClassMetadata5(analysis.classMetadata).toStmt() : null;\n    return compileResults(fac, def, classMetadata, \"\\u0275pipe\");\n  }\n};\n\n// bazel-out/darwin-fastbuild/bin/packages/compiler-cli/src/ngtsc/annotations/src/references_registry.mjs\nvar NoopReferencesRegistry = class {\n  add(source, ...references) {\n  }\n};\n\nexport {\n  ErrorCode,\n  COMPILER_ERRORS_WITH_GUIDES,\n  replaceTsWithNgInErrors,\n  ngErrorCode,\n  makeDiagnostic,\n  makeRelatedInformation,\n  isFatalDiagnosticError,\n  ERROR_DETAILS_PAGE_BASE_URL,\n  SemanticDepGraphUpdater,\n  CompoundMetadataReader,\n  DtsMetadataReader,\n  flattenInheritedDirectiveMetadata,\n  LocalMetadataRegistry,\n  CompoundMetadataRegistry,\n  InjectableClassRegistry,\n  ResourceRegistry,\n  DynamicValue,\n  StaticInterpreter,\n  PartialEvaluator,\n  CompilationMode,\n  HandlerFlags,\n  aliasTransformFactory,\n  TraitState,\n  TraitCompiler,\n  DtsTransformRegistry,\n  declarationTransformFactory,\n  ivyTransformFactory,\n  forwardRefResolver,\n  readBaseClass,\n  DirectiveDecoratorHandler,\n  NgModuleDecoratorHandler,\n  ComponentDecoratorHandler,\n  InjectableDecoratorHandler,\n  PipeDecoratorHandler,\n  NoopReferencesRegistry\n};\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n"]},"metadata":{},"sourceType":"module"}